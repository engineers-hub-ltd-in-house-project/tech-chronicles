# UNIXという思想

## ——パイプ、プロセス、ファイル――すべてはここから始まった

### 第2回：Multicsの挫折——UNIXが生まれた必然

**連載「UNIXという思想——パイプ、プロセス、ファイル――すべてはここから始まった」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- UNIXの前身であるMulticsがどのような野心を持ち、なぜ肥大化したのか
- CTSS（1961年）からMultics（1965年〜）、そしてUNIX（1969年〜）に至る技術系譜
- PDP-7という制約がUNIXの設計哲学をどのように形成したか
- 「シンプルさ」が美学ではなく生存戦略であったという事実
- 極小メモリ環境でのファイルシステムとプロセス管理の疑似体験

---

## 1. 複雑さに殺されたプロジェクト

2007年のことだった。私は、ある大規模業務システムの刷新プロジェクトに参加していた。既存システムの機能をすべて網羅し、さらに将来の拡張にも対応できる「理想的な」アーキテクチャを設計する——それがプロジェクトの目標だった。

設計書は膨れ上がった。要件定義だけで半年。基本設計でさらに半年。すべてのユースケースを想定し、すべてのエッジケースに対応し、すべてのステークホルダーの要望を取り込んだ。設計書のページ数は4桁に達した。

実装が始まると、設計書の矛盾が次々と発覚した。あるモジュールの前提条件が別のモジュールの前提条件と衝突する。インタフェースの定義が曖昧で、チーム間の認識がずれている。設計変更のたびに影響範囲が雪だるま式に拡大する。当初2年の計画は3年になり、4年になり、結局は要件を大幅に削減して「最低限動くもの」をリリースすることになった。

この経験を経て数年後、Multicsの歴史を初めて詳しく読んだとき、私は既視感に打たれた。1960年代のMITとBell Labsで起きたことは、40年後の日本のSIerの現場で起きたこととまったく同じだった。機能を足せば足すほどシステムは良くなる——その信仰が、プロジェクトを押しつぶした。

UNIXは、この「複雑さの病」への処方箋として生まれた。だが、それは意識的な選択というよりも、制約に強いられた必然だった。UNIXが「シンプルさ」を選んだのではない。シンプルにしか作れない環境に放り込まれたのだ。そして、その強いられたシンプルさが、57年間生き延びる設計哲学に昇華した。

あなたが今まで経験した「複雑になりすぎて失敗したプロジェクト」を思い浮かべてほしい。その構造は、おそらくMulticsと同型だ。

---

## 2. タイムシェアリングの夢——CTSSからMulticsへ

### コンピュータを「公共事業」にする

UNIXの物語を語るには、その前史から始めなければならない。

1960年代初頭、コンピュータは「バッチ処理」の時代にあった。ユーザはプログラムをパンチカードに書き、オペレータに渡し、数時間後——ときには翌日——に結果を受け取る。プログラムにバグがあれば、修正してまた数時間待つ。一台の高価なコンピュータを効率よく使うための仕組みだったが、プログラマにとっては苦行だった。

この状況に風穴を開けたのが、MITのFernando Corbatoだった。1961年11月、Corbatoのチーム——Marjorie DaggettとRobert Daleyを含む——は、IBM 709上でCTSS（Compatible Time-Sharing System）を稼働させた。CTSSは、最初の汎用タイムシェアリングシステムだった。複数のユーザが端末からコンピュータに同時にアクセスし、対話的にプログラムを実行できる。パスワードログインを最初に実装したシステムでもある。

CTSSの成功は、一つの夢を生んだ。コンピュータを電気や水道のような「公共事業（utility）」にできないか。電話を取るように端末に向かい、必要な計算能力を必要なだけ使う。MIT教授のMartin Greenbergerは1964年のAtlantic Monthly誌で「The Computers of Tomorrow」と題してこの構想を論じた。

この夢を実現するために生まれたのが、Multicsだった。

### 三者の野心

1964年、CTSSの成功を受けて、次世代タイムシェアリングシステムの計画が本格化した。GE（General Electric）のコンピュータ提案が1964年5月に選定され、同年8月に契約が締結された。11月にはBell Telephone Laboratoriesがソフトウェア開発への参加を決定した。

1965年、MIT Project MAC、Bell Labs、GEの3者は、Multics（Multiplexed Information and Computing Service）の共同開発を正式に開始した。Fernando Corbatoがプロジェクトを主導した。

Multicsの設計目標は壮大だった。数百人の同時ユーザにインタラクティブなアクセスを提供し、各ユーザがあたかもマシンを独占しているかのように操作でき、ハードウェアレベルの保護機構によってファイルとリソースの安全な共有を保証する。「コンピュータ・ユーティリティ」の実現——それがMulticsの使命だった。

ハードウェアにはGE-645が選ばれた。36ビットワード、最大4プロセッサの対称型マルチプロセッサ構成、コアメモリは最大100万ワード（約4MB）まで拡張可能。メモリサイクルタイム2マイクロ秒。1960年代としては最先端のマシンだった。離散トランジスタで構成された最後期のコンピュータの一つでもある。

### 技術的野心の全貌

Multicsが導入しようとした技術的革新は、今から見ても驚くほど野心的だ。

**セグメント化仮想メモリ**。Multicsは、メモリをセグメントとページの二段階で管理した。すべての情報はセグメントに格納され、各セグメントは独立したサイズとアクセス権を持つ。物理メモリの制限を超えてプログラムが動作できる仮想メモリの実現——これは1960年代においては画期的だった。

**リング保護機構**。従来のシステムが「スーパーバイザモード」と「ユーザモード」の2段階しか持たなかったのに対し、Multicsは8段階のリング保護を実装した。リング0が最も特権的で、リング7が最も制限される。プログラムのアクセス権限をきめ細かく制御できる。現代のCPUに搭載されているリング保護機構の直接的な起源だ。

**動的リンク**。実行中のプロセスが、必要になった時点で外部ルーチンを自分のアドレス空間に追加できる。プログラムとライブラリを実行時まで結合しない——Multicsはこの概念を世界で初めて大規模に実装した。

**階層型ファイルシステム**。ファイルをツリー構造のディレクトリで管理する——現代のすべてのOSが当然のように備えているこの機能は、Multicsが世界で初めて実装したものだ。ファイル名はほぼ任意の長さと構文を持てた。シンボリックリンクも、一つのファイルに複数の名前を付けることもできた。

**アクセス制御リスト（ACL）**。セグメントとディレクトリはACLによって保護され、ユーザまたはユーザクラスごとに読み取り・書き込み・実行の権限を設定できた。

これらの技術的野心の一つ一つは、それ自体は正当な目標だった。問題は、そのすべてを同時に実現しようとしたことにある。

---

## 3. 肥大化の病理——なぜMulticsは遅れたのか

### 複雑さの雪だるま

Multicsの設計を見ていると、ある種の必然性を感じる。各機能は合理的だ。セキュリティは必要だ。仮想メモリも必要だ。動的リンクは便利だ。階層型ファイルシステムは合理的だ。だが、これらすべてを一つのシステムに統合しようとすると、各機能の間に予期しない相互作用が生まれる。

セグメント化仮想メモリとリング保護を組み合わせると、メモリアクセスのたびに複数の権限チェックが必要になる。動的リンクとセキュリティを組み合わせると、リンク時のアクセス制御が複雑化する。階層型ファイルシステムとACLを組み合わせると、パス解決のたびに権限の継承と上書きを処理しなければならない。

個々の機能は合理的でも、その組み合わせの複雑さは指数関数的に増大する。これは、ソフトウェア工学で繰り返し観察されるパターンだ。Fred Brooksが1975年の『The Mythical Man-Month』で「概念的整合性こそアーキテクチャ設計の最重要課題」と述べたのは、まさにMulticsのような事例を念頭に置いていたと考えてよい。Brooksが同書で引き合いに出しているOS/360の開発経験は、Multicsと同時代の出来事だ。

さらに、ハードウェアの問題があった。GE-645は野心的なスペックを持っていたが、セグメンテーションとページングを同時に処理するハードウェア機構は当初不完全で、ソフトウェア側で補う必要があった。ハードウェアとソフトウェアの共同設計は、双方のスケジュールを相互に依存させ、遅延の連鎖を生んだ。

### Bell Labsの撤退

Dennis Ritchieは後にこう書いている。

> By 1969, Bell Labs management, and even the researchers came to believe that the promises of Multics could be fulfilled only too late and too expensively.

「1969年までに、Bell Labsの経営陣も、研究者たちでさえも、Multicsの約束は遅すぎ、高くつきすぎることによってのみ実現されると信じるに至った」

1969年、Bell LabsはMulticsプロジェクトから撤退した。撤退は一斉ではなく段階的だった。研究者が一人、また一人とプロジェクトから離脱していった。最後まで残ったのは、Ken Thompson、Dennis Ritchie、Doug McIlroy、Joe Ossannaの4人だった。

ここで重要な点がある。Bell Labsが撤退したのは、Multicsの目標を否定したからではない。その実現手段の複雑さと、それに伴うスケジュールとコストの超過に耐えられなくなったからだ。Ritchieの言葉は注意深く読む必要がある。「promises（約束）」は否定されていない。その約束が「too late and too expensively（遅すぎ、高くつきすぎる）」形でしか実現されないことが問題だったのだ。

Multicsは「失敗作」だったのか。この問いへの答えは単純ではない。1970年にGEのコンピュータ事業はHoneywellに売却され、HoneywellはMulticsを商用製品として販売し、数十のシステムが導入された。Multicsは1985年まで稼働し続けた。「失敗」したのは、Multicsが「遍在するユーティリティ」になるという当初の壮大な夢だった。製品としては20年近く存続した。

だが、Multicsの最大の遺産は、その技術そのものではなく、4人の研究者の頭の中に残った「経験」だった。

### Multicsの本当の遺産

Multicsが実現した——あるいは実現しようとした——技術の多くは、後の計算機科学に決定的な影響を与えた。

階層型ファイルシステムは、UNIX、macOS、Windows、Linuxのすべてに受け継がれた。リング保護機構は、IntelのCPUに実装された。仮想メモリは現代のすべてのOSの基盤だ。動的リンクは、現代の共有ライブラリ（.so、.dll、.dylib）の直接的な祖先だ。ACLベースのセキュリティは、現代のOSやクラウドサービスで広く使われている。

Multicsは「失敗した理想主義」ではなく「早すぎた成功」だった。そのアイデアの大半は、30年後に十分な計算資源を得て、別の形で実現された。

だが、1969年のKen Thompsonにとって、Multicsのアイデアを「30年後に実現する」ことは意味がなかった。今、手元にあるハードウェアで、今、動くものが必要だった。

---

## 4. PDP-7の前で——制約が哲学に変わる瞬間

### Space Travelから始まった

Multicsの夢が潰えた後、Thompson は何をしたか。ゲームを作った。

Space Travel——太陽系をシミュレートし、惑星や衛星に着陸を試みるゲームだ。ThompsonはこれをまずGE-645上で開発し、次にFortranに移植してGECOS上で動作させた。だがGECOSは「インタラクティブバッチ」モデルを採用しており、端末からのジョブはキューに積まれて順番を待つ。ゲームにはまったく不向きだった。

Thompsonは、隣の部門に使われていないPDP-7があることを知った。グラフィックス端末が接続されており、当時としてはなかなかの表示能力を持っていた。彼はGECOS上のクロスコンパイラを使ってSpace TravelをPDP-7向けに移植し、パンチテープに書き出してPDP-7にロードした。

ここからが重要だ。GECOS上でコードを書き、パンチテープに出力し、PDP-7にロードする——この作業の繰り返しがあまりに面倒だったため、Thompsonは PDP-7上に直接ファイルシステムを作ることにした。そのファイルシステムの設計は、Dennis RitchieとRudd Canadayが黒板に描いたアイデアにも基づいていた。彼らのMulticsでの経験から生まれたアイデアだ。

ファイルシステムがあれば、ファイルを操作するツールが要る。ツールがあれば、それらを組み合わせる仕組みが要る。気がつけば、Thompson のPDP-7の上には、小さなOSが出来上がっていた。

### 9KBの宇宙

PDP-7のスペックを、改めて確認しよう。

| 項目                 | PDP-7             | GE-645（Multics）        |
| -------------------- | ----------------- | ------------------------ |
| ワード長             | 18ビット          | 36ビット                 |
| 標準メモリ           | 4Kワード（約9KB） | 最大100万ワード（約4MB） |
| メモリサイクルタイム | 1.75マイクロ秒    | 2マイクロ秒              |
| 価格                 | 72,000ドル        | 数百万ドル規模           |
| マルチプロセッサ     | 非対応            | 最大4プロセッサ          |

GE-645の100万ワードに対して、PDP-7の4Kワードは0.4%に過ぎない。Multicsが100万ワードのメモリを使ってセグメント化仮想メモリ、8段階リング保護、動的リンクを実装しようとしていたのに対し、Thompsonには9KBしかなかった。

この制約が、すべてを決定した。

セグメント化仮想メモリを実装する余裕はない。だからフラットなアドレス空間を選んだ。8段階のリング保護を実装する余裕はない。だからスーパーバイザ/ユーザの2段階にした。動的リンクを実装する余裕はない。だからプログラムは静的に結合した。精巧なACLを実装する余裕はない。だからユーザ/グループ/その他の3段階のパーミッションにした。

Multicsが「理想的な設計」を目指して複雑さに溺れたのに対し、UNIXは「今、この9KBのメモリで動くもの」を作らざるを得なかった。複雑なものを作る「余裕がなかった」のだ。

だが、Thompsonは愚かではない。彼はMulticsの設計を知悉していた。何年もMulticsの開発に携わった経験から、何が本質的で何が装飾なのかを見極める眼を持っていた。

Multicsの階層型ファイルシステムは受け継いだ。ツリー構造によるファイル管理は、9KBのメモリでも実装する価値がある本質的な設計だと判断した。

Multicsのシングルレベルストア——すべてのデータをメモリとディスクの区別なく一つのアドレス空間に配置する仕組み——は捨てた。Ritchieの記述によれば、Thompsonはこれを「最終的に悪い設計選択」だと感じていた。

Multicsのシェル（コマンドインタプリタ）の概念は受け継いだ。リダイレクションの概念も、一部のコマンド名も。

つまり、UNIXはMulticsの「全否定」ではなく「選択的継承」だった。膨大な設計から、9KBのメモリで実装可能な本質だけを抽出した。この「選択」の精度こそが、ThompsonとRitchieの天才の核心にある。

### UNICSからUNIXへ

1970年、この小さなOSに名前が付いた。Brian Kernighanが、Multics（Multiplexed Information and Computing Service）に対する駄洒落として、UNICS（Uniplexed Information and Computing Service）という名前を考案した。「多重化されたもの」に対する「単一のもの」——Multicsの野心に対する、自嘲的かつ正確な位置づけだった。

後にUNICSはUNIXと綴りを変えた。その経緯について、Kernighan自身が「誰も最終的な綴りの由来を覚えていない」と述べている。だが名前の由来は重要だ。UNIXは、自らを「Multicsの単純版」と位置づけることから出発した。その「単純さ」が、50年以上生き延びる設計哲学の源泉になるとは、当時は誰も予想していなかっただろう。

---

## 5. 制約から哲学へ——UNIXの設計判断を分析する

ここまでの歴史を踏まえて、UNIXの設計判断を技術的に分析しよう。UNIXが「シンプルにした」と言うとき、具体的に何をどうシンプルにしたのか。

### メモリモデル：セグメンテーションからフラットアドレスへ

```
【Multics のメモリモデル】

 セグメントテーブル        ページテーブル          物理メモリ
 ┌──────────┐      ┌──────────┐      ┌──────────┐
 │ Seg 0    │─────→│ Page 0   │─────→│ Frame 12 │
 │ (code)   │      │ Page 1   │─────→│ Frame 47 │
 │ size: 4p │      │ Page 2   │─────→│ Frame 03 │
 │ ring: 0  │      │ Page 3   │─────→│ Frame 91 │
 ├──────────┤      └──────────┘      ├──────────┤
 │ Seg 1    │─────→ ...               │          │
 │ (data)   │                         │          │
 │ size: 2p │                         │          │
 │ ring: 4  │                         │          │
 ├──────────┤                         │          │
 │ Seg 2    │─────→ ...               │          │
 │ (stack)  │                         │          │
 │ ring: 4  │                         │          │
 └──────────┘                         └──────────┘

 各セグメントが独立したサイズ・アクセス権・リングレベルを持つ
 → 柔軟だが、アドレス解決が複雑

【UNIX のメモリモデル（PDP-7時代）】

 プロセスのアドレス空間     物理メモリ
 ┌──────────────┐     ┌──────────┐
 │ 0x0000       │────→│          │
 │ code         │     │          │
 │              │     │          │
 │ data         │     │          │
 │              │     │          │
 │ 0x1FFF (8KB) │     │          │
 └──────────────┘     └──────────┘

 フラットなアドレス空間。セグメンテーションなし
 → 単純だが、十分だった
```

Multicsのセグメント化メモリは、プログラムの論理構造をメモリの物理構造に反映させるエレガントな設計だった。コードセグメント、データセグメント、スタックセグメントがそれぞれ独立した保護属性を持つ。だが、メモリアクセスのたびにセグメントテーブルとページテーブルの二段階を参照し、さらにリング保護のチェックを行う必要があった。

UNIXは、フラットなアドレス空間を選んだ。プロセスごとに連続したアドレス空間を割り当て、コードもデータもスタックも同じ空間に配置する。セグメンテーションの柔軟性は失われるが、アドレス解決は単純明快になる。9KBのメモリでは、二段階のアドレス変換テーブルを持つ余裕がそもそもなかった。

### セキュリティモデル：リング保護からuid/gidへ

Multicsの8段階リング保護は、アクセス制御の粒度として理想的だった。カーネル（リング0）、特権デーモン（リング1-2）、システムライブラリ（リング3-4）、一般ユーザプログラム（リング5-7）と、段階的に権限を制限できる。

UNIXは、これをスーパーバイザモード（カーネル）とユーザモード（その他すべて）の2段階に簡素化した。ファイルのアクセス制御もACLではなく、owner/group/otherの3カテゴリに対するread/write/executeの9ビットで表現した。

```
Multics ACL:
  user_a: r w x
  user_b: r - -
  group_admins: r w x
  group_devs: r w -
  *.*.* : r - -
  （任意の粒度で設定可能）

UNIX パーミッション:
  rwxr-xr--
  （owner/group/other × read/write/execute = 9ビット）
```

Multicsの方が柔軟であることは明白だ。だが、UNIXの9ビットパーミッションは「ほとんどのユースケースをカバーする最小限の仕組み」だった。この「ほとんど」で十分なケースが圧倒的多数であったことが、UNIXの設計判断を正当化した。

### ファイルシステム：受け継がれた本質

唯一、UNIXがMulticsからほぼそのまま受け継いだのが、階層型ファイルシステムだ。ルートディレクトリを頂点とするツリー構造でファイルを管理する。このアイデアは、9KBのメモリでも実装する価値がある本質だとThompsonは判断した。

ただし、Multicsのシングルレベルストア——ファイルもメモリ上のデータも区別なく一つのアドレス空間に配置する——は、UNIXには採用されなかった。UNIXでは、ファイルはディスク上のバイト列であり、メモリに読み込んで操作する。ファイルとメモリの区別が明確だ。この判断は、実装をシンプルにするだけでなく、プログラマの頭の中のモデルもシンプルにした。

### 設計判断の本質：「何を捨てるか」

ここで浮かび上がるパターンがある。UNIXの設計判断の核心は、「何を作るか」ではなく「何を捨てるか」にある。

| Multicsの機能              | UNIXの選択               | 捨てた理由                         |
| -------------------------- | ------------------------ | ---------------------------------- |
| セグメント化仮想メモリ     | フラットアドレス空間     | 9KBにテーブルの余裕なし            |
| 8段階リング保護            | 2段階（カーネル/ユーザ） | 実装コストに見合わない             |
| 動的リンク                 | 静的リンク               | メモリ不足で実行時リンカが載らない |
| ACL                        | 9ビットパーミッション    | 大半のケースをカバーする最小限     |
| シングルレベルストア       | ファイル/メモリ分離      | 概念モデルの単純化                 |
| **階層型ファイルシステム** | **継承**                 | **本質的な設計と判断**             |
| **シェル**                 | **継承**                 | **対話的操作に不可欠**             |
| **リダイレクション**       | **継承**                 | **組み合わせの基盤**               |

「何を残し、何を捨てるか」の判断精度は、ThompsonとRitchieがMulticsに深く関わった経験から来ている。Multicsを知らなければ、何が本質で何が装飾かを見分けることはできなかった。

逆説的だが、UNIXの設計の卓越性は、Multicsの「失敗」なしには生まれ得なかった。

---

## 6. PDP-11への生存戦略——テキスト処理という救命ボート

PDP-7上のUNIXは、研究者の趣味のプロジェクトに過ぎなかった。組織の中で生き延びるためには、「役に立つ」ことを証明しなければならない。

ThompsonとRitchieは巧みだった。Bell Labsの特許部門がワードプロセッサを必要としていることを見つけ、UNIXにテキスト処理機能を追加することでPDP-11の購入資金を勝ち取った。テキストエディタとテキスト整形プログラム roff をPDP-11のアセンブリ言語で開発し、1971年半ばまでに、特許部門の3人のタイピストがPDP-11/20上で日常的に特許出願書類の作成・編集・整形を行うようになった。

1971年11月3日、UNIX Programmer's Manual が発行された。manページのフォーマット——今も `man ls` や `man grep` で目にするあの形式——は、このときに確立された。

この「テキスト処理のためのOS」という立ち位置は、UNIXの設計哲学にも影響を与えた。テキストを入出力の基本単位とする文化、行指向のデータ処理、ストリーム指向のツール設計——これらは単なる設計美学ではなく、特許出願書類を効率的に処理するという実務的な要求にも根ざしていた。

ここに、UNIXの生存戦略のもう一つの側面がある。理想的な設計を追求するのではなく、「今ここにある問題を解決する」ことで組織内の支持を勝ち取る。Multicsが壮大な理想から出発して実装に苦しんだのに対し、UNIXは動くものから出発して少しずつ機能を拡張していった。この「動くものを先に作る」アプローチは、後にエリック・レイモンドが「バザール」と呼ぶ開発モデルの原型でもある。

---

## 7. ハンズオン：PDP-7時代の制約を疑似体験する

Multicsの壮大さとUNIXの簡素さの差を、理屈だけでなく体で理解しよう。PDP-7の制約——9KBのメモリ——を疑似的に体験する演習を行う。

### 環境構築

```bash
docker run -it --rm ubuntu:24.04 bash
```

コンテナ内で必要なツールを用意する。

```bash
apt-get update && apt-get install -y bc
```

### 演習1：9KBの世界を体感する

まず、9KBとはどの程度の容量なのかを確認する。

```bash
# 9KB = 9,216バイト
# 現代のプログラムと比較してみよう

# /bin/ls のサイズ
ls -l /bin/ls | awk '{print $5, "bytes =", $5/1024, "KB"}'

# /bin/bash のサイズ
ls -l /bin/bash | awk '{print $5, "bytes =", $5/1024, "KB"}'

# /bin/grep のサイズ
ls -l /bin/grep | awk '{print $5, "bytes =", $5/1024, "KB"}'

echo ""
echo "PDP-7の全メモリ: 9 KB (9,216 bytes)"
echo "---"
echo "現代のlsコマンド1つすら、PDP-7の全メモリに収まらない"
```

lsコマンドだけで100KBを超えることが多い。PDP-7のメモリ9KBには、現代の ls 一つすら載らない。ThompsonはこのメモリにOS全体を収めなければならなかった。

### 演習2：極小メモリでのファイルシステム操作

UNIXのファイルシステムの原型を、最小限の仕組みで体験する。

```bash
# PDP-7 UNIXのファイルシステムを疑似的に再現する
# ディレクトリ構造を手動で管理する

WORKDIR="/tmp/pdp7-unix"
mkdir -p "$WORKDIR"
cd "$WORKDIR"

# PDP-7 UNIXの初期ディレクトリ構造
# (実際のPDP-7 UNIXはフラットに近い構造だったが、
#  階層の概念はMulticsから継承していた)
mkdir -p dd/root
mkdir -p dd/usr
mkdir -p dd/bin
mkdir -p dd/tmp

echo "=== PDP-7 UNIX 疑似ファイルシステム ==="
echo ""

# PDP-7 UNIXのコマンドは極めて短い名前を持っていた
# メモリ節約のため、コマンド名もファイル名も短くする

# catの原型——ファイルの中身を出力する
cat << 'PROG' > dd/bin/cat
#!/bin/sh
# PDP-7 UNIXの cat は
# 単にファイルの内容を標準出力に書くだけ
cat "$@"
PROG
chmod +x dd/bin/cat

# lsの原型——ディレクトリの中身を列挙する
cat << 'PROG' > dd/bin/ls
#!/bin/sh
# PDP-7 UNIXの ls はオプションなし
# ファイル名を列挙するだけ
ls "$@"
PROG
chmod +x dd/bin/ls

echo "ファイルシステム構造:"
find dd -type f -o -type d | sort
echo ""
echo "ここにOSのカーネル、シェル、ユーティリティの"
echo "すべてが9KBのメモリに収まっていなければならなかった"
```

### 演習3：プロセスの分離を体験する

UNIXの最も重要な設計判断の一つ——プロセスの分離——を体験する。

```bash
# fork() の本質を理解する
# 各プロセスが独立したアドレス空間を持つことの意味

echo "=== プロセス分離の体験 ==="
echo ""

# 親プロセスで変数を設定
PARENT_VAR="I am the parent"
echo "親プロセス (PID: $$): PARENT_VAR=$PARENT_VAR"

# 子プロセスを生成（サブシェル）
(
  # 子プロセスは親の変数のコピーを持つ
  echo "子プロセス (PID: $BASHPID): PARENT_VAR=$PARENT_VAR"

  # 子プロセスで変数を変更
  PARENT_VAR="I am the child"
  echo "子プロセス 変更後: PARENT_VAR=$PARENT_VAR"
)

# 親プロセスの変数は影響を受けない
echo "親プロセス 子終了後: PARENT_VAR=$PARENT_VAR"
echo ""
echo "→ 子プロセスの変更は親に影響しない"
echo "→ これがUNIXのプロセス分離の基本原則"
echo "→ Multicsのセグメント共有と対照的に、"
echo "  UNIXは各プロセスに独立した空間を与えた"
```

### 演習4：パイプの原型——プロセス間通信

Multicsにはパイプがなかった。UNIXのパイプは、プロセス間でデータをやり取りする最も単純な仕組みだ。

```bash
echo "=== パイプによるプロセス間通信 ==="
echo ""

# 名前付きパイプ（FIFO）で、パイプの内部動作を可視化する
FIFO_PATH="/tmp/pdp7_pipe"
rm -f "$FIFO_PATH"
mkfifo "$FIFO_PATH"

# 読み手プロセスをバックグラウンドで起動
(
  echo "[Reader] パイプからの読み取りを開始..."
  while IFS= read -r line; do
    echo "[Reader] 受信: $line"
  done < "$FIFO_PATH"
  echo "[Reader] パイプが閉じられた"
) &
READER_PID=$!

# 少し待ってから書き手プロセスを実行
sleep 1
(
  echo "[Writer] パイプへの書き込みを開始..."
  echo "Hello from writer" > "$FIFO_PATH"
  echo "Process communication" >> "$FIFO_PATH"
  echo "Via named pipe" >> "$FIFO_PATH"
  echo "[Writer] 書き込み完了"
)

# 読み手の終了を待つ
wait $READER_PID 2>/dev/null
rm -f "$FIFO_PATH"

echo ""
echo "→ 二つの独立したプロセスが、パイプを介してデータを交換した"
echo "→ 各プロセスは相手の内部状態を知らない"
echo "→ 知っているのは「バイト列がパイプを流れる」ことだけ"
echo "→ この単純さこそが、UNIXの組み合わせ可能性の基盤"
```

### 演習5：MulticsとUNIXの設計思想を比較する

最後に、同じ問題——「特定のパターンを含むファイルを見つける」——をMultics的アプローチとUNIX的アプローチで比較する。

```bash
echo "=== 設計思想の比較: ファイル検索 ==="
echo ""

# テスト用のファイルを作成
TEST_DIR="/tmp/design_compare"
rm -rf "$TEST_DIR"
mkdir -p "$TEST_DIR"

echo "error: disk full" > "$TEST_DIR/system.log"
echo "info: startup complete" >> "$TEST_DIR/system.log"
echo "error: connection refused" >> "$TEST_DIR/system.log"
echo "warning: memory low" >> "$TEST_DIR/system.log"
echo "error: timeout" >> "$TEST_DIR/system.log"

echo "def calculate(): pass" > "$TEST_DIR/app.py"
echo "def validate(): pass" >> "$TEST_DIR/app.py"
echo "# error handling" >> "$TEST_DIR/app.py"

echo "SELECT * FROM users;" > "$TEST_DIR/query.sql"
echo "-- error: fix this query" >> "$TEST_DIR/query.sql"

echo "--- Multics的アプローチ（仮想的な再現）---"
echo ""
echo "Multicsなら、ファイル検索は単一の高機能コマンドで行う:"
echo "  search_files -dir /tmp/design_compare -pattern 'error' \\"
echo "    -recursive -show_line_numbers -format detailed"
echo ""
echo "一つのコマンドが、検索・表示・整形のすべてを担当する"
echo ""

echo "--- UNIX的アプローチ ---"
echo ""
echo "UNIXでは、複数の単機能コマンドを組み合わせる:"
echo ""

# Step 1: grep でパターンを検索
echo "Step 1: grep で 'error' を含む行を抽出"
grep -rn "error" "$TEST_DIR"

echo ""
echo "Step 2: パイプでさらに絞り込み"
grep -rn "error" "$TEST_DIR" | grep "\.log:"

echo ""
echo "Step 3: 件数をカウント"
grep -rn "error" "$TEST_DIR" | wc -l

echo ""
echo "→ grepは「パターンに一致する行を抽出する」だけ"
echo "→ wcは「行数を数える」だけ"
echo "→ それぞれが一つの仕事に専念し、パイプで組み合わさる"
echo "→ Multics的な万能コマンドより柔軟性が高い"
echo "  なぜなら、組み合わせ方を変えれば別の処理になるから"

rm -rf "$TEST_DIR"
```

この演習の要点は、同じ問題に対するアプローチの違いだ。Multicsは「賢い一つのプログラム」で解決しようとする。UNIXは「愚直な複数のプログラムの組み合わせ」で解決する。どちらが「正しい」かではない。9KBのメモリでは「賢い一つのプログラム」を作る余裕がなかった。だから「愚直な複数の小さなプログラム」を組み合わせる道を選んだ。そしてその選択が、結果的により柔軟で、より長寿命な設計哲学を生んだ。

---

## 8. まとめと次回予告

### この回の要点

- CTSSの成功（1961年）が「コンピュータ・ユーティリティ」の夢を生み、Multicsプロジェクト（1965年〜、MIT/Bell Labs/GE）はその実現を目指した。セグメント化仮想メモリ、8段階リング保護、動的リンク、世界初の階層型ファイルシステムなど、その技術的野心は今から見ても驚くほど先進的だった
- Multicsの問題は個々の技術ではなく、そのすべてを同時に統合しようとした複雑さにあった。1969年、Bell Labsは「約束は遅すぎ、高くつきすぎることによってのみ実現される」としてMulticsから撤退した
- Ken ThompsonはPDP-7（18ビット、メモリ9KB）の上で、Multicsの経験から本質だけを抽出した小さなOSを作った。階層型ファイルシステムとシェルは受け継ぎ、セグメント化メモリ、リング保護、動的リンクは捨てた。この「選択的継承」の精度がUNIXの設計哲学の源泉である
- UNIXのシンプルさは美学ではなく、9KBのメモリという制約から生まれた必然だった。だがその必然が、「何を捨てるか」という設計判断の卓越性と相まって、57年間生き延びる哲学に昇華した
- 特許部門へのテキスト処理サービスという「実用的な価値」を示すことで、UNIXは組織内での生存を勝ち取った。「動くものから始める」アプローチは、理想から出発したMulticsとの決定的な違いだった

### 冒頭の問いへの暫定回答

「UNIXはなぜ『シンプルさ』を選んだのか？ その選択の背景に何があったのか？」

暫定的な答えはこうだ。UNIXはシンプルさを「選んだ」のではない。PDP-7の9KBのメモリが、シンプルさを「強いた」のだ。だが、ThompsonとRitchieがMulticsの経験から「何が本質で何が装飾か」を見極める眼を持っていたからこそ、単なる「貧弱なOS」ではなく、50年以上生き延びる設計哲学が生まれた。

制約は創造の母である——この言葉が陳腐に聞こえるなら、PDP-7の9KBとGE-645の4MBを並べて見ればよい。0.4%以下のリソースから、より長命な設計が生まれた。その理由は、制約そのものにあるのではなく、制約の中で「何を残すか」を判断できる知見にある。Multicsを知り尽くしていたからこそ、UNIXは生まれた。

### 次回予告

次回は「Ken ThompsonとDennis Ritchie——二人の天才が残したもの」。UNIXの設計哲学は、どのような人間によって生み出されたのか。Ken Thompsonのチェスプログラムから正規表現、Go言語に至るキャリア。Dennis RitchieによるC言語の設計と、OSをC言語で書き直すという革命的判断。そして2011年10月12日——Steve Jobsの死の数日後に、世間にほとんど報じられることなく逝去した、しかしJobsのMacの基盤を作った男の物語。

あなたが毎日使っているプログラミング言語はCの子孫だろうか。あなたが毎日使っているOSは、Cで書かれているだろうか。その答えを知ったとき、Dennis Ritchieの仕事の大きさが見えてくる。

---

## 参考文献

- Dennis Ritchie, "The Evolution of the Unix Time-sharing System", Language Design and Programming Methodology Conference, Sydney, 1979. Reprinted in AT&T Bell Laboratories Technical Journal 63 No. 6 Part 2, October 1984: <https://www.nokia.com/bell-labs/about/dennis-m-ritchie/hist.html>
- Fernando Corbató et al., "Multics--The First Seven Years", Proceedings of the AFIPS Spring Joint Computer Conference, 1972: <https://multicians.org/f7y.html>
- Multics History, multicians.org: <https://multicians.org/history.html>
- Multics Features, multicians.org: <https://multicians.org/features.html>
- Unix and Multics, multicians.org: <https://multicians.org/unix.html>
- M. D. Schroeder, J. H. Saltzer, "A Hardware Architecture for Implementing Protection Rings", Communications of the ACM, Vol. 15, No. 3, March 1972: <https://multicians.org/protection.html>
- A. Bensoussan, C. T. Clingen, R. C. Daley, "The Multics Virtual Memory: Concepts and Design", Communications of the ACM, Vol. 15, No. 5, May 1972: <https://multicians.org/multics-vm.html>
- Brian W. Kernighan, "UNIX: A History and a Memoir", Kindle Direct Publishing, 2019
- Peter H. Salus, "A Quarter Century of UNIX", Addison-Wesley, 1994
- Frederick P. Brooks Jr., "The Mythical Man-Month", Addison-Wesley, 1975
- Compatible Time-Sharing System (1961-1973) Fiftieth Anniversary: <https://multicians.org/thvv/compatible-time-sharing-system.pdf>
- PDP-7 - Wikipedia: <https://en.wikipedia.org/wiki/PDP-7>
- GE 645 - Wikipedia: <https://en.wikipedia.org/wiki/GE_645>
- Computer History Museum, "The Earliest Unix Code: An Anniversary Source Code Release": <https://computerhistory.org/blog/the-earliest-unix-code-an-anniversary-source-code-release/>
