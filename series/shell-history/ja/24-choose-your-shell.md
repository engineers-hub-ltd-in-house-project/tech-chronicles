# 第24回：bash ありきの世界を疑え――あなたは何を選ぶか

**シリーズ**: bash ありきの世界を疑え――シェルの根源から対話と自動化の未来を考える

**著者**: 佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）

---

**この回で学べること**:

- 連載全23回を貫く問い「シェルは与えられるものか、選ぶものか」への著者の回答
- 50年のシェル史が示す「最適解は常に変わる」という教訓
- シェル選定の実践的フレームワーク――対話用・スクリプト用・組織レベルの三層で考える
- 「bashで十分」が正解である場合と、そうでない場合の見極め方
- 自分のチーム・プロジェクトに最適なシェル構成を設計する評価マトリクス

---

## 1. 導入――この連載を書いて、私が気づいたこと

この連載の第1回を書き始めたとき、私には一つの確信があった。

「bashを当たり前に使っている人間は、シェルの本質を見失っている。」

24年間ターミナルに棲み続けたエンジニアとして、Thompson shellからNushellまでの歴史を辿り直せば、その確信を読者に伝えられると思っていた。bashは答えではない。「人間がコンピュータと対話する方法」という問いに対するひとつの解に過ぎない。問いを知らずにbash scriptを書く人間は、シェルの限界をシェルの本質と取り違えている、と。

23回を書き終えた今、その確信は変わっていない。だが、一つだけ書き始める前には気づいていなかったことがある。

**私自身が、シェルを「選んでいた」つもりで、実は「与えられて」いた部分が少なくなかった。**

1990年代後半、Slackware 3.5をインストールしたとき、bashが「ターミナルに出てくるあれ」だった。私はbashを選んだのではない。Linuxディストリビューションがbashを選び、私はそれを受け取った。大学のBSD環境でtcshに出会ったのも、その環境のデフォルトがtcshだったからだ。2019年にmacOS Catalinaがデフォルトをzshに変えたとき、私はzshに「移行」した。だが正直に言えば、Appleの判断に従っただけだ。

では、私が本当に「選んだ」瞬間はあったのか。

あった。2000年代後半、数百行のbashデプロイスクリプトに苦しんだ末に「これ以上bashで書くべきではない」と判断し、Pythonに切り替えた瞬間。CI/CDパイプラインのスクリプトで`#!/bin/sh`を使い、bash依存を排除する判断をした瞬間。zshの補完システムをOh My Zshなしで設定し、自分の手に馴染む環境を構築した瞬間。これらは「選択」だった。歴史を知り、選択肢を理解し、自分の文脈に照らして判断を下した。

この連載を書く中で、50年分のシェルの歴史を言語化した。その作業を通じて、「なぜ自分が今のシェル構成を使っているのか」の理由が、初めて明確な言葉になった。対話にはzshを使う。補完とプロンプトのカスタマイズ性が他に代えがたいからだ。スクリプトは`#!/bin/sh`で書く。POSIX準拠にすることで、Alpine Linuxのashでもdashでもbashでも動くからだ。50行を超える自動化にはPythonを使う。エラーハンドリングと型の安全性が、シェルスクリプトの限界を超えるからだ。

あなたは、自分のシェルを「選んで」いるだろうか。それとも「与えられて」いるだろうか。

この最終回では、23回分の歴史と分析を踏まえた上で、シェル選定の実践的なフレームワークを提示する。そして、「bash ありきの世界」を疑った先に何があるのかを、私なりに答えてみたい。

---

## 2. 歴史的背景――「最適解は常に変わる」という教訓

### 50年の変遷が教えてくれること

この連載を通じて辿った50年の歴史は、一つの明確な教訓を示している。**シェルの最適解は、常に変わり続けてきた。**

Thompson shell（1971年）は、人間がUNIXと対話する最初の窓口だった。変数もなく、制御構造もなく、パイプすら後から追加された。だがそれは「不完全」だったのではない。当時のUNIXの規模と用途——数人の研究者がPDP-11で使う環境——にとっては、Thompson shellで十分だった。

Bourne shell（1979年）は、シェルをプログラミング言語にした。`if`/`for`/`while`/`case`の制御構造、変数、関数。この跳躍は、UNIXがAT&T以外の組織に広がり、システム管理の自動化が求められるようになったことへの応答だった。Thompson shellでは「十分」でなくなったのだ。

C shell（1979年）は、Bourne shellの対話性の貧しさへの反乱だった。Bill Joyはヒストリ、エイリアス、ジョブ制御を実装し、人間がシェルの前に座って対話的に作業する体験を根本的に改善した。だがcshのスクリプティングは信頼性に問題があり、Tom Christiansenが"Csh Programming Considered Harmful"（1996年）で指摘した通り、対話とスクリプティングの両立は叶わなかった。

Korn shell（1983年）は統合を試みた。Bourne shell互換を保ちつつcshの対話機能を取り込んだ。技術的には成功した。だがAT&Tのプロプライエタリライセンスが普及を阻み、「最適解」にはなれなかった。

bash（1989年）は、kshの技術的統合とGPLの自由再配布が交差する点に生まれた。Linuxの爆発的普及と相まって、bashは四半世紀にわたる覇権を手にした。だが、bashの覇権は技術的必然ではなく歴史的偶然の産物でもある。第15回で語ったように、GPLv3への移行がAppleのbash離脱を招き、macOSのデフォルトはzshに変わった。

そして今、2026年のシェルの世界はさらに多様化している。

### 2025-2026年の現在地

2025年7月、Bash 5.3がリリースされた。前バージョン5.2から約3年ぶりのメジャーリリースであり、Chet Rameyの継続的なメンテナンスにより、bashは枯れるどころか新機能を追加し続けている。current execution contextでのコマンド置換やGLOBSORT変数など、bashは進化を止めていない。

同じ2025年、fish 4.0が安定版をリリースした。2023年に始まったC++からRustへの書き換えが完了し、57,000行のC++コードが75,000行のRustコードに置き換わった。約2年の開発、2,600以上のコミット、200人以上のコントリビューター。fishの「POSIX互換を捨てて対話に特化する」という設計判断は、Rustの安全性と性能に裏打ちされた新たな基盤を得た。

Nushellは2026年1月時点でバージョン0.110.0に達している。2019年の初公開から7年、まだ1.0には到達していないが、月次リリースのペースで機能を追加し続けている。構造化データパイプラインというパラダイムは、概念実証の段階を超え、実用的なシェルとして成熟しつつある。

Oils（旧Oil Shell）のOSHモードは、2,705のspec testのうち2,420をパスしている（バージョン0.37.0、2025年12月）。Andy Chuの「bash互換を保ちつつ言語を進化させる」戦略は着実に形になりつつある。YSHにはクロージャ、オブジェクト、名前空間が追加され、シェル言語としての表現力はPythonやJavaScriptに近づいている。Alpine Linux上で`/bin/sh`、`/bin/ash`、`/bin/bash`をすべてOSHで置き換えるテストハーネスも構築されており、システムレベルでのbash代替を本気で目指していることがわかる。

2024年6月にはPOSIX.1-2024（Issue 8）が公開された。1992年の最初のPOSIXシェル標準から32年、シェルの「契約書」は改訂を重ね続けている。シェルの標準化という営みそのものが、50年間止まることなく続いているのだ。

2025年のStack Overflow Developer Surveyでは、Bash/Shellを使う開発者は約49%に達している。2人に1人がシェルを使っている現実がある。だが、その49%のうち何割が、自分の使うシェルを「選んで」いるだろうか。

### シェルの「選択」を支配する見えない力

50年の歴史を俯瞰すると、シェルの選択を支配してきたのは、技術的優劣だけではないことがわかる。

**ライセンス**がシェルの運命を決めた。kshはAT&Tのプロプライエタリライセンスゆえに自由な世界に広がれなかった。bashはGPLv2の自由再配布によってLinuxのデファクトとなった。だがGPLv3への移行が、AppleのmacOSからのbash排除を招いた。zshがmacOSのデフォルトに選ばれたのは、MITライセンスだったからだ。

**ディストリビューションのデフォルト設定**がユーザーの選択を決めた。Linuxディストリビューションがbashをデフォルトにしたから、多くの開発者はbashを使い始めた。macOSがzshに変えたから、macOSユーザーはzshを使い始めた。Alpine LinuxがBusyBox ashを採用したから、コンテナ環境ではashが動く。

**エコシステム**がシェルのロックインを生んだ。Oh My Zsh（2009年）はzshの対話体験を劇的に簡単にしたが、同時にzshへのロックインも生んだ。bash-completionパッケージはbashの補完体験を底上げしたが、bashからの移行障壁にもなった。Starshipのようなクロスシェルプロンプトは、この状況に風穴を開けようとしている。10種以上のシェルに対応するStarshipは、「プロンプトはシェルに依存しなくてよい」ことを証明した。

**AIの台頭**がシェルとの対話の意味を変えつつある。2025年にはClaude Code、GitHub Copilot CLI、Gemini CLIが相次いで登場した。ターミナルは従来のシェルコマンドだけでなく、AIエージェントとの自然言語による対話の場へと変容しつつある。シェルの上にAIが乗り、AIがシェルコマンドを生成・実行する。この構造は、「人間がシェルと対話する」というこれまでの前提そのものを揺さぶっている。

これらの「見えない力」は、個々の開発者のシェル選択を無意識のうちに制約している。bashを使っている理由が「最初から入っていたから」であるならば、それは選択ではなく受容だ。zshを使っている理由が「Catalinaにアップデートしたら変わっていたから」であるならば、それはAppleの選択に従っただけだ。

シェルを「選ぶ」とは、これらの見えない力を認識した上で、自分の文脈に照らして意識的に判断を下すことだ。

---

## 3. 技術論――シェル選定の実践的フレームワーク

### 「bashで十分」が正解である場合

この連載は「bash ありきの世界を疑え」と題している。だが、私は「bashを使うな」と言いたいのではない。**bashを「選んで」使え**と言いたいのだ。

そして、歴史を知り、選択肢を理解した上で「bashで十分」と判断することは、立派な選択である。

bashが最適解であり得る場面は、実は少なくない。

**チームの共通言語としてのbash。** あなたのチームの全員がbashに習熟しており、CI/CD環境もLinuxで統一されているならば、bashはスクリプト言語として合理的な選択だ。チーム全員が読み書きできるという利点は、言語としての洗練さよりも重いことがある。

**情報の圧倒的な厚み。** bashのトラブルシューティングに関する情報は、Stack Overflowやブログ記事に膨大に蓄積されている。zshやfishのトラブルに遭遇したとき、同じ問題を先に踏んだ人間を見つけるのは難しいかもしれない。Nushellならなおさらだ。2025年のStack Overflow Developer Surveyで約49%がBash/Shellを使っている事実は、エコシステムの厚みとして無視できない。

**「50行以下の接着剤」としてのbash。** 第14回で語ったように、bashスクリプトの最適な射程は「50行以下の接着剤（glue）」だ。ファイルのコピー、サービスの起動・停止、ログの検索、簡単なデータ変換。この範囲であれば、bashの限界に突き当たることは少ない。

```
┌─────────────────────────────────────────────────────────────┐
│            「bashで十分」の判断チェックリスト                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  以下のすべてに該当する場合、bashは合理的な選択である:      │
│                                                             │
│  [  ] チームの全員がbashスクリプトを読み書きできる          │
│  [  ] スクリプトは50行以下である                            │
│  [  ] 実行環境がLinuxに限定されている                       │
│  [  ] エラーハンドリングが単純（失敗したら止める）          │
│  [  ] 外部データのパースが不要（JSON/YAML等を扱わない）     │
│  [  ] テストの必要性が低い（使い捨て or 単純なタスク）      │
│                                                             │
│  一つでも該当しない場合、代替を検討する価値がある。         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

このチェックリストの意味は、「bashで十分かどうか」を意識的に判断するための道具を持つことにある。無意識に「とりあえずbash」と書き始めるのではなく、「この場面でbashは適切か」と立ち止まって考える。それが「選ぶ」ということだ。

### 「bashでは不十分」な場面の見極め

一方、bashの限界を知った上で代替を検討すべき場面もある。

**構造化データの処理。** JSON、YAML、TOML、CSVを扱うスクリプトをbashで書こうとした経験があるだろうか。`jq`や`yq`で凌ぐことはできる。だがそれは、テキストストリームの限界をツールで補っているに過ぎない。Nushellならば構造化データをネイティブに扱える。Pythonならばjsonモジュールで型安全に処理できる。第6回で語った「すべてはテキスト」の限界は、構造化データを扱う瞬間に顕在化する。

**エラーハンドリングの複雑さ。** `set -euo pipefail`はbashスクリプトのベストプラクティスだが、万能ではない。パイプラインの途中でエラーが発生した場合の挙動、trapでのクリーンアップ、リトライロジック——これらが複雑になるほど、bashの限界が見える。Pythonのtry/exceptやGoのerror型のような体系的なエラーハンドリングは、bashには存在しない。

**テストの必要性。** bats-core（Bash Automated Testing System）はbashスクリプトのテストフレームワークとして機能するが、Pythonのpytestやfishのfishtapeと比較すると、アサーション、モック、フィクスチャといった機能は限定的だ。スクリプトの信頼性をテストで担保する必要があるならば、テスト基盤の整ったプログラミング言語を検討すべきだ。

**クロスプラットフォーム要件。** macOS（zshデフォルト、bash 3.2がプリインストール）、Linux各ディストリビューション（bash 5.x）、Windows（WSL経由またはGit Bash）、Alpine Linux（BusyBox ash）——これらの環境すべてで動くスクリプトを書くならば、POSIX sh準拠が最も安全な選択肢だ。bashの拡張機能に依存したスクリプトは、環境を選ぶ。

### 対話用シェルの選定基準

前回の第23回で提示した「三層モデル」をさらに具体化しよう。まず、Layer 1——対話用シェルの選定基準から。

対話用シェルとは、毎日ターミナルを開いたときに向き合うシェルだ。この層での選定基準は、技術的な厳密さよりも**主観的な快適さ**が重要だ。なぜなら、対話用シェルは一日に何百回も使うものであり、わずかな摩擦が生産性に直結するからだ。

以下のマトリクスで比較する。

```
対話用シェル選定マトリクス

               bash      zsh       fish      Nushell
─────────────────────────────────────────────────────
補完の充実度     ○        ◎        ◎         ○
構文ハイライト   △        ○        ◎         ◎
自動サジェスト   △        ○        ◎         ○
学習コスト       ◎        ○        ◎         △
カスタマイズ性   ○        ◎        ○         ○
エコシステム     ◎        ◎        ○         △
起動速度         ○        △        ○         △
POSIX互換        ◎        ◎        ×         ×
─────────────────────────────────────────────────────

◎=優秀  ○=良好  △=やや弱い  ×=非対応

補足:
- bash: 堅実な選択。情報量が圧倒的。bash 5.3でReadline 8.3同梱
- zsh:  最大主義。Oh My Zsh で入りやすいが、本質は深い
- fish: 学習コスト最小。箱出しの体験が最高。POSIX非互換が代償
- Nushell: 構造化データ表示が革新的。エコシステムは発展途上
```

この表を見て、「zshが全体的に強い」と感じるかもしれない。事実、zshは三つの軸のバランスに優れている。だが、「バランスが良い」ことが「最適」を意味するとは限らない。

fishを使い始めた人がよく言うのは、「設定なしで、ここまで快適な体験が得られるとは思わなかった」ということだ。fishは箱出し（out of the box）の対話体験に全力を注いでいる。構文ハイライト、自動サジェスト、man pageベースの自動補完——これらが設定なしで動く。zshで同等の体験を得るには、Oh My Zshかzinit等のプラグインマネージャーが必要だ。

一方、Nushellの`ls`がテーブルを返す体験は、一度味わうと従来のテキスト出力に戻れないという声もある。`ls | where size > 1mb | sort-by modified`のような操作は、Nushellの構造化パイプラインならば自然に書けるが、bashでは`find`と`awk`と`sort`を駆使する必要がある。

対話用シェルの選定に正解はない。自分の手に馴染むかどうかが全てだ。ただし、**一つのシェルしか試したことがない人間には、「手に馴染む」の基準そのものがない。** 少なくとも二つのシェルを一定期間使ってみることを、私は強く勧める。

### スクリプト用シェルの選定基準

Layer 2——スクリプト用シェルの選定は、対話用シェルとは正反対の基準で行う。主観的な快適さではなく、**客観的な再現性**が最重要だ。

```
スクリプト用シェル選定マトリクス

                 POSIX sh   bash     Oils/YSH   Python
──────────────────────────────────────────────────────────
可搬性              ◎        ○         △         ○
起動速度            ◎        ○         △         △
エラー処理          △        △         ○         ◎
型安全性            ×        ×         ○         ◎
テスト容易性        △        △         ○         ◎
既存スクリプト互換  ◎        ◎         ◎         ×
学習コスト          ○        ◎         △         △
──────────────────────────────────────────────────────────

用途別の推奨:
- 10行以下のワンライナー    → POSIX sh
- 50行以下の自動化グルー    → bash (set -euo pipefail)
- 50行超の自動化タスク      → Python / Oils(YSH)
- 既存bashスクリプトの移行  → Oils(OSH→YSH)
```

ここで重要なのは、スクリプト用シェルとして「POSIX sh」を選ぶことの意味だ。POSIX shは特定のシェル実装ではなく、仕様である。bashでもdashでもashでも、POSIX準拠の範囲内で書かれたスクリプトは同じように動く。この「抽象化」こそがPOSIX shの価値だ。

第11回で語ったように、POSIX shで使えるもの・使えないものの境界を知ることは、ポータブルなスクリプトを書くための必須知識である。配列は使えない。`[[`は使えない。`local`は厳密にはPOSIX外だ（多くの実装がサポートしているが）。これらの制約を受け入れることで、どの環境でも動く堅牢なスクリプトが書ける。

Oils/YSHは、既存のbashスクリプトからの段階的な移行パスを提供するという点でユニークだ。OSHモードでbash互換のスクリプトを実行し、少しずつYSH構文に書き換えていく。この「段階的移行」は、何万行ものbashスクリプトを抱える組織にとって、現実的な道筋になり得る。

### 組織レベルでの標準化

個人のシェル選択と、組織レベルでの標準化は、異なる判断軸を持つ。

個人の対話シェルは、好みで選んでよい。zshを使おうがfishを使おうが、他の人には影響しない。だが、チームで共有するスクリプト、CI/CDパイプライン、Dockerfileのシェルは、組織としての標準が必要だ。

```
組織レベルのシェル標準化フレームワーク

┌───────────────────────────────────────────────────────────┐
│                                                           │
│  1. 対話用シェル: 個人の自由                              │
│     → 標準化しない。各自が快適なシェルを使えばよい        │
│     → ただし、プロンプトの情報表示は統一推奨             │
│       (Starship等のクロスシェルツールが有効)              │
│                                                           │
│  2. スクリプト用シェル: チーム標準を定める                │
│     → shebangの統一: #!/bin/sh または #!/usr/bin/env bash │
│     → bash使用時: set -euo pipefail を必須とする         │
│     → ShellCheckによる静的解析をCI/CDに組み込む          │
│     → 50行超はPython等の言語に切り替える基準を明文化     │
│                                                           │
│  3. CI/CD用シェル: 環境に応じた明示的指定                 │
│     → GitHub Actions: shell: bash を明示的に指定          │
│       (コンテナ内はデフォルトが/bin/shに変わるため)       │
│     → Dockerfileのベースイメージに応じたシェル選択        │
│       Alpine系: #!/bin/sh (ashが実体)                     │
│       Debian系: #!/bin/bash も可                          │
│     → distrolessイメージ: シェルスクリプト不使用を前提    │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

このフレームワークの核心は、**層ごとに異なるルールを適用する**ことだ。対話用シェルの自由を保ちつつ、スクリプトとCI/CDの層では再現性と可搬性を優先する。「zshを使いましょう」でも「bashを使いましょう」でもなく、「どの層で何を重視するかを明確にしましょう」と言うのだ。

ShellCheckの導入は、組織レベルでの品質担保として特に効果的だ。第5回で紹介したShellCheck（Vidar Holen, 2012年-）は、シェルスクリプトの静的解析ツールとして事実上のデファクトスタンダードとなっている。SC2086（ダブルクォート忘れ）、SC2046（コマンド置換のクォーティング）といった典型的な罠を自動検出する。CI/CDパイプラインにShellCheckを組み込むだけで、チーム全体のシェルスクリプト品質は大幅に向上する。

### シェルを超えた視点——AIと対話の未来

2025年、シェルの世界に根本的な変化の兆しが現れた。

Claude Code、GitHub Copilot CLI、Gemini CLI——これらのAI CLIツールは、ターミナル上で自然言語による指示を受け付け、適切なシェルコマンドを生成・実行する。従来のシェルは「人間がコマンドの構文を覚え、正確に入力する」ことを前提としていた。AIの介在は、この前提を根本から変える。

だが、ここで安易な結論を出すべきではない。AIがシェルコマンドを生成するとしても、**そのコマンドが何をしているかを理解する能力は依然として不可欠だ。** AIが`rm -rf /`を提案したとき、それが何を意味するか分からない人間は、AIの提案を検証できない。AIが`find . -name "*.log" -exec rm {} \;`を生成したとき、`{}`の意味を理解できない人間は、コマンドの正当性を判断できない。

シェルの歴史を知ることの価値は、AIの時代にむしろ高まる。なぜなら、AIが生成するコマンドを理解し、検証し、必要に応じて修正するためには、シェルの仕組みを理解している必要があるからだ。AIは強力な道具だが、道具を使いこなすには、道具の仕組みを理解する人間が必要だ。

Thompson shellの時代から50年、シェルは「人間がコンピュータと対話する方法」の一つの実装であり続けてきた。AIの台頭は、対話の方法を変えるかもしれない。だが、対話という営みそのものは消えない。そして、対話の仕組みを理解する人間——つまり、歴史を知り、選択肢を知り、自分で判断できる人間——の価値も、消えない。

---

## 4. ハンズオン――シェル選定の評価マトリクスを作成する

この最終回のハンズオンでは、自分のチーム・プロジェクトに最適なシェル構成を設計するための評価マトリクスを作成する。単にスクリプトを実行するだけでなく、自分の頭で考え、判断を下す演習だ。

### 演習1：現状のシェル構成を可視化する

まず、自分（またはチーム）の現在のシェル構成を洗い出す。

```bash
#!/bin/sh
# 演習1: シェル構成の可視化
set -eu

echo "=== 演習1: 現状のシェル構成を可視化する ==="
echo ""

# --- Layer 1: 対話用シェル ---
echo "【Layer 1: 対話用シェル】"
echo "  デフォルトシェル: $SHELL"
if [ -n "${ZSH_VERSION:-}" ]; then
    echo "  実行中: zsh $ZSH_VERSION"
elif [ -n "${BASH_VERSION:-}" ]; then
    echo "  実行中: bash $BASH_VERSION"
elif [ -n "${FISH_VERSION:-}" ]; then
    echo "  実行中: fish $FISH_VERSION"
else
    echo "  実行中: $(ps -p $$ -o comm= 2>/dev/null || echo '不明')"
fi
echo ""

# プロンプトの種類を検出
echo "  プロンプト:"
if command -v starship > /dev/null 2>&1; then
    echo "    Starship $(starship --version 2>/dev/null | head -1)"
elif [ -n "${ZSH_THEME:-}" ]; then
    echo "    zsh テーマ: $ZSH_THEME"
elif [ -n "${PS1:-}" ]; then
    echo "    カスタムPS1設定あり"
fi
echo ""

# --- Layer 2: スクリプト用シェル ---
echo "【Layer 2: スクリプト用シェル】"
echo "  プロジェクト内のシェルスクリプト:"

# shebang行の統計
if [ -d "./" ]; then
    echo "    shebang統計（カレントディレクトリ以下）:"
    for shebang in "#!/bin/bash" "#!/bin/sh" "#!/usr/bin/env bash" "#!/usr/bin/env sh"; do
        # 再帰的に.shファイルを探す
        count=0
        for f in $(find . -name "*.sh" -type f 2>/dev/null); do
            if head -1 "$f" 2>/dev/null | grep -qF "$shebang"; then
                count=$((count + 1))
            fi
        done
        if [ "$count" -gt 0 ]; then
            echo "      $shebang: ${count}ファイル"
        fi
    done
fi
echo ""

# --- Layer 3: CI/CD用シェル ---
echo "【Layer 3: CI/CD・コンテナ用シェル】"

# GitHub Actions
if [ -d ".github/workflows" ]; then
    echo "  GitHub Actions:"
    shell_specs=$(grep -r "shell:" .github/workflows/ 2>/dev/null | wc -l)
    echo "    shell: 明示指定: ${shell_specs}箇所"
    run_steps=$(grep -r "run:" .github/workflows/ 2>/dev/null | wc -l)
    echo "    run: ステップ数: ${run_steps}箇所"
fi

# Dockerfile
dockerfile_count=$(find . -name "Dockerfile*" -type f 2>/dev/null | wc -l)
if [ "$dockerfile_count" -gt 0 ]; then
    echo "  Dockerfile: ${dockerfile_count}ファイル"
    for df in $(find . -name "Dockerfile*" -type f 2>/dev/null); do
        base=$(grep -i "^FROM" "$df" 2>/dev/null | head -1)
        if [ -n "$base" ]; then
            echo "    $df: $base"
        fi
    done
fi
echo ""

echo "=== 可視化完了 ==="
echo ""
echo "このデータをもとに、演習2で評価マトリクスを作成します。"
```

### 演習2：チームのシェル選定マトリクスを作成する

次に、以下のテンプレートを使って、自分のチームに最適なシェル構成を評価する。

```bash
#!/bin/sh
# 演習2: シェル選定マトリクス
set -eu

WORKDIR="${HOME}/shell-choice-handson-24"
mkdir -p "$WORKDIR"

cat > "$WORKDIR/shell-evaluation-matrix.md" << 'MATRIX'
# シェル選定評価マトリクス

## チーム情報

- チーム名: ________________
- 人数: ____名
- 主要プラットフォーム: [ ] Linux  [ ] macOS  [ ] Windows (WSL)
- 主要コンテナ基盤: [ ] Alpine  [ ] Debian  [ ] distroless  [ ] なし

## Layer 1: 対話用シェル

### 評価基準（1-5点で採点）

| 基準 | bash | zsh | fish | Nushell | 重み |
|------|------|-----|------|---------|------|
| チーム内の習熟度 | __ | __ | __ | __ | x3 |
| 補完の充実度 | __ | __ | __ | __ | x2 |
| 箱出しの体験 | __ | __ | __ | __ | x1 |
| カスタマイズ性 | __ | __ | __ | __ | x1 |
| 起動速度 | __ | __ | __ | __ | x1 |

### 結論
- 推奨: ______________
- 方針: [ ] 自由選択  [ ] 推奨あり  [ ] 統一

## Layer 2: スクリプト用シェル

### 評価基準（1-5点で採点）

| 基準 | POSIX sh | bash | Oils/YSH | Python | 重み |
|------|----------|------|----------|--------|------|
| 可搬性 | __ | __ | __ | __ | x3 |
| チーム内の習熟度 | __ | __ | __ | __ | x3 |
| エラー処理の堅牢性 | __ | __ | __ | __ | x2 |
| テスト容易性 | __ | __ | __ | __ | x2 |
| 既存資産との互換性 | __ | __ | __ | __ | x2 |

### 結論
- shebang標準: ______________
- bash使用時のルール: ______________
- シェルスクリプト→他言語の切り替え基準: ____行超

## Layer 3: CI/CD・システム用シェル

### 評価基準

| 基準 | 回答 |
|------|------|
| CI/CDのshell指定 | [ ] 明示  [ ] デフォルト任せ |
| Dockerベースイメージ | ______________ |
| /bin/sh の実体を把握 | [ ] はい  [ ] いいえ |
| POSIX準拠テスト | [ ] 実施  [ ] 未実施 |

### 結論
- CI/CD標準シェル: ______________
- Docker内シェル方針: ______________

## 総合判断

### 現在の構成
- 対話: ______________
- スクリプト: ______________
- CI/CD: ______________

### 理想の構成（このマトリクスの結果に基づく）
- 対話: ______________
- スクリプト: ______________
- CI/CD: ______________

### ギャップと移行計画
- ______________________________________________
- ______________________________________________
MATRIX

echo "=== 演習2: 評価マトリクスを作成しました ==="
echo ""
echo "ファイル: $WORKDIR/shell-evaluation-matrix.md"
echo ""
echo "このマトリクスをテキストエディタで開き、以下の手順で記入してください:"
echo ""
echo "  1. チーム情報を記入する"
echo "  2. 各Layerの評価基準を1-5点で採点する"
echo "  3. 重みを掛けて合計点を算出する"
echo "  4. 合計点に基づいて各Layerの推奨シェルを決定する"
echo "  5. 現在の構成と理想の構成のギャップを分析する"
echo ""
echo "重要: このマトリクスに「正解」はありません。"
echo "あなたのチームの文脈で、意識的に判断を下すことに意味があります。"
```

### 演習3：シェル移行のシミュレーション

最後に、「今使っていないシェル」を実際に試す演習を行う。

```bash
#!/bin/sh
# 演習3: シェル移行シミュレーション
set -eu

echo "=== 演習3: シェル移行シミュレーション ==="
echo ""
echo "この演習では、普段使わないシェルで一連のタスクを実行し、"
echo "対話体験の違いを体感します。"
echo ""

WORKDIR="${HOME}/shell-choice-handson-24"
mkdir -p "$WORKDIR"

# テスト用のデータを作成
cat > "$WORKDIR/sample-data.json" << 'JSON'
[
  {"name": "Thompson shell", "year": 1971, "author": "Ken Thompson", "posix": false},
  {"name": "Bourne shell", "year": 1979, "author": "Stephen Bourne", "posix": true},
  {"name": "C shell", "year": 1979, "author": "Bill Joy", "posix": false},
  {"name": "Korn shell", "year": 1983, "author": "David Korn", "posix": true},
  {"name": "bash", "year": 1989, "author": "Brian Fox", "posix": true},
  {"name": "zsh", "year": 1990, "author": "Paul Falstad", "posix": true},
  {"name": "ash", "year": 1989, "author": "Kenneth Almquist", "posix": true},
  {"name": "fish", "year": 2005, "author": "Axel Liljencrantz", "posix": false},
  {"name": "PowerShell", "year": 2006, "author": "Jeffrey Snover", "posix": false},
  {"name": "Nushell", "year": 2019, "author": "Sophia Turner", "posix": false}
]
JSON

echo "--- タスク: シェルの歴史データを処理する ---"
echo ""
echo "sample-data.json には10個のシェルのデータが格納されています。"
echo "以下のタスクを、異なるシェル/ツールで実行してみてください。"
echo ""

echo "タスク1: POSIX準拠のシェルだけを抽出し、年代順に表示する"
echo ""

# bashでの実装
echo "【bash + jq での実装】"
if command -v jq > /dev/null 2>&1; then
    jq -r '.[] | select(.posix == true) | "\(.year) \(.name) (\(.author))"' \
        "$WORKDIR/sample-data.json" | sort -n
else
    echo "  (jq がインストールされていません)"
fi
echo ""

# POSIX shでの実装（jqなし）
echo "【POSIX sh のみでの実装（jqなし）】"
echo "  (JSONをPOSIX shだけでパースするのは非現実的です。"
echo "   これが「テキスト処理の限界」の具体例です。)"
echo ""

# Nushellでの実装例を表示
echo "【Nushell での実装（参考）】"
echo '  open sample-data.json | where posix == true | sort-by year | select year name author'
echo ""

echo "タスク2: 各年代（1970s, 1980s, 1990s, 2000s, 2010s）ごとに"
echo "         登場したシェルの数を集計する"
echo ""

echo "【bash + jq での実装】"
if command -v jq > /dev/null 2>&1; then
    jq -r '.[].year' "$WORKDIR/sample-data.json" | \
    while read -r year; do
        decade=$(( (year / 10) * 10 ))
        echo "${decade}s"
    done | sort | uniq -c | sort -k2n
else
    echo "  (jq がインストールされていません)"
fi
echo ""

echo "【Nushell での実装（参考）】"
echo '  open sample-data.json | insert decade {|r| ($r.year // 10 * 10)} | group-by decade | transpose decade shells | each {|g| {decade: $g.decade, count: ($g.shells | length)}}'
echo ""

echo "--- 演習のポイント ---"
echo ""
echo "1. JSONデータの処理は、bashだけでは困難。jqという外部ツールが必要。"
echo "2. Nushellは構造化データをネイティブに扱え、記述が直感的。"
echo "3. 「どのシェル/ツールが最適か」は、扱うデータの性質に依存する。"
echo "4. テキスト処理にはbash+パイプが強く、構造化データにはNushellが強い。"
echo ""

echo "--- 追加課題（任意） ---"
echo ""
echo "以下のシェルをインストールし、同じタスクを実行してみてください:"
echo ""
echo "  Nushell:  cargo install nu  (または https://nushell.sh/ からダウンロード)"
echo "  fish:     各OSのパッケージマネージャーからインストール"
echo "  Oils:     https://oils.pub/ からダウンロード"
echo ""
echo "普段使わないシェルで30分過ごすだけで、"
echo "「自分が何を選んでいるか」の解像度が上がります。"
echo ""

# 後片付け案内
echo "--- 後片付け ---"
echo "作業ディレクトリ: $WORKDIR"
echo "削除するには: rm -rf $WORKDIR"
echo ""
echo "=== 演習完了 ==="
```

この演習で最も重要なのは、「普段使わないシェルで30分過ごす」という体験だ。bashしか使ったことがない人はfishを試してほしい。zshしか使ったことがない人はNushellを試してほしい。比較対象を持つことで初めて、「自分が何を選んでいるか」が見えるようになる。

---

## 5. まとめ――bashを使うなとは言わない。bashを「選んで」使え

### 23回の旅を終えて

この連載は、Thompson shell（1971年）から始まり、Nushell（2019年-）に至る50年以上のシェルの歴史を辿ってきた。

第1回で私は「bashが空気になった世界で、私たちはシェルの何を見失ったのか」と問うた。23回の旅を経て、その答えが見えている。

**私たちが見失ったのは、「選択」という行為そのものだ。**

bashを使うこと自体は問題ではない。bashが「最初から入っていたから」「みんな使っているから」「他を知らないから」使い続けることが問題なのだ。それは選択ではなく、惰性だ。

Thompson shellはKen Thompsonがfork/execモデルの上に「対話の最小限」を実装した選択だった。Bourne shellはStephen Bourneがシェルをプログラミング言語にするという選択だった。C shellはBill Joyが対話性に全振りするという選択だった。bashはBrian FoxがGNUの自由のためにBourne shell互換のシェルを書くという選択だった。fishはAxel LiljencrantzがPOSIXを捨てるという選択だった。NushellはSophia TurnerとYehuda Katzがテキストストリームを超えるという選択だった。

50年間、シェルの歴史は「選択」の連続だった。各シェルの作者は、何を重視し何を犠牲にするかを意識的に選んだ。対話を重視すればスクリプティングが犠牲になり、可搬性を重視すれば表現力が犠牲になり、互換性を重視すれば革新が犠牲になる。トレードオフの存在を認識し、自分の文脈に照らして判断を下す。それが「選ぶ」ということだ。

### 最終回にあたって伝えたいこと

この連載で私が伝えたかったことを、最後に五つにまとめる。

**第一に、歴史を知れ。** シェルの歴史を知ることは、現在の道具をより深く理解することにつながる。bashの`if`/`then`/`fi`がAlgol 68に由来することを知れば、その構文が恣意的でないことがわかる。cshのスクリプティングが「harmful」とされた理由を知れば、対話とスクリプティングの分離がなぜ重要かがわかる。POSIX標準がksh88のサブセットとして設計された経緯を知れば、`#!/bin/sh`の意味がわかる。歴史は、現在の道具の設計判断を理解するための地図だ。

**第二に、選択肢を知れ。** bashだけがシェルではない。zshの補完システム、fishの箱出し体験、Nushellの構造化パイプライン、dashの軽量性、Oilsの段階的移行パス——これらの選択肢を知らなければ、「選ぶ」ことはできない。少なくとも二つのシェルを一定期間使ってみることを勧める。比較対象を持つことで初めて、自分が何を重視しているかが見えてくる。

**第三に、層を分けて考えよ。** 対話用シェル、スクリプト用シェル、CI/CD用シェルは、同じシェルである必要はない。第23回で提示した三層モデルを実践してほしい。zshで対話し、`#!/bin/sh`でスクリプトを書き、dashやashがCI/CDで動く。この使い分けは矛盾ではなく、各層に最適なツールを選ぶ合理的な判断だ。

**第四に、トレードオフを受け入れよ。** すべての軸で最高得点を取るシェルは存在しない。対話の快適さと可搬性、機能の豊富さと起動速度、革新性と互換性——これらは設計上のトレードオフだ。万能のシェルを求めるのではなく、自分の文脈で何を重視するかを決め、その判断に基づいて選べ。

**第五に、選択を恐れるな。** bashから別のシェルに移行することは、大きな決断のように感じるかもしれない。だが、対話用シェルを変えるだけなら、リスクは小さい。`chsh`コマンド一つで変えられるし、合わなければ戻せばよい。重要なのは、「試してみる」という最初の一歩だ。

### あなたは何を選ぶか

冒頭の問いに戻ろう。シェルは「与えられるもの」なのか、「選ぶもの」なのか。

答えは明白だ。シェルは「選ぶもの」だ。ただし、選ぶためには知識がいる。

1971年のThompson shellから2026年の現在まで、50年以上にわたってシェルは進化し続けてきた。その歴史を知った上で、あなたの文脈——あなたの仕事、あなたのチーム、あなたのプロジェクト——に最適なシェルを選ぶ。それが「bash ありきの世界を疑え」の意味するところだ。

bashを使うなとは言わない。bashを「選んで」使え。歴史を知り、選択肢を知り、トレードオフを理解した上で、意識的にbashを選ぶならば、それは立派な判断だ。

だが、「最初から入っていたから」だけを理由にbashを使い続けるならば、あなたはシェルに「使われて」いる。

この連載が、あなたにとって「選ぶ」ための地図になったならば、24回にわたって書き続けた意味がある。

シェルの歴史は終わらない。Nushell、Oils/YSH、Elvish——次世代シェルの挑戦は始まったばかりだ。AIとシェルの融合は、対話の意味そのものを変えるかもしれない。10年後のシェルの世界は、今とは全く異なるものになっている可能性がある。

だからこそ、歴史を知る意味がある。シェルの50年の歴史は、「最適解は常に変わる」ことを教えてくれる。bashが永遠の答えではないように、今のあなたの選択も永遠の答えではない。それでよい。重要なのは、そのとき・その文脈で、意識的に選んでいることだ。

ターミナルを開いたとき、そこに表示されるプロンプトは、あなたの選択の結果だ。

その選択に、あなたは自信を持てるだろうか。

---

## 参考文献

- Ken Thompson, "Unix Programmer's Manual", 1st Edition, November 3, 1971
- Stephen R. Bourne, "The UNIX Shell", Bell System Technical Journal, 1978
- Bill Joy, "An Introduction to the C shell", 2BSD, 1979
- Tom Christiansen, "Csh Programming Considered Harmful", 1996
- David Korn, KornShell, USENIX, July 14, 1983
- Brian Fox, GNU Bash Beta (v0.99), June 8, 1989
- Chet Ramey, Bash 5.3 Release, July 3, 2025 <https://lists.gnu.org/archive/html/bash-announce/2025-07/msg00000.html>
- Paul Falstad, zsh 1.0, 1990
- Axel Liljencrantz, fish 1.0, February 13, 2005
- fish shell, "Fish 4.0: The Fish Of Theseus", February 27, 2025 <https://fishshell.com/blog/rustport/>
- Sophia Turner, Yehuda Katz, Andres Robalino, "Introducing nushell", August 23, 2019 <https://www.nushell.sh/blog/2019-08-23-introducing-nushell.html>
- Nushell GitHub Releases <https://github.com/nushell/nushell/releases>
- Andy Chu, Oils 0.37.0 Release, December 2025 <https://oils.pub/blog/2025/12/release-0.37.0.html>
- Qi Xiao, Elvish Shell <https://elv.sh/>
- Jeffrey P. Snover, "Monad Manifesto", August 8, 2002 <https://www.jsnover.com/Docs/MonadManifesto.pdf>
- IEEE Std 1003.1-2024, "POSIX Base Specifications, Issue 8", June 14, 2024 <https://ieeexplore.ieee.org/document/10555529/>
- Stack Overflow Developer Survey 2025 <https://survey.stackoverflow.co/2025/>
- Vidar Holen, ShellCheck <https://github.com/koalaman/shellcheck>
- Starship: Cross-Shell Prompt <https://starship.rs/>
- GitHub Docs, "Workflow syntax for GitHub Actions" <https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions>
- Alpine Linux Official Docker Image <https://hub.docker.com/_/alpine>
- GitHub Copilot CLI <https://github.com/github/copilot-cli>
