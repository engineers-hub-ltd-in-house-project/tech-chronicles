# 第2回：シェル以前の世界――テレタイプ、モニタプログラム、そして対話の誕生

**シリーズ**: bash ありきの世界を疑え――シェルの根源から対話と自動化の未来を考える

**著者**: 佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）

---

**この回で学べること**:

- バッチ処理の時代――パンチカードとオペレータが支配した世界
- タイムシェアリングという革命――CTSS（1961年）の誕生
- 「対話」を可能にするために必要だった技術的条件
- Multics上で"shell"という概念が生まれた経緯
- RUNCOMから.rcファイルへ――60年続く命名規則の起源

---

## 1. 導入――「待つ」ことが当たり前だった世界

大学の計算機室で、私は「バッチ処理」という概念を初めて知った。

正確には、概念として知ったのではない。古いUNIXの教科書を読んでいたとき、「パンチカードにプログラムを打ち込み、オペレータに提出し、翌日結果を受け取る」という記述に出会った。1990年代後半のことだ。私はSlackware 3.5をインストールした直後で、ターミナルにコマンドを打てば即座に結果が返ってくる世界を当たり前のものとして受け入れていた。

コマンドを打って、結果を待つ。待つといっても数秒、長くて数分。それが私の知る「コンピュータとの対話」だった。

だが教科書が描く世界は根本的に異なっていた。プログラマはプログラムをパンチカードに記録し、計算機室のカウンター越しにオペレータに手渡す。オペレータが類似のジョブをまとめてコンピュータに投入する。結果が出るのは数時間後、場合によっては翌日だ。もしプログラムにバグがあれば、修正してもう一度カードを提出し、また数時間待つ。

この記述を読んだとき、私は正直に言えば「信じがたい」と感じた。コマンドを打ったら即座に応答が返ってくる。この「当たり前」が、かつては存在しなかった。コンピュータと人間の間に「対話」が存在しない時代があった。

だが考えてみれば、私が「当たり前」として享受していたその対話的環境こそ、多くの技術者が長い年月をかけて勝ち取ったものだったのだ。ターミナルにプロンプトが表示される。コマンドを入力する。結果が即座に返ってくる。この一連の流れは、1950年代の計算機利用者にとっては夢物語だった。

前回、私はシェルの二面性——対話的インタフェースとスクリプティング言語——について語った。だが、そもそも「対話」とは何だったのか。コンピュータと人間が「対話する」という概念は、いつ、どのようにして生まれたのか。

今回はシェルが生まれる以前の世界に遡る。パンチカード、バッチ処理、テレタイプ、そしてタイムシェアリングの誕生。これらを知らずにシェルの意味を語ることはできない。

あなたが今ターミナルを開いてコマンドを打つたびに、そこには60年以上の歴史が折り重なっている。その最初の層を掘り起こすことから始めよう。

---

## 2. 歴史的背景――バッチ処理からタイムシェアリングへ

### パンチカードの時代

1950年代から1960年代にかけて、コンピュータへの入力手段はパンチカードが主流だった。

パンチカードそのものの歴史は古い。1890年の米国国勢調査でHerman Hollerithが使用したのが実用的な起点とされるが、コンピュータ用の入力媒体として広く使われるようになったのは1950年代以降のことだ。IBMの80列パンチカードは、1プログラムの1行を1枚のカードに対応させるという形式で、プログラミングの基本単位となった。

プログラマの作業はこうだ。まず紙にプログラムを書く。次にキーパンチ機（カード穿孔機）でパンチカードにコードを打ち込む。数百行のプログラムであれば数百枚のカードになる。NASAのMargaret Hamiltonのチームがアポロ計画で使用したシミュレーションプログラムでは、1回の実行に15,000枚から20,000枚のカードが必要だったと記録されている。

カードの束を手に、計算機室のカウンターに並ぶ。オペレータにカードデッキを手渡す。オペレータは類似のジョブをまとめて「バッチ」として処理する。これがバッチ処理という名前の由来だ。

### バッチ処理の構造的問題

バッチ処理の世界では、プログラマとコンピュータの間にオペレータが介在する。プログラマはコンピュータに直接触れることができない。

```
プログラマ → パンチカード → オペレータ → コンピュータ → 出力 → オペレータ → プログラマ
                                  ↑
                          ジョブキューで待機
                          （数時間〜翌日）
```

この構造には深刻な問題があった。ターンアラウンドタイム——プログラムを提出してから結果を受け取るまでの時間——が長すぎるのだ。ピーク時にはカウンターに行列ができ、結果を受け取るまでに1日以上かかることも珍しくなかった。プログラムにセミコロンひとつの誤りがあっただけで、その1日は無駄になる。修正して再提出し、また1日待つ。

1950年代後半のIBMの大型計算機は200万ドル（現在の約2,400万ドル相当）という巨額の投資であり、アイドル時間の削減は経済的に切実な課題だった。バッチ処理はコンピュータの稼働率を最大化するための方法だったが、その代償として人間の時間が犠牲になっていた。

コンピュータの時間は高価で、人間の時間は安い。この前提がバッチ処理の根底にあった。だが、この前提は永遠に続くものではなかった。

### John McCarthyの構想

1959年1月、MITのJohn McCarthyは、P.M. Morse教授宛に一通のメモを送った。"A Time Sharing Operator Program for our Projected IBM 709"と題されたこのメモは、コンピューティングの歴史における転換点のひとつとなった。

McCarthyの提案の核心は単純かつ根本的だった。コンピュータが十分に高速であれば、複数のユーザーのプログラムを高速に切り替えながら実行できる。各ユーザーから見れば、自分専用のコンピュータを使っているように見える。コンピュータの処理速度が人間の反応速度を大幅に上回っている以上、その差分を活用すれば、1台のコンピュータを同時に多数の人間が使える。

これがタイムシェアリングの着想だ。イギリスのChristopher Stracheyも1959年に独立して同様の概念を提案しており、タイムシェアリングの発明は特定の一人に帰せられるものではない。だが、McCarthyのメモがMITでの実装に直結したという点で、その影響は決定的だった。

McCarthyの構想は、バッチ処理の前提を逆転させるものだった。「コンピュータの時間は高価で、人間の時間は安い」から「人間の時間こそ高価であり、コンピュータの時間を人間のために使うべきだ」へ。この発想の転換が、シェルの誕生に至る長い道のりの出発点である。

### CTSSの誕生（1961年）

McCarthyの構想を実現に移したのは、MITのFernando J. Corbatóだった。

Corbatóは、Marjorie Merwin-DaggettおよびRobert Daleyと共に、タイムシェアリングシステムの開発に取り組んだ。1961年11月、MITの改造IBM 709上で「Experimental Time-Sharing System」のデモンストレーションが行われた。4台の端末から同時にプログラムを実行できるこのシステムは、後にCompatible Time-Sharing System（CTSS）と名付けられる。

「Compatible」（互換）という名前には意味がある。CTSSはバッチ処理との互換性を維持しつつタイムシェアリングを実現する設計だった。既存のバッチジョブも実行できる。新しいものだけを求めたのではなく、古いものとの共存を図った点に、実用的なシステム設計の知恵がある。

CTSSの実現には、ハードウェアレベルの改造が必要だった。MIT Computation CenterのIBM 7094（1963年にアップグレード）には以下の特別な改造が施された。

第一に、インターバルタイマーの追加。計算集約的なユーザープログラムを一定時間で中断し、次のユーザーに処理を譲り渡すための装置だ。タイムシェアリングの文字通りの心臓部である。

第二に、メモリの二重化。32K語（36ビット語）のメモリを2バンクに分け、バンクAにCTSSのスーパバイザ（OS）を、バンクBにユーザープログラムを格納した。この分離によって、ユーザープログラムの暴走がOSに波及することを防いだ。

第三に、CPUへのモードビットの追加。ユーザープログラムがI/O命令を直接実行することを禁止し、I/O操作をスーパバイザ経由に強制するためのものだ。

この三つの改造——タイマー、メモリ保護、特権モード——は、現代のOSにおけるプリエンプティブマルチタスク、メモリ保護、カーネルモード/ユーザーモード分離の原型にほかならない。2026年の今、あなたが使っているLinuxカーネルの根底にある設計原理は、1961年のこの改造IBM 7094にまで遡ることができる。

1963年夏、CTSSはMIT Computation Centerの一般ユーザーに対するルーティンサービスとして提供を開始した。タイムシェアリングは、もはや実験ではなく実用的なシステムになった。

### タイムシェアリングがもたらしたもの

CTSSの成功は、単に「複数人がコンピュータを同時に使えるようになった」という効率の話にとどまらない。タイムシェアリングは、コンピュータと人間の関係を根本的に変えた。

バッチ処理の世界では、プログラマは「コンピュータの時間を借りる人」だった。オペレータという仲介者を通じて、コンピュータに仕事を「お願い」する。結果は後で受け取る。この関係には、対話がない。

タイムシェアリングの世界では、プログラマは端末の前に座り、コマンドを入力し、即座に結果を見る。うまくいかなければ、その場で修正して再試行する。この「入力→応答→修正→再入力」のサイクルこそが、「対話」の本質である。

タイムシェアリングは、同時にもうひとつの革新を必然的にもたらした。パスワード認証の誕生だ。複数のユーザーがひとつのコンピュータを共有するとき、各ユーザーのファイルを他のユーザーから保護する仕組みが不可欠になる。Corbatóは各ユーザーにパスワードを設定する仕組みを導入した。CTSSは、世界で初めてコンピュータパスワードを実装したシステムとして広く知られている。

Corbatóは1990年、ACMチューリング賞を受賞した。受賞理由は「汎用大規模タイムシェアリングおよびリソース共有コンピュータシステムの概念の組織化と開発を主導した先駆的業績」である。

CTSSだけではない。1964年3月にはDartmouth大学でもDartmouth Time-Sharing System（DTSS）が稼働を始めた。John G. KemenyとThomas E. Kurtzが開発したこのシステムは、BASIC言語とともに全学生にコンピュータへのアクセスを開放した。McCarthyがKurtzに「タイムシェアリングをやるべきだ」と助言したことが契機だったという。1964年5月1日、最初のBASICプログラムが実行された。

1960年代前半のわずか数年で、「コンピュータとの対話」は夢想から現実になった。だが、この対話を本当の意味で実用的なものにするには、もうひとつの要素が必要だった。テレタイプという物理的なインタフェースである。

---

## 3. 技術論――「対話」を可能にした三つの条件

### テレタイプ――キーボードとプリンタの一体化

コンピュータとの対話には、物理的な入出力装置が必要だ。1960年代にその役割を担ったのが、テレタイプ端末だった。

テレタイプ（teletype）は、元来は電気通信用の装置である。キーボードと印字装置（プリンタ）を一体化し、電気信号で文字を送受信する。19世紀末から20世紀にかけて、通信社のニュース配信や電報サービスで広く使われていた。

1963年、Teletype CorporationがModel 33を発表した。元々は米海軍向けに設計され、Western Unionの通信ネットワーク用の低コスト端末として開発されたものだ。このModel 33が、コンピュータの世界を変えることになる。

Model 33がコンピュータとの対話に適していた理由は二つある。第一に、ASCIIコードに対応していたこと。1960年代の多くのテレタイプは独自の文字コード（Baudot符号など）を使っていたが、Model 33は7ビットASCII（プラスパリティビット）をサポートした。これにより、コンピュータとの直接的なデータ交換が容易になった。

第二に、価格が約1,000ドル（現在の約11,000ドル相当）と、他のコンピュータ端末に比べて大幅に安価だったこと。この価格は、大学や研究機関が複数の端末を設置することを経済的に可能にした。CTSSが4台の端末でデモンストレーションできた背景には、端末の低価格化がある。

1970年代中頃まで、IBM以外のほとんどのミニコンピュータ——DEC PDP-7、PDP-11を含む——にはModel 33テレタイプがコンソール端末として接続されていた。Ken ThompsonとDennis RitchieがUNIXを開発した際も、PDP-7にはModel 33テレタイプが繋がれていた。

UNIXにおいて端末デバイスが`/dev/tty`と表記されるのは、teletypeの略称"tty"に由来する。あなたが`tty`コマンドを実行したとき表示される文字列の背後には、1963年のTeletype Model 33の記憶が生きている。

だがテレタイプには根本的な制約があった。大文字しか出力できない。画面がなく、紙にインクで印字するため、出力は一方向的だ。一度印字された文字は消去できない。カーソルという概念も存在しない。

```
テレタイプの入出力モデル:

  ユーザー → キーボード → [文字が電気信号として送信]
                                        ↓
                                    コンピュータ
                                        ↓
  ユーザー ← 印字装置 ← [文字が電気信号として返送]
             （紙に印字、スクロール不可、大文字のみ）
```

この制約は、シェルの設計に深い影響を与えている。シェルのプロンプトが1行のテキスト表示であること。コマンドの出力が上から下へ流れること。画面をクリアするという操作が後付けであること。これらはすべて、テレタイプという物理的な装置に起源を持つ。

現代のターミナルエミュレータが「端末」を「エミュレート」しているとき、それはテレタイプの振る舞いを画面上に再現しているのだ。あなたのターミナルの「スクロールバッファ」は、テレタイプの紙の巻物に相当する。

### 対話に必要な三つの条件

タイムシェアリングの実現と、テレタイプという入出力装置の普及。この二つが揃ったとき、コンピュータと人間の「対話」が初めて可能になった。

「対話」が成立するためには、三つの技術的条件が同時に満たされなければならない。

**第一の条件：入力の即時受付。** バッチ処理では、入力（パンチカード）は一括して投入される。対話的処理では、ユーザーがキーボードで文字を打つたびに、その入力をシステムが即座に受け取る必要がある。テレタイプ端末は1文字ずつ送信できるため、この条件を満たした。

**第二の条件：出力の即時表示。** バッチ処理では、出力はジョブ完了後にまとめて提供される。対話的処理では、コマンドの実行結果をリアルタイムでユーザーに返す必要がある。テレタイプの印字装置が、文字単位でこの応答を実現した。

**第三の条件：状態の保持。** バッチ処理では、各ジョブは独立しており、前のジョブの状態を引き継がない。対話的処理では、カレントディレクトリ、環境変数、実行中のプロセスといった「状態」をセッション全体にわたって保持する必要がある。

この第三の条件が、シェルの存在を必然にした。

入力の受付と出力の表示は、端末とOSの機能で実現できる。だが「状態の保持」——ユーザーが何を作業し、どこにいて、何を設定したか——を管理するプログラムは、カーネルとは別に必要だった。カーネルはプロセスの管理やハードウェアの抽象化を担うが、ユーザーの対話セッション全体を管理する役割は持たない。

ここに、カーネルとユーザーの間に位置する「殻」——シェル——が必要とされる理由がある。

```
バッチ処理時代:
  プログラマ → パンチカード → オペレータ → コンピュータ
  （対話なし、状態保持なし）

タイムシェアリング時代:
  ユーザー ←→ テレタイプ端末 ←→ シェル ←→ カーネル
  （リアルタイム対話、状態保持あり）
                                  ↑
                          ここにシェルが必要
                          （セッション状態の管理）
```

### コンテキストスイッチと端末多重化

タイムシェアリングを技術的に実現するには、CPUが複数のユーザープログラムを高速に切り替えて実行する仕組みが必要だった。これがコンテキストスイッチである。

コンテキストスイッチとは、実行中のプログラムの状態（レジスタ、プログラムカウンタ、メモリマッピング等）を保存し、別のプログラムの状態を復元して実行を切り替える操作だ。CTSSのIBM 7094では、インターバルタイマーが一定時間ごとに割り込みを発生させ、スーパバイザがコンテキストスイッチを実行した。

CTSSの場合、タイムスライス（各ユーザーに割り当てられるCPU時間）は約200ミリ秒だった。人間がキーボードを叩く速度（毎秒数文字）に対してCPUの処理速度は圧倒的に速いため、各ユーザーには自分専用のコンピュータを使っているかのような錯覚を与えることができた。

端末多重化は、複数のテレタイプ端末をコンピュータに同時接続するための技術だ。各端末からの入力を識別し、対応するユーザーのプロセスに振り分ける。この多重化を行うのもOSの役割であり、CTSSのスーパバイザがこの処理を担当していた。

タイムシェアリングの技術は、現代のOSにおけるマルチタスク、仮想メモリ、プロセス間保護の直接的な先祖である。CTSSで確立された「タイマー割り込み＋コンテキストスイッチ＋メモリ保護」という三本柱は、60年以上経った今も変わっていない。

---

## 4. ハンズオン――バッチ処理と対話的処理を体験する

理論はここまでにして、実際に手を動かそう。1960年代のバッチ処理的ワークフローと、対話的ワークフローの違いを体感する演習を行う。

### 環境構築

Docker環境を前提とする。以下のコマンドでUbuntu 24.04コンテナを起動する。

```bash
docker run -it ubuntu:24.04 bash
```

あるいは、本記事に付属する`setup.sh`スクリプトを使えば、演習環境の構築を一括で行える。

```bash
bash setup.sh
```

### 演習1：バッチ処理的ワークフローの再現

まず、「バッチ処理的」なワークフローを体験する。プログラムを書き、一括実行し、結果を確認する。途中経過は見えない。

テキストファイルに処理を書き、一括で実行する。これがバッチ処理の本質だ。

```bash
# 「パンチカード」にあたるスクリプトファイルを作成する
cat > /tmp/batch_job.sh << 'BATCH'
#!/bin/sh
echo "=== バッチジョブ開始 ==="
echo "日時: $(date)"
echo "ユーザー: $(whoami)"
echo "ホスト: $(hostname)"
echo ""
echo "--- /etc/passwd の行数を集計 ---"
wc -l /etc/passwd
echo ""
echo "--- ファイルシステムの使用量 ---"
df -h /
echo ""
echo "=== バッチジョブ完了 ==="
BATCH

chmod +x /tmp/batch_job.sh

# 「オペレータに提出」してジョブを実行し、結果をファイルに保存する
/tmp/batch_job.sh > /tmp/batch_output.txt 2>&1

# 「翌日、結果を受け取る」
echo "--- バッチ処理の結果 ---"
cat /tmp/batch_output.txt
```

ポイントは、スクリプトの実行中に途中経過が一切見えないことだ。出力はすべてファイルにリダイレクトされ、実行完了後に初めて確認できる。バグがあれば、スクリプトを修正して再度実行するしかない。1960年代のプログラマは、この「書く→提出→待つ→確認→修正→再提出」のサイクルを、1サイクルあたり数時間から1日のスパンで繰り返していた。

### 演習2：対話的ワークフロー

次に、同じ情報を対話的に取得する。

```bash
# 対話的に、1ステップずつ結果を確認しながら進める
date
whoami
hostname
wc -l /etc/passwd
df -h /
```

違いは歴然としている。各コマンドの結果を即座に確認し、次のコマンドを選択できる。`wc -l /etc/passwd`の結果を見て「もっと詳しく見たい」と思えば、その場で`cat /etc/passwd`を打てる。バッチ処理では、この「もっと知りたい」という衝動に即座に応えられない。

対話的処理の本質は、この「入力→結果確認→判断→次の入力」というフィードバックループの高速化にある。

### 演習3：heredocで「パンチカード的」入力を再現する

シェルのheredoc（here document）機能を使って、バッチ的な入力をシミュレートしてみよう。heredocはBourne shell（1979年）で導入された機能だが、複数行の入力を一括してコマンドに渡すという点で、パンチカードの精神を受け継いでいる。

```bash
# heredocによるバッチ的入力
cat << 'EOF'
これは「パンチカード」のようなものだ。
あらかじめ決められた内容を、
一括してプログラムに渡す。
途中で変更することはできない。
EOF
```

```bash
# heredocをコマンドの入力として使う
sort << 'EOF'
banana
apple
cherry
date
elderberry
EOF
```

heredocで書かれた内容は、実行前に確定している。途中で「やっぱりgrapeも追加しよう」と思っても、入力済みのheredocを変更することはできない。これがバッチ的処理の制約だ。

一方、対話的にsortを使う場合は異なる。

```bash
# 対話的にsortに入力する（Ctrl-Dで入力終了）
sort
```

`sort`コマンドを実行すると、端末は入力待ちになる。1行ずつ入力し、最後にCtrl-Dを押す。入力しながら「この行はいらない」と思えばやり直せる。対話的処理の柔軟性がここにある。

### 演習4：RUNCOMの精神を体験する

Louis PouzinがCTSS上で作ったRUNCOMは、コマンドスクリプトの実行エンジンだった。これは現代のシェルスクリプトの直接的な先祖にあたる。RUNCOMの本質は「コマンドをプログラミング言語のように組み合わせて使う」ことだ。

```bash
# 複数のコマンドを組み合わせて処理を自動化する
# これがRUNCOMの精神——コマンドをビルディングブロックとして使う

# Step 1: データを生成する
seq 1 100 > /tmp/numbers.txt

# Step 2: フィルタリングする（偶数のみ）
awk '$1 % 2 == 0' /tmp/numbers.txt > /tmp/even.txt

# Step 3: 集計する
echo "偶数の個数: $(wc -l < /tmp/even.txt)"
echo "偶数の合計: $(awk '{sum+=$1} END {print sum}' /tmp/even.txt)"
```

PouzinがRUNCOMで実現しようとした「コマンドをサブルーチンライブラリのように組み合わせる」という発想は、後のUNIXにおけるパイプラインとシェルスクリプトの基盤となった。

### 演習5：.rcファイルの起源を確認する

RUNCOMから派生した".rc"命名規則が、現代の設定ファイルに生き続けていることを確認しよう。

```bash
# 現在のシステムに存在する.rcファイルを探す
echo "--- ホームディレクトリの.rcファイル ---"
ls -la ~/.*rc 2>/dev/null || echo "(なし)"

echo ""
echo "--- /etc配下の.rcファイル ---"
ls /etc/*rc 2>/dev/null || echo "(なし)"
ls /etc/*rc.* 2>/dev/null || echo "(なし)"

echo ""
echo "--- .rcの由来 ---"
echo "rc = run commands"
echo "起源: Louis Pouzin, CTSS RUNCOM (1963年頃)"
echo "系譜: RUNCOM → Multics shell → UNIX → .bashrc, .vimrc, .zshrc..."
```

1963年頃にPouzinがCTSSで作ったRUNCOMのスクリプトファイルは"runcom"と呼ばれていた。その略称"rc"が、UNIXに引き継がれ、`.profile`（Bourne shell）、`.cshrc`（C shell）、`.bashrc`（bash）、`.vimrc`（Vim）、`.zshrc`（zsh）と、60年以上にわたって使われ続けている。Kernighan & Ritchieによれば、UNIXの.rcファイルはこのCTSSのRUNCOMに由来する。

あなたのホームディレクトリにある`.bashrc`や`.zshrc`の名前には、1963年の技術者の仕事が刻まれているのだ。

---

## 5. まとめと次回予告

### この回の要点

第一に、バッチ処理の時代、コンピュータと人間の間に「対話」は存在しなかった。プログラマはパンチカードを通じてオペレータにジョブを提出し、結果を数時間から翌日まで待った。コンピュータの時間が高価で、人間の時間が安いという前提がこの構造を支えていた。

第二に、1959年のJohn McCarthyの提案と、1961年のFernando CorbatóによるCTSSの実現が、タイムシェアリングの時代を切り開いた。CTSSは、インターバルタイマー、メモリの二重化、モードビットという三つのハードウェア改造によって、1台のIBM 7094で複数ユーザーの同時利用を可能にした。この設計原理は現代のOSにそのまま受け継がれている。

第三に、「対話」の成立には三つの技術的条件が必要だった。入力の即時受付、出力の即時表示、状態の保持。最初の二つはテレタイプ端末が実現し、三つ目はシェルの必要性を生んだ。

第四に、Louis Pouzinが1963年頃にCTSS上で作ったRUNCOMが「コマンドをプログラミング言語のように使う」という発想を生み、1964年末にMulticsの設計段階で"shell"という概念を命名した。RUNCOMの名前は".rc"ファイルの命名規則として現代まで生き続けている。

第五に、Teletype Model 33（1963年）は、ASCIIコード対応と低価格によってコンピュータ端末の標準となった。UNIXの`/dev/tty`という表記は、このテレタイプの記憶を今に伝えている。

### 冒頭の問いへの暫定回答

「コンピュータと人間の対話は、どこから始まったのか」――この問いに対する暫定的な答えを示そう。

対話は、1961年のCTSSで始まった。McCarthyが構想し、Corbatóが実現した。だが、その「始まり」は一人の天才の閃きではない。パンチカードの制約への不満、コンピュータ価格の漸減、テレタイプ端末の普及、ハードウェアにおける保護機構の実装――これらの条件が揃ったとき、「対話」は必然として生まれた。

そして、対話の実現は新たな問いを生んだ。ユーザーの入力をどう解釈し、どのプログラムを起動し、その結果をどうユーザーに返すか。この「仲介者」の役割を果たすプログラムが必要になった。それが「シェル」だ。

### 次回予告

次回は、UNIXにおける最初のシェル――Ken ThompsonのThompson shellを取り上げる。1971年、UNIX V1とともに生まれたこのシェルは、変数を持たず、制御構造を持たず、パイプすらV3（1973年）まで存在しなかった。「プログラミング言語」どころか、最小限の「対話ツール」でしかなかった。

だが、Thompson shellには決定的な設計判断があった。シェルをカーネルの外に置き、通常のユーザープログラムとして実装したこと。fork/execモデルによるプロセス起動。この設計が、後のすべてのUNIXシェルの基盤となる。

最初のUNIXシェルは、何ができて、何ができなかったのか。その「できなかったこと」にこそ、シェルの進化の物語がある。

---

## 参考文献

- John McCarthy, "Memorandum to P. M. Morse: A Time Sharing Operator Program for our Projected IBM 709" (1959) <http://jmc.stanford.edu/computing-science/timesharing-memo.html>
- Fernando J. Corbató, Marjorie Merwin-Daggett, Robert C. Daley, "An Experimental Time-Sharing System", AFIPS Spring Joint Computer Conference (1962)
- Multicians.org, "The Origin of the Shell" <https://www.multicians.org/shell.html>
- Tom Van Vleck, "The IBM 7094 and CTSS" <https://www.multicians.org/thvv/7094.html>
- Tom Van Vleck, "Compatible Time-Sharing System (1961-1973) Fiftieth Anniversary Commemorative Overview" <https://multicians.org/thvv/compatible-time-sharing-system.pdf>
- Wikipedia, "Teletype Model 33" <https://en.wikipedia.org/wiki/Teletype_Model_33>
- Wikipedia, "Compatible Time-Sharing System" <https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System>
- Wikipedia, "RUNCOM" <https://en.wikipedia.org/wiki/RUNCOM>
- Wikipedia, "Punched card" <https://en.wikipedia.org/wiki/Punched_card>
- ACM, "Fernando Corbató - A.M. Turing Award Laureate" <https://amturing.acm.org/award_winners/corbato_1009471.cfm>
- Dartmouth College Library, "Sharing the Computer" <https://www.dartmouth.edu/library/rauner/exhibits/sharing-the-computer.html>
- Columbia University, "Teletype Machines" <https://www.columbia.edu/cu/computinghistory/teletype/index.html>
