# 第1回：なぜこの連載を書くのか――bash ありきの世界への違和感

**シリーズ**: bash ありきの世界を疑え――シェルの根源から対話と自動化の未来を考える

**著者**: 佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）

---

**この回で学べること**:

- 「シェル」とは何か――kernel/shell/applicationの三層構造
- 対話的インタフェースとスクリプティングという二面性
- 2020年代のシェル利用状況とbashの支配構造
- 複数のシェルを並べて比較することの意味

---

## 1. 導入――bashが「空気」になった世界で

Slackware 3.5のインストールが終わった日のことを、私は今でも覚えている。

1990年代後半、当時大学生だった私は、友人に勧められてLinuxの世界に足を踏み入れた。CDから起動し、パーティションを切り、パッケージを選択し、長い時間をかけてインストールが完了する。再起動してログインすると、画面にプロンプトが現れた。`bash-2.05$`――この無骨な文字列が、私のUNIX人生の出発点である。

だが正直に告白すれば、当時の私は自分が「bash」というものを使っていることを知らなかった。正確に言えば、それが「シェル」であること、シェルには種類があること、そしてそれを「選べる」ということを、まったく理解していなかった。ターミナルを開けば何かが動く。コマンドを打てば結果が返ってくる。それで十分だった。シェルは、空気のように透明な存在だった。

この「透明さ」に最初の亀裂が入ったのは、大学の計算機室でBSD環境に触れたときだ。ログインした瞬間、プロンプトの見た目が違う。`%`記号が出迎える。bashでは`for`だった構文が`foreach`になっている。コマンドの挙動が微妙に異なる。これがtcshとの出会いであり、「シェルは選べるものだ」と私が初めて認識した瞬間でもあった。

あれから四半世紀以上が経った。2020年代の今、私はかつての自分と同じ状態にいるエンジニアを、毎週のように目にする。

ある日、チームの若手エンジニアに聞いたことがある。「シェルは何を使っているのか」と。彼は自信を持って答えた。「Oh My Zshを入れたので、zshです」。私が「ではzshの何が気に入っているのか」と重ねると、彼は少し考えてから「プロンプトがかっこいいところ」と答えた。

この答えが間違っているとは言わない。だが、ここには深い断絶がある。Oh My Zshはzshの設定フレームワークであって、zshそのものではない。そして「プロンプトがかっこいい」ことは、zshの本質的な設計思想とは何の関係もない。彼はzshを「使って」いるが、zshを「選んで」はいない。誰かが作ったテンプレートを、意味を理解せずに適用しているだけだ。

2024年のStack Overflow Developer Surveyを見ると、Bash/Shellは「Programming, scripting, and markup languages」部門で33.9%の利用率を記録し、全体の第6位に位置している。JavaScript、HTML/CSS、Python、SQL、TypeScriptに次ぐ位置だ。開発者の3人に1人がbashまたはシェルスクリプトを使っている計算になる。だが、そのうちの何割が、自分の使っているシェルが「何を解決しているのか」を理解しているだろうか。

この連載は、その問いに向き合う試みである。

bashを否定したいのではない。bashは優れたシェルだ。だが、bashを「空気」として吸い続けることは、bashに「依存」していることと同義である。空気の成分を知らずに呼吸している人間は、空気が薄くなったとき何が起きているか理解できない。Thompson shellからNushellまでの歴史を知ることで初めて、シェルの本質を理解し、自分で選べるエンジニアになれる。

あなたは今、どのシェルを使っているだろうか。そして、なぜそのシェルを使っているのだろうか。「最初から入っていたから」以外の答えを持っているだろうか。

---

## 2. 歴史的背景――bashが「デフォルト」の座を獲得するまで

bashが支配的な地位を築くまでには、50年にわたるシェルの進化史がある。この連載で詳しく語る歴史を、ここでは俯瞰的に素描しておきたい。

### 「シェル」という概念の誕生

「shell」という言葉が最初に使われたのは、1964年末のことである。フランス人エンジニアのLouis Pouzinが、MITのMulticsプロジェクトにおいて、コマンドプロセッサを指してこの言葉を造語した。kernel（核）を包む「殻」というメタファーだ。Pouzinの概念は、コマンドをプログラミング言語のように使えるようにするという構想を含んでいた。Pouzinが1965年にフランスに帰国した後、MITのGlenda Schroederが彼のフローチャートをもとにMultics用の最初のシェルを実装している。

この時点で既に、シェルの本質的な性格が定まっていた。シェルとは、カーネルの外に置かれた独立したプログラムである。カーネルの機能ではなく、カーネルを包む「殻」である。この設計判断は、後のUNIXにも受け継がれ、シェルを自由に交換可能な部品にした。

### Thompson shellからBourne shellへ

1971年、Ken ThompsonがUNIX V1とともに最初のUNIXシェルを世に送り出した。Thompson shellは対話的なコマンド実行に特化しており、入出力リダイレクト（`<`, `>`）とシーケンシャル実行（`;`）、バックグラウンド実行（`&`）を備えていた。パイプ（`|`）はV3（1973年）で追加された。だが、変数も制御構造もなかった。シェルスクリプトという概念は、まだ視野に入っていなかった。

1979年、Stephen BourneがUNIX V7に搭載したBourne shellが、この景色を一変させる。`if`/`for`/`while`/`case`構文、変数、here document、関数――Bourne shellはシェルを「コマンドインタプリタ」から「プログラミング言語」に昇格させた。Algol 68の影響を受けた構文（`if...fi`、`case...esac`）は独特だったが、`/bin/sh`として標準シェルの座を確立した。この`/bin/sh`という位置は、今日に至るまでシェルの世界の基準点であり続けている。

### cshの反乱とシェル文化の分裂

1978年、UCバークレーの大学院生Bill JoyがC shellを開発した。Bourne shellとはまったく異なるC風の構文、ヒストリ機能（`!`コマンド）、ジョブコントロール（`fg`/`bg`/`Ctrl-Z`）、エイリアス、チルダ展開（`~`）――cshは対話的な使い勝手を飛躍的に向上させた。

だが、cshのスクリプティング能力には深刻な問題があった。1995年、Tom Christiansenが"Csh Programming Considered Harmful"を発表し、cshでのスクリプティングの危険性を体系的に指摘した。ここから、シェルの世界に「対話用シェル」と「スクリプト用シェル」という二つの文化が定着していく。

### bashの覇権

この分裂を統合しようとしたのが、1983年のKorn shell（David Korn, Bell Labs）であり、1989年のbash（Brian Fox, FSF）である。

bashの成功は、技術的な優秀さだけでは説明できない。1989年6月8日にBrian FoxがGNUプロジェクトの一環としてリリースしたbashは、Bourne shell互換でありながらcshの対話的機能を取り込み、さらに独自の拡張を加えた「全部入り」のシェルだった。そしてGPLv2ライセンスの下で自由に配布できた。

1990年代、Linuxディストリビューションが急速に普及すると、bashはそのデフォルトシェルとして世界中に広まった。Linuxのシェルとしてbashが選ばれたのは、技術的必然というよりも、GNUプロジェクトの自由ソフトウェアとしてBourne shell互換を実現した唯一の選択肢だったという歴史的偶然の産物である。そしてLinuxの普及がbashの普及を加速し、bashの普及がLinuxエコシステムのbash依存を深め、というフィードバックループが回り続けた。

### 2019年の事件

2019年秋、macOS Catalinaがデフォルトシェルをbashからzshに変更した。ターミナルを開くと"The default interactive shell is now zsh."というメッセージが表示される。

この変更の直接的な理由は技術的ではない。bash 4.0（2009年）以降がGPLv3ライセンスに移行し、AppleはGPLv3のTivoization禁止条項を受け入れられなかった。macOSに同梱されていたbashは、10年以上前のbash 3.2（2006年、GPLv2最終版）のまま凍結されていた。Appleが選んだのは、MITライセンス系統のzshだった。

ソフトウェアライセンスが技術選定を決める。bashの覇権は技術的必然ではなく、GNUのライセンス政策とLinuxの普及という歴史的条件の産物だった。そしてその条件が変わったとき、覇権は揺らいだ。この事実を知らないエンジニアは少なくない。

---

## 3. 技術論――シェルとは何か

ここで「シェル」という言葉が何を指しているのかを、技術的に定義しておこう。

### kernel/shell/applicationの三層構造

コンピュータのソフトウェアスタックは、概念的に三つの層で構成される。

```
┌──────────────────────────────────┐
│         Application              │  ← ユーザーが直接使うプログラム
│    (grep, awk, git, python...)   │
├──────────────────────────────────┤
│           Shell                  │  ← ユーザーとカーネルの間の仲介者
│    (bash, zsh, fish, dash...)    │
├──────────────────────────────────┤
│           Kernel                 │  ← ハードウェアを抽象化する核
│    (Linux, XNU, FreeBSD...)      │
├──────────────────────────────────┤
│         Hardware                 │  ← CPU, メモリ, ディスク, NIC
└──────────────────────────────────┘
```

"shell"という名前そのものが、kernel（核）を包む「殻」であることを示している。ユーザーはカーネルを直接操作するのではなく、シェルという殻を通じてカーネルと対話する。

ただし、ここで重要な事実がある。UNIXにおいて、シェルは特権的なプログラムではない。カーネルの観点から見れば、`bash`も`grep`も`python`も、等しく「ユーザー空間で動作するプログラム」に過ぎない。シェルが特別なのは、ユーザーがログインしたとき最初に起動されるプログラムであること、そして他のプログラムを起動する役割を担っていること、この二点においてのみだ。

この設計は、Louis Pouzinがshellの概念を提唱した1964年から一貫している。シェルをカーネルの外に置く。シェルを交換可能な部品にする。この判断が、bashからzshへ、zshからfishへ、fishからNushellへと、シェルを自由に乗り換えられる世界を可能にしている。

### シェルの二面性――対話とスクリプティング

シェルには、根本的に異なる二つの使われ方がある。

**対話的インタフェース（Interactive Shell）**は、人間がリアルタイムでコマンドを入力し、結果を確認する使い方だ。ターミナルを開き、`ls`と打ち、ファイル一覧を眺める。`cd`でディレクトリを移動する。`git status`で状態を確認する。ここでのシェルは、人間とコンピュータの対話を仲介する「インタフェース」である。

**スクリプティング言語（Non-Interactive Shell）**は、一連のコマンドをファイルに書き、自動実行する使い方だ。`.sh`ファイルにデプロイ手順を記述し、CI/CDパイプラインで実行する。`cron`で定期実行する。Dockerfileの`RUN`命令で環境構築を自動化する。ここでのシェルは、自動化のための「プログラミング言語」である。

この二面性は、シェルの設計における本質的な緊張関係を生む。

対話的インタフェースとしてのシェルには、補完（TAB補完）、ヒストリ、構文ハイライト、プロンプトカスタマイズ、ジョブコントロールといった機能が求められる。人間の入力効率を最大化する方向の進化だ。

一方、スクリプティング言語としてのシェルには、POSIX準拠（ポータビリティ）、高速起動、堅牢なエラーハンドリング、予測可能な挙動が求められる。機械が正確に処理できる方向の進化だ。

この二つの方向性は、しばしば衝突する。

たとえば、fishは対話的シェルとして極めて優れている。構文ハイライト、オートサジェスチョン、存在しないコマンドの赤色表示がデフォルトで有効だ。だがfishはPOSIX非互換であり、既存のシェルスクリプトの大半はfishでは動作しない。

逆に、dashは高速起動とPOSIX準拠に特化したシェルだ。Ubuntuは2006年に`/bin/sh`をbashからdashに切り替え、起動速度を3-5倍に改善した。だがdashには補完機能もヒストリ検索も構文ハイライトもなく、対話的シェルとしてはほぼ使い物にならない。

bashとzshは、この両方をひとつのシェルで実現しようとした「全部入り」のアプローチだ。対話的機能もスクリプティング機能も備える。だが、全部入りの代償として、巨大で複雑な言語仕様と遅い起動速度を抱えることになった。

```
対話的シェルとしての強さ
↑
│  fish ★
│            zsh ★
│
│       bash ★
│
│                      dash ★
│
└─────────────────────────→ スクリプト用シェルとしての強さ
                            （POSIX準拠・高速・堅牢性）
```

この図はもちろん単純化だが、根本的な構造は正確である。「対話に最適なシェル」と「スクリプティングに最適なシェル」は、同じものである必要はない。むしろ、同じものであろうとすることが、シェルの設計上の最も深い緊張なのだ。

私が日常で行っている使い分けを例にしよう。対話的シェルにはzshを使い、スクリプトの先頭には`#!/bin/sh`と書く。CI/CD環境ではdashまたはash（Alpine Linux）が動く。三つの異なるシェルを、三つの異なる目的で使い分けている。このような使い分けの根拠を、この連載で語っていく。

---

## 4. ハンズオン――4つのシェルを並べて比較する

理論はここまでにして、実際に手を動かそう。bash、zsh、fish、dashの4つのシェルをDocker上で起動し、同じ操作を試して差異を体感する。

### 環境構築

Docker環境を前提とする。以下のコマンドでUbuntu 24.04コンテナを起動し、必要なシェルをインストールする。

```bash
# Ubuntu 24.04ベースのコンテナを起動
docker run -it ubuntu:24.04 bash

# コンテナ内でシェルをインストール
apt-get update && apt-get install -y zsh fish dash
```

あるいは、本記事に付属する`setup.sh`スクリプトを使えば、4つのシェルのインストールと演習環境の構築を一括で行える。

```bash
bash setup.sh
```

### 演習1：変数代入の構文比較

まず、最も基本的な操作――変数への値の代入を、4つのシェルで比較する。

**bash**:

```bash
bash -c 'NAME="world"; echo "Hello, $NAME"'
# => Hello, world
```

**zsh**:

```bash
zsh -c 'NAME="world"; echo "Hello, $NAME"'
# => Hello, world
```

**fish**:

```bash
fish -c 'set NAME "world"; echo "Hello, $NAME"'
# => Hello, world
```

**dash**:

```bash
dash -c 'NAME="world"; echo "Hello, $NAME"'
# => Hello, world
```

bash、zsh、dashは同じ構文で動作する。これはBourne shell系統の共通構文だ。fishだけが異なる。fishは`VAR=value`構文を持たず、`set`コマンドで変数を代入する。これはfishが意図的にPOSIX互換を捨てた結果である。

### 演習2：ループ構文の比較

次に、forループで1から5までの数を出力してみよう。

**bash**:

```bash
bash -c 'for i in 1 2 3 4 5; do echo "Number: $i"; done'
```

**zsh**:

```bash
zsh -c 'for i in 1 2 3 4 5; do echo "Number: $i"; done'
```

**fish**:

```bash
fish -c 'for i in 1 2 3 4 5; echo "Number: $i"; end'
```

**dash**:

```bash
dash -c 'for i in 1 2 3 4 5; do echo "Number: $i"; done'
```

ここでもfishだけが異なる。Bourne系シェル（bash, zsh, dash）は`do...done`構文を使うが、fishは`end`で閉じる。また、fishにはセミコロンの後に`do`を置く構文がない。fishの構文はBourne shellの歴史的遺産を引きずっておらず、一貫性のある独自設計になっている。

### 演習3：パイプラインの比較

パイプは、シェルの最も強力な機能のひとつだ。1973年にKen ThompsonがUNIX V3に実装して以来、あらゆるシェルに受け継がれている。

ここでは、`/etc/passwd`ファイルからシェル名を抽出し、重複を除いて並べ替えるタスクを試す。

**bash**:

```bash
bash -c 'cat /etc/passwd | awk -F: "{print \$7}" | sort | uniq'
```

**zsh**:

```bash
zsh -c 'cat /etc/passwd | awk -F: "{print \$7}" | sort | uniq'
```

**fish**:

```bash
fish -c 'cat /etc/passwd | awk -F: "{print \$7}" | sort | uniq'
```

**dash**:

```bash
dash -c 'cat /etc/passwd | awk -F: "{print \$7}" | sort | uniq'
```

パイプライン自体は4つのシェルで同一の構文が使える。パイプ（`|`）はThompson shell以来のシェルの普遍的な機能であり、シェルの種類が変わっても変わらない。これは「小さなプログラムをパイプでつなぐ」というUNIX哲学が、50年にわたって保たれている証左である。

### 演習4：対話的機能の違いを体感する

最後に、各シェルを対話モードで起動し、対話的機能の差を体感してみよう。

```bash
# dashで対話モードに入る
dash

# bashで対話モードに入る
bash

# zshで対話モードに入る
zsh

# fishで対話モードに入る
fish
```

各シェルで以下の操作を試してほしい。

1. **TAB補完**: `/etc/`まで入力してTABを押す。bash、zsh、fishではファイル名の候補が表示されるが、dashでは何も起きない
2. **ヒストリ検索**: `Ctrl-R`を押す。bash、zshではインクリメンタルサーチが始まる。fishではコマンドラインにヒストリサジェスチョンがリアルタイムに表示される。dashではこの機能がない
3. **構文ハイライト**: fishでは入力中のコマンドが色分けされ、存在しないコマンド名は赤で表示される。bash、zsh、dashにはこの機能がデフォルトでは存在しない（zshはプラグインで追加可能）

dashで操作したときの「素朴さ」と、fishで操作したときの「豊かさ」の差が、対話的シェルとしての機能差を如実に物語る。だが覚えておいてほしい。dashがスクリプト実行において3-5倍高速であるという事実を。豊かさにはコストがある。

---

## 5. まとめと次回予告

### この回の要点

第一に、シェルとは「カーネルを包む殻」であり、ユーザーとカーネルの間の仲介者である。Louis Pouzinが1964年に命名したこの概念は、60年後の今も変わっていない。

第二に、シェルには「対話的インタフェース」と「スクリプティング言語」という二つの顔がある。この二面性は根本的な設計上の緊張を生み、すべてのシェルはこの緊張に対する異なる回答である。

第三に、bashの覇権は技術的必然ではない。GNUプロジェクトのライセンス政策、Linuxの普及、そして歴史的な偶然の重なりが、bashを「デフォルト」の座に押し上げた。2019年のmacOS Catalinaの事件は、その構造の脆さを露呈した。

第四に、bash、zsh、fish、dashは同じ「シェル」でありながら、設計思想が大きく異なる。変数代入の構文ひとつとっても、fishはBourne系の慣習を捨てている。パイプだけが50年にわたって共通している。

### 冒頭の問いへの暫定回答

「bashが空気になった世界で、私たちはシェルの何を見失ったのか」――この問いに対する暫定的な答えを示しておこう。

私たちが見失ったのは、「選択」である。

bashを使うことが問題なのではない。bashを「選んで」使っているのか、それとも「最初から入っていたから」使っているのか。その違いが問題なのだ。選択とは、代替案を知り、それぞれの設計思想とトレードオフを理解した上で判断することだ。この連載は、その選択に必要な知識を提供する。

### 次回予告

次回は、シェルが生まれる以前の世界――テレタイプ、パンチカード、バッチ処理の時代に遡る。コンピュータと人間の「対話」は、どこから始まったのか。CTSS（1961年）におけるタイムシェアリングの誕生と、Multics上での"shell"という概念の成立を追う。

シェルは「対話」の上に生まれた。対話なしには、シェルも存在しない。では、「対話」とは何だったのか。

---

## 参考文献

- Stack Overflow, "2024 Stack Overflow Developer Survey - Technology" <https://survey.stackoverflow.co/2024/technology>
- Multicians.org, "The Origin of the Shell" <https://www.multicians.org/shell.html>
- Wikipedia, "Thompson shell" <https://en.wikipedia.org/wiki/Thompson_shell>
- Wikipedia, "Bourne shell" <https://en.wikipedia.org/wiki/Bourne_shell>
- Wikipedia, "Bash (Unix shell)" <https://en.wikipedia.org/wiki/Bash_(Unix_shell)>
- Wikipedia, "Z shell" <https://en.wikipedia.org/wiki/Z_shell>
- Apple Support, "Change the default shell in Terminal on Mac" <https://support.apple.com/guide/terminal/change-the-default-shell-trml113/mac>
- Ubuntu Wiki, "DashAsBinSh" <https://wiki.ubuntu.com/DashAsBinSh>
- Robby Russell, "d'Oh My Zsh" <https://www.freecodecamp.org/news/d-oh-my-zsh-af99ca54212c/>
- LWN.net, "Fish - The friendly interactive shell" <https://lwn.net/Articles/136232/>
- Tom Christiansen, "Csh Programming Considered Harmful" (1995)
