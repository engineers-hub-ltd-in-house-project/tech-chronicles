# データベースの地層

## ——RDBからNewSQLまで、データ管理50年の地殻変動

### 第9回：ストアドプロシージャとトリガー——ロジックはどこに置くべきか

**連載「データベースの地層——RDBからNewSQLまで、データ管理50年の地殻変動」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- ストアドプロシージャの起源——1987年にSybase SQL Serverが切り開いた「サーバサイドロジック」の世界
- PL/SQL、T-SQL、PL/pgSQLの系譜と、SQL/PSM標準化の遅れが生んだベンダーロックイン
- 「ファットDB」アーキテクチャの全盛期と、その崩壊の経緯
- トリガーがもたらすデータ整合性の保証と、暗黙的な副作用という毒
- 同じビジネスロジックをストアドプロシージャとアプリケーションコードで実装し、保守性・テスト容易性・パフォーマンスを比較する方法

---

## 1. 数千行のPL/pgSQLが教えてくれたこと

2010年頃、私はある保守案件を引き継いだ。

業務系のWebシステムで、画面の数は30ほどだったと記憶している。コードベースはPHP。フレームワークは使っておらず、生のPHPファイルが数百個、ディレクトリに雑然と並んでいた。だが問題はPHPのコードではなかった。ビジネスロジックの大部分が、PostgreSQLのストアドプロシージャの中にあった。

PL/pgSQLで書かれたストアドプロシージャが200個以上。そのうち最大のものは3,000行を超えていた。受注処理、在庫引当、請求計算、帳票データの生成——業務の核心を担うロジックがすべてデータベースの中に閉じ込められていた。PHPのコードは、ストアドプロシージャを呼び出して結果を画面に表示するだけの薄い殻に過ぎなかった。

最初の1週間で、私は途方に暮れた。

テストがない。ストアドプロシージャに対する自動テストは一切書かれていなかった。PHPのユニットテストフレームワークからストアドプロシージャの内部ロジックをテストする手段がない。データベースに接続し、テストデータを投入し、ストアドプロシージャを実行し、結果を検証し、テストデータを片付ける——この一連のプロセスを自動化するには、テスト自体がデータベース依存になる。モックもスタブもできない。ロジックとデータが不可分に結合していた。

デバッグができない。当時のPostgreSQLにはステップ実行のデバッガがなかった（pgAdmin 4のデバッガ拡張は後年の話だ）。`RAISE NOTICE`で変数の値を出力し、ログを目で追う。3,000行のストアドプロシージャの中で、どこでデータがおかしくなっているのかを特定するために、数十個の`RAISE NOTICE`を埋め込んでは消す。原始的なprintf デバッグだ。

バージョン管理が事実上不可能だった。ストアドプロシージャのソースコードはデータベースの中にある。PHP のコードはGitで管理されていたが、ストアドプロシージャはSQLファイルとしてエクスポートされたものがリポジトリに入っていた。だが実際にデータベースに適用されているコードと、リポジトリ上のSQLファイルが一致している保証がない。「ちょっとした修正」を本番のデータベースに直接適用し、SQLファイルの更新を忘れる。こうしてリポジトリと本番は乖離していく。

その案件で私は誓った。「二度とストアドプロシージャにビジネスロジックを書かない」と。

だが、この判断は正しかったのか。ストアドプロシージャには確かに利点がある。ネットワーク越しに大量のデータをやり取りする代わりに、データの近くでロジックを実行する。セキュリティ境界として機能する。パフォーマンスが問題になる局面で、アプリケーション層では得られない速度を出すことがある。

ビジネスロジックをデータベースに置くべきか、アプリケーションに置くべきか。この問いは、RDBの能力が増すにつれて避けて通れなくなった。そして、その答えは時代によって振り子のように揺れ動いてきた。

---

## 2. ストアドプロシージャの誕生——サーバサイドロジックの起源

### Sybaseが切り開いた道

ストアドプロシージャの歴史は、1987年のSybase SQL Serverに始まる。

Sybase SQL Serverは、ストアドプロシージャとトリガーをサポートした最初の商用RDBMSだ。Bob Epsteinを中心に、カリフォルニア州バークレーの自宅から始まったプロジェクトが、1987年5月にSunワークステーション向けUNIX版として最初の商用バージョンを出荷した。

Sybase SQL Serverが画期的だったのは、クライアント/サーバアーキテクチャを採用した最初のDBMSでもあった点だ。それ以前のデータベースシステムは、端末がメインフレームに直接接続するモノリシックな構成が主流だった。Sybaseはネットワークを介してクライアントとサーバが通信するモデルを商用化し、その設計の中でストアドプロシージャは不可欠な要素として組み込まれた。

なぜストアドプロシージャが必要だったのか。1980年代後半のネットワーク帯域は、現在から見れば極めて貧弱だ。10BASE-Tイーサネットの理論帯域は10Mbps。実効帯域はさらに低い。クライアントがSQLを1行ずつサーバに送り、結果を受け取り、次のSQLを送る——このラウンドトリップの繰り返しは、ネットワーク遅延を累積的に蓄積する。

ストアドプロシージャは、複数のSQL文をひとまとめにしてサーバ側に保存し、一度の呼び出しで実行する。クライアントは「この処理を実行せよ」という指示だけを送り、結果だけを受け取る。ネットワークの往復回数が劇的に減る。1980年代のネットワーク環境では、この差は無視できなかった。

Sybaseが開発した手続き型SQL拡張はTransact-SQL（T-SQL）と呼ばれた。T-SQLは標準SQLに変数宣言、条件分岐（IF/ELSE）、ループ（WHILE）、エラーハンドリング、カーソル操作を追加した。SQLの宣言的な世界に、手続き型プログラミングの制御構造を持ち込んだのだ。

### Microsoft SQL Serverへの継承

1988年1月、MicrosoftはAshton-TateおよびSybaseと契約を結び、IBM OS/2向けにSybase SQL Serverの派生版を開発した。1989年にリリースされたMicrosoft SQL Server v1.0は、Sybase SQL Server 3.0をベースとしていた。1994年まで、Microsoft SQL Serverには3つのSybase著作権表示が含まれていた。

1993年7月のWindows NT発売前後に、SybaseとMicrosoftは袂を分かつ。それぞれが独自の進化を遂げ、SQL Server 2005でレガシーSybaseコードは完全に書き換えられた。だがT-SQLという言語は、今日もMicrosoft SQL ServerとSybase ASE（現SAP ASE）の双方で使い続けられている。

### Oracleの回答——PL/SQL

Oracleは別のアプローチでサーバサイドロジックに挑んだ。

PL/SQL（Procedural Language/SQL）の最初のバージョンはSQL*Forms v3.0とともに登場した。これはクライアント側のフォームアプリケーション内で手続き的な処理を記述するためのものだった。1991年、Oracle 6のTransaction Processing OptionとしてサーバサイドでのPL/SQL実行が可能になったが、この段階ではまだストアドプロシージャの保存と再利用はできなかった。

転換点は1992年、Oracle 7.0とともに出荷されたPL/SQL 2.0だ。このバージョンで初めて、プロシージャやファンクションをデータベース内に保存し、後から呼び出すことが可能になった。PL/SQLの言語設計はAda言語の影響を強く受けており、ブロック構造、例外処理、強い型付けといったAdaの特徴がPL/SQLに引き継がれている。

PL/SQL 2.0の登場により、Oracleのエコシステムでは「ビジネスロジックをデータベースに置く」という設計思想が急速に浸透した。Oracle Databaseは企業システムの中核を担う製品であり、DBAとPL/SQL開発者がシステムの心臓部を掌握する——この構造が、後に「ファットDB」アーキテクチャと呼ばれる設計パラダイムを形成していく。

### PL/pgSQLと標準化の遅れ

PostgreSQLの手続き型言語であるPL/pgSQLは、Jan Wieckによって実装され、1998年10月にリリースされたPostgreSQL 6.4で初登場した。PL/pgSQLはOracle PL/SQLに似た構文を持ち、PL/SQLからの移行を比較的容易にする設計だった。PL/pgSQL、PL/SQL、そして後述するSQL/PSM標準のいずれも、Ada言語の影響を受けている。

興味深いのは、PostgreSQLにおける「ストアドプロシージャ」の概念の変遷だ。PostgreSQL 11（2018年）でCREATE PROCEDUREコマンドが導入されるまで、PostgreSQLには正式な「プロシージャ」がなかった。すべてのサーバサイドロジックは「関数」（CREATE FUNCTION）として定義され、戻り値のないプロシージャはvoid型の関数で代替していた。CREATE PROCEDUREの導入によって初めて、関数内ではできなかったトランザクション制御（COMMITやROLLBACK）がプロシージャ内で可能になった。

MySQLがストアドプロシージャをサポートしたのは、さらに後のことだ。MySQL 5.0（2005年10月正式リリース）でストアドプロシージャ、トリガー、ビュー、カーソルが導入された。Oracle（1992年）やPostgreSQL（1998年）と比較すると大幅に遅い参入だ。前回触れたように、MySQLは「シンプルさと速度」を優先する設計判断を採っており、ストアドプロシージャのような「重い」機能は長らく後回しにされていた。

```
手続き型SQL拡張の系譜

1987  Sybase SQL Server ─── Transact-SQL (T-SQL)
          │
          ├─→ 1989  Microsoft SQL Server ─── T-SQL（Sybaseから継承）
          │          （1993年に独自路線へ）
          │
1991  Oracle 6 ─── PL/SQL 1.0（サーバサイド実行、保存不可）
1992  Oracle 7.0 ─── PL/SQL 2.0（ストアドプロシージャ保存可能）
          │
1996  ISO ─── SQL/PSM標準（各ベンダーの独自実装が先行）
          │
1998  PostgreSQL 6.4 ─── PL/pgSQL（PL/SQL影響下）
          │
2005  MySQL 5.0 ─── ストアドプロシージャ初サポート
          │
2018  PostgreSQL 11 ─── CREATE PROCEDURE導入
```

### SQL/PSM——遅すぎた標準化

1990年頃、ANSI SQL委員会のJim Meltonを中心とするグループが、ストアドプロシージャの標準化に着手した。結果として1996年にSQL/PSM（SQL/Persistent Stored Modules）がISO/IEC 9075-4:1996として公開された。

だが標準化は遅すぎた。

OracleのPL/SQL（1992年）、SybaseとMicrosoftのT-SQL（1987年/1989年）、InformixのSPL（1996年）——各ベンダーはすでに独自の手続き型言語を確立し、それぞれのエコシステムを築いていた。SQL/PSM標準が存在しても、既存の言語を捨てて標準に移行するベンダーはなかった。結果として、手続き型SQL拡張は「最も互換性のない」SQL機能の一つとなった。

PL/SQLで書かれたストアドプロシージャをT-SQLに移植するには、構文の書き換えだけでなく、例外処理モデル、カーソルの扱い、データ型の対応関係を再設計する必要がある。PL/pgSQLはPL/SQLに似ているが完全な互換ではない。この非互換性こそが、ストアドプロシージャの最大の欠点の一つである「ベンダーロックイン」の根本原因だ。

---

## 3. 「ファットDB」の全盛と崩壊——ロジック配置の振り子

### 三層アーキテクチャとロジックの居場所

ビジネスロジックをどこに置くか。この問いを理解するには、アプリケーションアーキテクチャの変遷を俯瞰する必要がある。

```
ロジック配置の3つのパターン

パターン1：ファットDB（Thick Database）
┌─────────────┐    ┌─────────────┐    ┌──────────────────┐
│ プレゼン層   │───→│ 薄いアプリ層 │───→│ DB層（ロジック集中）│
│ (UI表示のみ) │    │ (呼出のみ)  │    │ SP/トリガー/ビュー │
└─────────────┘    └─────────────┘    └──────────────────┘

パターン2：ファットアプリ（Thick Application）
┌─────────────┐    ┌──────────────────┐    ┌─────────────┐
│ プレゼン層   │───→│ アプリ層          │───→│ DB層         │
│ (UI表示のみ) │    │ (ロジック集中)    │    │ (CRUDのみ)   │
└─────────────┘    └──────────────────┘    └─────────────┘

パターン3：分散（Distributed Logic）
┌─────────────┐    ┌──────────────────┐    ┌──────────────────┐
│ プレゼン層   │───→│ アプリ層          │───→│ DB層              │
│ (バリデーション)│    │ (業務ロジック)    │    │ (整合性制約+SP) │
└─────────────┘    └──────────────────┘    └──────────────────┘
```

1990年代後半から2000年代前半、エンタープライズシステムの世界では「ファットDB」パラダイムが強い影響力を持っていた。特にOracle Databaseのエコシステムにおいて、この設計思想は支配的だった。

ファットDBの主張はこうだ。データの整合性を最も確実に保証できるのは、データに最も近い場所——つまりデータベースエンジン自体である。ビジネスルールをストアドプロシージャとして実装し、アプリケーションからはトランザクショナルAPIを通じてのみデータにアクセスさせる。テーブルへの直接アクセスは禁止し、ストアドプロシージャとビューだけを公開する。こうすることで、どのアプリケーションからアクセスしても、同じビジネスルールが強制される。

この設計にはいくつかの明確な利点がある。

第一に、データ整合性の一元管理だ。複数のアプリケーションが同じデータベースにアクセスする環境（エンタープライズ環境では珍しくない）で、各アプリケーションがそれぞれビジネスルールを実装すると、ルールの不一致が生じるリスクがある。データベース側にルールを集約すれば、このリスクを排除できる。

第二に、ネットワーク効率だ。大量のデータを処理するバッチ処理や、複数テーブルにまたがる複雑な集計を、アプリケーション層でSQL文を逐次発行して実行するのは効率が悪い。ストアドプロシージャならサーバ側で完結する。

第三に、セキュリティ境界の確保だ。テーブルへのSELECT/INSERT/UPDATE/DELETE権限をアプリケーションユーザーに直接付与する代わりに、ストアドプロシージャのEXECUTE権限のみを付与する。ストアドプロシージャは定義者権限（definer's rights）で実行されるため、テーブルの構造や直接操作がアプリケーションから隠蔽される。

### ファットDBが崩壊した理由

2000年代後半から2010年代にかけて、ファットDBアーキテクチャは急速に支持を失っていく。何が起きたのか。

**テストの困難さ**が最大の要因だ。2000年代に入り、XP（エクストリームプログラミング）やTDD（テスト駆動開発）の実践が広がると、「自動テストのないコードは負債である」という認識が浸透した。だがストアドプロシージャの自動テストは、アプリケーションコードのテストと比較して格段に難しい。

ストアドプロシージャをテストするには、データベースに接続し、テストデータを投入し、プロシージャを実行し、結果を検証し、テストデータを片付けるという一連のプロセスが必要だ。テスト対象のロジックとデータストアが不可分に結合しているため、モックやスタブによる分離ができない。テストの実行にはデータベースインスタンスが必要で、テスト間のデータ干渉を防ぐための仕組みも自前で構築しなければならない。結果として、テストの作成コストと実行時間が膨大になり、テストが書かれない。

**デバッグの困難さ**も深刻だ。アプリケーションコードなら、IDEのブレークポイントで処理を止め、変数の中身を覗き、ステップ実行で処理の流れを追える。ストアドプロシージャのデバッグツールは限定的で、SQL Serverのデバッガは比較的充実しているが、PostgreSQLやMySQLでは`RAISE NOTICE`や`SELECT`による手動デバッグが主流だった。数千行のストアドプロシージャを、ログ出力だけで追うのは現実的ではない。

**バージョン管理の乖離**がシステムを蝕む。アプリケーションコードはGitで管理される。だがストアドプロシージャのソースはデータベース内に存在する。SQLファイルをGitに入れることはできるが、「データベース上の実際のコード」と「リポジトリ上のSQLファイル」の同期は手動で行う必要がある。Flyway（2010年リリース）やLiquibase（2006年初版）のようなデータベースマイグレーションツールが登場し、この問題を部分的に解決したが、根本的な課題——二つのコードベース（アプリケーションとデータベース）の同期——は消えない。

**デプロイの複雑化**も問題だ。アプリケーションのデプロイは、新しいバージョンのコードをサーバに配置して切り替える。ゼロダウンタイムデプロイも確立された手法がある。だがストアドプロシージャの変更は、稼働中のデータベースに対するDDL操作だ。古いバージョンのアプリケーションが新しいストアドプロシージャを呼ぶ、あるいは新しいアプリケーションが古いストアドプロシージャを呼ぶ——バージョン不整合のリスクが常につきまとう。アプリケーションとデータベースのデプロイを同期させる必要があり、デプロイパイプラインの複雑さが増す。

Martin Fowlerは2003年の著書『Patterns of Enterprise Application Architecture』で、ドメインロジックの組織化パターンとしてTransaction Script、Domain Model、Table Moduleの3つを定義し、また「Domain Logic and SQL」という記事でストアドプロシージャの限界を指摘した。ビューやストアドプロシージャによるカプセル化には限界があり、特にデータが複数ソースにまたがる場合、完全なカプセル化はアプリケーション層でしか実現できないと論じている。

### ORMの台頭と「シンDB」への移行

2000年代半ばから2010年代にかけて、ORM（Object-Relational Mapping）フレームワークの普及が、ロジックのアプリケーション層への移動を決定的にした。

Ruby on Rails（2004年）のActiveRecord、JavaのHibernate（2001年初版）、PythonのDjango ORM（2005年）——これらのフレームワークは、データベースのテーブルをプログラミング言語のオブジェクトとして扱い、SQLの記述を大幅に削減した。ORMの世界では、ビジネスロジックはモデルクラスのメソッドとして記述される。ストアドプロシージャの出番はない。

ORMの台頭は、開発者のスキルセットにも影響を与えた。Rails世代の開発者にとって、SQLは「ORMが裏で生成するもの」であり、ストアドプロシージャはもちろん、生のSQL文すら書く機会が減っていった。T-SQLやPL/SQLに精通したデータベース開発者という職種は、需要こそ消えなかったものの、新世代の開発者がその道に進むことは少なくなった。

さらに2010年代のマイクロサービスアーキテクチャの普及が、ファットDBパラダイムに止めを刺す。マイクロサービスでは、各サービスが独自のデータストアを持つことが推奨される（Database per Service パターン）。データベースはサービスの内部実装の一部であり、外部に公開するのはAPIだ。ストアドプロシージャでビジネスロジックを共有するという発想自体が、マイクロサービスの設計原則と矛盾する。

こうして、振り子は「ファットDB」から「シンDB」へと振れた。データベースはCRUD操作とデータ整合性の保証に専念し、ビジネスロジックはアプリケーション層に置く。これが2020年代の主流だ。

だが、振り子が完全に片側に振り切れたわけではない。

---

## 4. トリガーの功罪——暗黙の守護者か、見えない罠か

### トリガーとは何か

ストアドプロシージャがアプリケーションから明示的に呼び出されるのに対し、トリガー（Trigger）はデータベースのイベントに応じて自動的に実行される。INSERT、UPDATE、DELETE——これらのデータ操作がテーブルに対して行われたとき、事前（BEFORE）または事後（AFTER）に、あるいは操作の代わりに（INSTEAD OF）、定義済みのロジックが発火する。

トリガーの概念も、Sybase SQL Serverが1987年にストアドプロシージャとともに導入したものだ。その後、Oracle、Microsoft SQL Server、PostgreSQL、MySQLと、主要なRDBMSがいずれもトリガー機能を備えるに至った。

```sql
-- PostgreSQLでのトリガー例：更新日時の自動記録
CREATE OR REPLACE FUNCTION update_modified_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_timestamp();
```

このトリガーは、`orders`テーブルの任意の行が更新されるたびに、`updated_at`カラムを現在時刻で自動更新する。アプリケーションコードが`updated_at`の設定を忘れても、トリガーが保証する。

### トリガーの正当な用途

トリガーが正当に機能する場面は存在する。

**監査ログ（Audit Trail）**はその典型だ。重要なテーブルへの変更を、誰が、いつ、何を、どう変えたかを別テーブルに自動記録する。アプリケーションコードに依存しないため、直接のSQLアクセスやバッチ処理による変更も漏れなく捕捉できる。金融や医療など、コンプライアンス要件の厳しい分野で広く使われている。

```sql
-- 監査ログのトリガー例
CREATE OR REPLACE FUNCTION audit_orders_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO orders_audit (
            order_id, changed_at, operation,
            old_amount, new_amount, changed_by
        ) VALUES (
            OLD.id, NOW(), 'UPDATE',
            OLD.amount, NEW.amount, current_user
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO orders_audit (
            order_id, changed_at, operation,
            old_amount, new_amount, changed_by
        ) VALUES (
            OLD.id, NOW(), 'DELETE',
            OLD.amount, NULL, current_user
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**派生データの自動計算**も合理的な用途だ。たとえば注文明細の変更時に注文合計を自動再計算する、在庫テーブルの変更時に集計テーブルを更新するなど、データの一貫性を宣言的に保証できる。

**参照整合性の拡張**として、外部キー制約では表現しきれない複雑な整合性ルールを実装する場面もある。たとえば「ステータスが"完了"の注文は金額の変更を禁止する」といったビジネスルールだ。

### トリガーの暗黙的な罠

だがトリガーには、本質的に危険な特性がある。**暗黙性**だ。

ストアドプロシージャは明示的に呼び出す。コードを読めば「ここでストアドプロシージャXが呼ばれる」と分かる。だがトリガーは見えない。INSERT文を実行したとき、そのテーブルに何個のトリガーが定義されているか、アプリケーションコードからは分からない。トリガーが別のテーブルにINSERTし、そのINSERTが別のトリガーを発火し——カスケード的にトリガーが連鎖する。

この暗黙性は、以下の問題を引き起こす。

**予期しないパフォーマンス劣化**。大量のバルクINSERTを実行したとき、各行に対してトリガーが発火する。1万行のINSERTが1万回のトリガー実行を引き起こし、各トリガーが別テーブルへのINSERTを行えば、実質的に2万回のDML操作になる。アプリケーション開発者がバルクINSERTの実行計画を立てるとき、トリガーの存在を認識していなければ、性能見積もりは根本的に狂う。

**デバッグの困難さの増幅**。データが意図しない状態になったとき、原因がアプリケーションコードなのか、トリガーなのか、トリガーから連鎖的に発火した別のトリガーなのかを特定するのは容易でない。ストアドプロシージャのデバッグが困難だと述べたが、トリガーのデバッグはそれ以上に厄介だ。トリガーはブレークポイントの設定すら通常の手段ではできない。

**テスト対象の不可視性**。テストコードがINSERT文を実行したとき、そのINSERTに付随するトリガーの動作もテスト対象に含まれる。だがテストコードの中に、トリガーの存在を示すものは何もない。テストが失敗したとき、テストコードとテーブル定義だけを見ても原因は特定できない。

**マイグレーションとの干渉**。テーブル構造を変更するマイグレーションを実行するとき、既存のトリガーが予期しない動作を引き起こすことがある。マイグレーションスクリプトが一時的にトリガーを無効化し、構造変更後に再有効化する——この手順を忘れると、データ不整合が発生する。

### トリガーを使うべき場面、避けるべき場面

トリガーの使用に関して、私が24年の経験から得た判断基準はこうだ。

トリガーを使うべき場面は、**ロジックがデータの物理的な性質に密接に関わり、アプリケーション層の関与なしに保証されるべき場合**だ。監査ログ、`updated_at`の自動更新、参照整合性の拡張——これらは「データベースの責務」として自然だ。

トリガーを避けるべき場面は、**ロジックがビジネスルールそのものである場合**だ。在庫引当のロジック、価格計算、ステータス遷移の制御——これらはアプリケーション層で明示的に実装し、テストし、バージョン管理すべきだ。

一つの目安として、トリガーのロジックが10行を超えるなら、それはアプリケーション層にあるべきロジックがデータベースに漏れ出している兆候だ。

---

## 5. ストアドプロシージャが輝く場面——全否定は知的怠惰である

### パフォーマンスが絶対的に重要な場面

冒頭で「二度とストアドプロシージャにビジネスロジックを書かない」と誓った私だが、その後の経験を通じて、この誓いは修正が必要だと認識するに至った。

大量データのバッチ処理は、ストアドプロシージャの領分だ。数百万行のデータに対する集計・変換・挿入を、アプリケーション層からSQLを逐次発行して行うと、ネットワークのラウンドトリップとアプリケーション側のメモリ消費が問題になる。ストアドプロシージャなら、データの近くで処理が完結する。

ETL（Extract, Transform, Load）処理も同様だ。データウェアハウスやレポーティング用のデータ変換で、テーブル間のJOINと複雑な変換ロジックを一括実行する場合、ストアドプロシージャのパフォーマンス上の利点は明白だ。

### セキュリティが最優先の場面

PCI DSS（Payment Card Industry Data Security Standard）やHIPAA（Health Insurance Portability and Accountability Act）のような厳格なコンプライアンス要件がある場合、ストアドプロシージャによるセキュリティ境界の設定は理にかなっている。テーブルへの直接アクセスを禁止し、ストアドプロシージャ経由のみでデータ操作を許可することで、データアクセスの監査とアクセス制御を一元化できる。

### レガシーシステムとの共存

エンタープライズの現実として、PL/SQLで書かれた数万行のストアドプロシージャが稼働するOracle Databaseは、今日も世界中で動いている。これを「全面的に書き換えるべき」と主張するのは簡単だが、動いているシステムの全面書き換えには膨大なリスクとコストが伴う。

現実的なアプローチは、新規開発ではアプリケーション層にロジックを置き、既存のストアドプロシージャは段階的に移行するか、あるいは「触らない」ことだ。動いているストアドプロシージャを無理に書き換えて障害を起こすのは、技術的な潔癖症の代償としては高すぎる。

### ロジック配置の判断基準

ストアドプロシージャとアプリケーションコードの選択は、二者択一ではなく判断基準の問題だ。以下に、私が用いている判断フレームワークを示す。

```
ロジック配置の判断基準

                        ストアドプロシージャ向き    アプリケーション向き
─────────────────────────────────────────────────────────────
データ量              大量（100万行以上の処理）    少量〜中量
ネットワーク制約       帯域が限定的               十分な帯域
テスト要件            低い（バッチ処理等）        高い（CI/CD必須）
変更頻度              低い（安定したロジック）     高い（頻繁な変更）
マルチDB対応          不要                        必要
セキュリティ要件       厳格（コンプライアンス）    標準的
チームのスキル         DBA・SQL専門家がいる       アプリ開発者中心
デプロイ方式          計画停止が許容される        ゼロダウンタイム
```

この基準に「正解」はない。だが「判断基準がない」のは問題だ。「ストアドプロシージャは悪」「ストアドプロシージャは万能」のどちらも、思考停止に過ぎない。

---

## 6. ハンズオン: ストアドプロシージャとアプリケーションコードの比較

今回のハンズオンでは、同じビジネスロジック（受注処理）をPostgreSQLのストアドプロシージャとアプリケーションコード（SQLスクリプト）の両方で実装し、保守性・パフォーマンスの違いを体験する。

### 演習概要

1. 受注テーブルと在庫テーブルを作成する
2. 「在庫を確認し、在庫があれば受注を記録して在庫を減らす」というロジックをストアドプロシージャで実装する
3. 同じロジックをトランザクション付きのSQLスクリプトで実装する
4. 両者のパフォーマンスと可読性を比較する
5. トリガーによる監査ログの自動記録を体験する

### 環境構築

```bash
# handson/database-history/09-stored-procedures-and-triggers/setup.sh を実行
bash setup.sh
```

### 演習1: ストアドプロシージャによる受注処理

PostgreSQLに接続する。

```bash
docker exec -it db-history-ep09-pg psql -U postgres -d handson
```

setup.shが作成した受注処理のストアドプロシージャを確認する。

```sql
-- ストアドプロシージャの確認
\df+ process_order
```

ストアドプロシージャの内部ロジックはこうなっている。

```sql
-- 受注処理ストアドプロシージャ（setup.shで作成済み）
-- process_order(customer_id, product_id, quantity)
--
-- 1. 在庫を確認する
-- 2. 在庫が足りなければエラーを返す
-- 3. 在庫を減らす
-- 4. 受注レコードを作成する
-- 5. 受注IDを返す
```

このストアドプロシージャを実行する。

```sql
-- 在庫の確認
SELECT * FROM inventory;

-- 受注処理の実行（ストアドプロシージャ経由）
SELECT process_order(1, 1, 5);

-- 在庫が減っていることを確認
SELECT * FROM inventory WHERE product_id = 1;

-- 受注レコードが作成されていることを確認
SELECT * FROM orders;

-- 在庫不足のケース
SELECT process_order(1, 1, 99999);
-- → ERROR: Insufficient stock ...
```

ストアドプロシージャの利点を確認しよう。1回の関数呼び出しで、在庫確認・在庫更新・受注作成がアトミックに実行される。アプリケーションからは`SELECT process_order(1, 1, 5);`の一行で済む。ネットワークラウンドトリップは1回だ。

### 演習2: アプリケーション側SQLによる同じ処理

同じロジックを、トランザクション付きのSQLスクリプトとして実装する。

```sql
-- アプリケーション側で実行するSQL（複数のステートメント）
BEGIN;

-- Step 1: 在庫を確認（FOR UPDATEで行ロック取得）
SELECT stock_quantity
FROM inventory
WHERE product_id = 2
FOR UPDATE;
-- → アプリケーション側で stock_quantity >= 注文数量 を検証

-- Step 2: 在庫を減らす
UPDATE inventory
SET stock_quantity = stock_quantity - 3,
    updated_at = NOW()
WHERE product_id = 2;

-- Step 3: 受注レコードを作成する
INSERT INTO orders (customer_id, product_id, quantity, total_price)
SELECT 1, 2, 3, p.price * 3
FROM products p
WHERE p.id = 2;

COMMIT;

-- 結果を確認
SELECT * FROM inventory WHERE product_id = 2;
SELECT * FROM orders ORDER BY id DESC LIMIT 1;
```

アプリケーション側SQLの場合、各ステップが明示的に見える。何が起きているかをコードリーディングだけで把握できる。テストも各ステップを個別に検証できる。だがネットワーク越しの実行では、BEGIN、SELECT、UPDATE、INSERT、COMMITの5回のラウンドトリップが発生する（プリペアドステートメントやバッチ実行で削減は可能だ）。

### 演習3: パフォーマンス比較

setup.shが用意したベンチマーク用関数で、大量の受注処理のパフォーマンスを比較する。

```sql
-- ストアドプロシージャ版: 1000件の受注処理
SELECT benchmark_sp_orders(1000);

-- アプリケーション版（個別SQL）: 1000件の受注処理
SELECT benchmark_individual_orders(1000);

-- 結果を比較する
-- ストアドプロシージャ版の方が高速になるはずだ
-- 差はネットワーク環境（ローカルでは小さい）とデータ量による
```

ローカルのDocker環境ではネットワーク遅延がほぼゼロのため、差は小さい。だが実際のプロダクション環境——アプリケーションサーバとデータベースサーバが物理的に分離し、ネットワークレイテンシが数ミリ秒ある——では、1000回のラウンドトリップ差は数秒の違いになりうる。

### 演習4: トリガーによる監査ログ

setup.shが作成したトリガーを確認する。

```sql
-- 注文テーブルの監査トリガーを確認
SELECT tgname, tgtype, tgenabled
FROM pg_trigger
WHERE tgrelid = 'orders'::regclass AND NOT tgisinternal;

-- 注文を変更する
UPDATE orders SET quantity = 10 WHERE id = 1;

-- 監査ログを確認する
SELECT * FROM orders_audit ORDER BY changed_at DESC;
-- → UPDATE操作が自動的に記録されている

-- 注文を削除する
DELETE FROM orders WHERE id = 1;

-- 監査ログを確認する
SELECT * FROM orders_audit ORDER BY changed_at DESC;
-- → DELETE操作も自動的に記録されている
```

トリガーがアプリケーションコードの関与なしにデータ変更を捕捉していることを確認できる。直接SQLで変更しても、ORMを通じて変更しても、バッチ処理で変更しても、監査ログは必ず記録される。これがトリガーの正当な用途だ。

### 演習5: トリガーの連鎖と暗黙的な副作用

setup.shが作成した連鎖トリガーの動作を確認する。

```sql
-- 在庫変更 → 在庫ログ記録のトリガーが設定されている
-- 受注処理を実行すると:
--   1. orders テーブルに INSERT → 監査トリガー発火
--   2. inventory テーブルに UPDATE → 在庫ログトリガー発火

-- まず現在のログ件数を確認
SELECT COUNT(*) FROM orders_audit;
SELECT COUNT(*) FROM inventory_log;

-- 受注処理を1件実行
SELECT process_order(2, 3, 1);

-- ログが増えていることを確認
SELECT COUNT(*) FROM orders_audit;
SELECT COUNT(*) FROM inventory_log;

-- 1回のprocess_order呼び出しで、複数のトリガーが発火していることがわかる
-- アプリケーションコードからは、この連鎖は見えない
```

### 後片付け

```bash
docker rm -f db-history-ep09-pg
```

---

## 7. 判断基準を持て——「ロジックをどこに置くか」の本質

第9回を振り返ろう。

**ストアドプロシージャは1987年にSybase SQL Serverが商用化した技術であり、クライアント/サーバアーキテクチャにおけるネットワーク効率の向上が当初の動機だった。** SybaseのT-SQL、OracleのPL/SQL（1992年）、PostgreSQLのPL/pgSQL（1998年）、MySQL 5.0のストアドプロシージャサポート（2005年）と、各RDBMSが独自の手続き型言語を発展させた。1996年にSQL/PSM標準が制定されたが、各ベンダーの独自実装が先行していたため、互換性の問題は解消されなかった。

**2000年代の「ファットDB」アーキテクチャは、ストアドプロシージャにビジネスロジックを集中させる設計パラダイムだった。** データ整合性の一元管理、ネットワーク効率、セキュリティ境界の確保という明確な利点があった。だがテスト困難、デバッグ困難、バージョン管理の乖離、デプロイの複雑化という欠点が、TDD、CI/CD、マイクロサービスの時代に致命的な弱点となった。

**トリガーはデータベースイベントに応じて自動実行される機構であり、監査ログや更新日時の自動記録には正当な用途がある。** だがその本質的な暗黙性——アプリケーションコードからトリガーの存在が見えない——が、パフォーマンスの予測困難、デバッグの困難、テストの不透明さを引き起こす。

**ストアドプロシージャを全否定するのは知的怠惰だ。** 大量データのバッチ処理、厳格なセキュリティ要件、レガシーシステムとの共存——ストアドプロシージャが合理的な選択である場面は確かに存在する。問題は「ストアドプロシージャの是非」ではなく、「判断基準を持っているか」だ。

冒頭の問いに戻ろう。「ビジネスロジックをデータベースに置くべきか、アプリケーションに置くべきか？」

この問いに対する私の回答はこうだ。「ロジックをどこに置くか」は技術的問題であると同時に組織的問題でもある。チームにDBAがいるか、テストの自動化はどこまで求められるか、デプロイの頻度はどの程度か、データの整合性要件はどれほど厳格か——これらの変数によって、最適解は変わる。正解はないが、判断基準は持てる。

次回は、RDBの黄金期をさらに掘り下げる。インデックス設計——なぜ同じSQLでも、インデックスの有無で100倍速度が変わるのか。B+Treeの構造からEXPLAIN ANALYZEの読み方まで、データベースの「速さ」の正体に迫る。

あなたのプロジェクトでは、ビジネスロジックはどこに置かれているだろうか。それは意図的な設計判断の結果だろうか、それとも「なんとなくそうなった」のだろうか。

---

### 参考文献

- SAP Community Blog, "A Deeper Look At Sybase: History of ASE", 2011. <https://blogs.sap.com/2011/04/15/a-deeper-look-at-sybase-history-of-ase/>
- Ispirer, "Sybase ASE History". <https://doc.ispirer.com/sqlways/Output/SQLWays-1-178.html>
- Oracle FAQ, "PL/SQL". <https://www.orafaq.com/wiki/PL/SQL>
- O'Reilly, "Oracle PL/SQL Programming: The Origins of PL/SQL". <https://www.oreilly.com/library/view/oracle-pl-sql-programming/9780596805401/ch01s02.html>
- Wikipedia, "History of Microsoft SQL Server". <https://en.wikipedia.org/wiki/History_of_Microsoft_SQL_Server>
- SQLShack, "TSQL History". <https://www.sqlshack.com/tsql-history/>
- Wikipedia, "PL/pgSQL". <https://en.wikipedia.org/wiki/PL/pgSQL>
- Wikipedia, "SQL/PSM". <https://en.wikipedia.org/wiki/SQL/PSM>
- Wikipedia, "MySQL" (MySQL 5.0 stored procedures). <https://en.wikipedia.org/wiki/MySQL>
- Martin Fowler, "Domain Logic and SQL". <https://martinfowler.com/articles/dblogic.html>
- Martin Fowler, 『Patterns of Enterprise Application Architecture』, 2002.
- Dustin Moris Gorski, "Drawbacks of Stored Procedures". <https://dusted.codes/drawbacks-of-stored-procedures>
- Jeff Atwood, "Who Needs Stored Procedures, Anyways?", Coding Horror. <https://blog.codinghorror.com/who-needs-stored-procedures-anyways/>
- Mike Smithers, "What's Special About Oracle? Relational Databases and the Thick Database Paradigm", 2016. <https://mikesmithers.wordpress.com/2016/06/03/whats-special-about-oracle-relational-databases-and-the-thick-database-paradigm/>
- PostgreSQL Documentation, "PL/pgSQL — SQL Procedural Language". <https://www.postgresql.org/docs/current/plpgsql.html>
- EnterpriseDB, "Everything you need to know about Postgres stored procedures and functions". <https://www.enterprisedb.com/postgres-tutorials/everything-you-need-know-about-postgres-stored-procedures-and-functions>

---

**次回予告：** 第10回「インデックス設計——データベースの『速さ』の正体」では、本番環境で突然SQLが遅くなった障害対応の記憶から始め、B+Treeの構造と計算量、複合インデックスの最左一致の法則、インデックスの選択性、そしてEXPLAIN ANALYZEの読み方を詳解する。適切なインデックスを一本追加して、クエリが数秒から数ミリ秒に改善した——その「魔法」の仕組みを解き明かす。
