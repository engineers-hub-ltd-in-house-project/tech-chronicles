# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第4回：CVSの誕生——RCSの限界を超えて

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- RCSの「ファイル単位・一人ずつ」という限界が、次の世代のツールをどう動機づけたか
- Dick Grune（1986年）によるCVSの原型と、その設計思想
- Brian Berliner（1989年）によるC言語での全面書き直しと、実戦投入の経緯
- 「リポジトリ」という概念がバージョン管理にもたらした構造的変革
- Copy-Modify-Mergeモデルの革新性と、ロック方式との設計思想の違い
- CVSサーバを実際に立てて、プロジェクトを管理する体験

---

## 1. cvsrootの向こう側

前回、私はRCSのファイルロック方式について書いた。`co -l` でロックを取得し、`ci` でチェックインし、ロックを解放する。一人でファイルの履歴を管理するには十分だった。だが、チームで複数のファイルを管理しようとした瞬間、その限界が露呈すると。

あの結論は、理屈として書いたものではない。私自身がその限界に直面した記憶がある。

2000年代の初め、あるプロジェクトに配属されたとき、先輩が「CVSを使う」と言った。当時の私はRCSしか知らなかった——というよりRCSすら覚えたばかりで、`ci` と `co` の違いをようやく体に染み込ませた段階だった。

先輩は `CVSROOT` という環境変数を設定し、`cvs checkout` というコマンドを叩いた。するとディレクトリツリーがまるごと手元に降ってきた。一つのファイルではない。プロジェクトの全ファイルが、ディレクトリ構造を保ったまま再現された。

RCSでは、各ファイルを個別に `co` していた。ファイルが10個あれば `co` を10回叩く。50個あれば50回だ。ディレクトリ構造の管理は人間の仕事だった。それがCVSでは、`checkout` 一発でプロジェクト全体が降ってくる。

「これが『リポジトリ』というやつか」と思った。RCSの ,v ファイルが個々の引き出しだとすれば、CVSのリポジトリは引き出しを整理する棚そのものだった。

だが、もっと驚いたのはその後だ。先輩は私に「ロックはしなくていい」と言った。

RCSでは `co -l` でロックを取得しなければ編集できなかった。それがCVSでは、チェックアウトした時点で自由に編集できる。同じファイルを私と先輩が同時に触っていても構わない。変更をコミットするとき、CVSが差分をマージしてくれるのだと。

「ロックしなくて大丈夫なんですか」と聞くと、先輩は「まあ、たまにコンフリクトするけどな」と笑った。

あの瞬間の「ロックしなくていい」という言葉の衝撃を、今でも覚えている。RCSのファイルロックは、前回書いた通り、並行編集の衝突を「禁止」することで解決していた。CVSは、禁止を解いた。代わりに、衝突が起きたときに「解決する」仕組みを用意した。

この設計思想の転換は、バージョン管理の歴史における最も重要な転換点の一つだ。そして「リポジトリ」という概念は、単なる便利機能ではなく、ソフトウェア開発のあり方そのものを変えた。

なぜ「リポジトリ」は必要だったのか。なぜ「ロックの禁止」から「マージによる解決」への転換が起きたのか。それを理解するには、CVSが生まれた経緯を辿る必要がある。

---

## 2. 三人のスケジュール問題——CVS誕生の背景

### RCSの限界が見えた場所

前回の末尾で、SCCS/RCSには二つの根本的な限界があると述べた。第一に、ファイル単位の管理しかできない。第二に、ファイルロックによって並行作業が制限される。

この二つの限界が、どのような現場で最も痛切に感じられたかを考えてほしい。答えは「複数人が、異なるスケジュールで、同じプロジェクトに取り組む場面」だ。

まさにその状況に直面していたのが、オランダのVrije Universiteit Amsterdam（アムステルダム自由大学）の計算機科学者Dick Gruneだった。

1984年7月から1985年8月にかけて、Gruneは学生のErik BaalbergenおよびMaarten Waageとともに、ACK（Amsterdam Compiler Kit）のCコンパイラの開発に取り組んでいた。問題は、三人の作業スケジュールがまったく噛み合わなかったことだ。Baalbergenは定時で作業する学生だった。Waageの作業時間は不規則だった。そしてGrune自身は、他の業務があるため夜間しか作業できなかった。

三人が同じ時間にオフィスにいることは稀だった。「あのファイルのロックを解除してくれ」と声をかける相手がいないのだ。RCSのファイルロック方式は、物理的に同じ場所にいるチームを前提としていた。スケジュールがずれた三人にとって、ロックは共同作業の障壁そのものだった。

### シェルスクリプトの集合体——初期CVS

Gruneの解決策は、RCSの上に薄いラッパー層を構築することだった。RCSの ,v ファイル形式はそのまま利用し、その上に「複数ファイルをまとめて扱う」「ロックなしで並行編集を可能にする」機能を追加する。

初期のCVSは、3つのシェルスクリプトで構成されていた。

**CreateVersion** はリポジトリからプライベートコピーを生成する。後の `cvs checkout` に相当する操作だ。開発者は自分専用の作業ディレクトリを持ち、他の開発者の作業に影響されずに編集できる。

**UpdateVersion** はリポジトリの最新状態を自分の作業コピーに反映する。内部的には `rcsmerge` を使い、他の開発者がコミットした変更を自分のファイルにマージする。後の `cvs update` だ。

**Commit** は自分の変更をリポジトリに登録する。後の `cvs commit` である。

この三つの操作——取得、更新、登録——が、CVSの基本サイクルを形成する。そしてこのサイクルは、現代のgitにおける `clone`/`pull`/`push` にも、概念的には直接対応している。

Gruneの設計で注目すべきは、彼がファイル状態の全組み合わせを網羅する「決定テーブル」を作成したことだ。ローカルファイルとリポジトリファイルの状態の全パターンを列挙し、それぞれに対して何をすべきかを定義した。場当たり的な実装ではなく、網羅的な状態遷移設計に基づいている。

もう一つの重要な設計判断は、「very-long-term transactions」を許容したことだ。リポジトリはチェックアウトされたコピーの存在を追跡しない。開発者がいつチェックアウトしたか、いつコミットするかは完全に開発者に委ねられる。RCSのロック方式では、ロック保持者がいつまでもロックを解除しないことが問題になったが、CVSではそもそもリポジトリ側が作業コピーを管理しない。「好きなときにチェックアウトし、好きなときにコミットせよ」——これは開発者への信頼に基づく設計だ。

Gruneは初期のCVSを「cmt」と名付けていた。commit（コミット）に由来する名前だ。1986年6月23日、GruneはこのスクリプトをUsenetのcomp.sources.unixに公開投稿した。

### Brian Berlinerの書き直し——CVS IIの誕生

Gruneのシェルスクリプトは概念実証としては十分だったが、性能と機能の両面で実用的な限界があった。シェルスクリプトは各コマンドを外部プロセスとして呼び出すため、ファイル数が増えると遅くなる。エラー処理も不十分だった。

1989年4月、Brian Berliner（Prisma, Inc.所属）がCVSをC言語で全面的に書き直した。BerlinerはSunOSカーネルのサードパーティ開発者としてPrisma社に所属しており、大規模なソースコードを管理する実務上の必要性からこの作業に着手した。

Prisma社は1988年12月からCVSを利用していた。Berlinerの書き直し後、14人の開発者が17,000以上のファイルを管理する環境に展開された。これが小規模チームでのCVSの実用性を実証した。

実戦投入の成果は数字に表れている。SunOS 4.0.3カーネルソースのアップグレード配布では、346ファイル中233ファイルが修正されたが、そのうち139ファイルはPrisma社がローカルに変更を加えていなかったためクリーンにマージできた。残り94ファイルはローカル修正との衝突があり手動マージが必要だったが、233ファイルの修正の合計は20,766行の差分に及んだ。ファイルロック方式では、この規模の並行開発は事実上不可能だっただろう。

Jeff PolkがBerlinerとともにモジュール機能とベンダーブランチのサポートを設計・実装した。モジュール機能により、リポジトリの一部だけをチェックアウトできるようになった。ベンダーブランチにより、外部から提供されるソースコード（SunOSカーネルのように）のバージョンと自社の修正バージョンを分離して管理できるようになった。

1990年、BerlinerはUSENIX Conference Proceedingsで "CVS II: Parallelizing Software Development" と題する論文を発表した。タイトルの「CVS II」は、Gruneのオリジナルに対する第二世代を意味する。「Parallelizing」——並列化——という言葉が、この書き直しの本質を示している。

そして1990年11月19日、CVS version 1.0がFree Software Foundation（FSF）に提出され、GNU General Public License（GPL）の下で配布されることになった。これにより、CVSはフリーソフトウェアとしての地位を確立し、世界中の開発者が自由に利用できるようになった。

---

## 3. CVSのアーキテクチャ——「リポジトリ」という革新

### リポジトリとは何か

CVSが導入した最も重要な概念は「リポジトリ」だ。RCSでは、各ファイルに対応する ,v ファイルが管理の単位だった。CVSでは、プロジェクト全体のファイルを格納するディレクトリツリーが管理の単位になる。

CVSのリポジトリは、作業ディレクトリと対応するディレクトリ構造を持つ。プロジェクトの各ファイルは、リポジトリ内でRCS形式の ,v ファイルとして格納される。つまり、CVSはRCSを「内部ストレージエンジン」として利用しているのだ。

```
リポジトリ                        作業ディレクトリ
/cvsroot/myproject/               ~/work/myproject/
  +-- CVSROOT/                      +-- CVS/
  |     +-- modules,v                     +-- Root
  |     +-- loginfo,v                     +-- Repository
  |     +-- commitinfo,v                  +-- Entries
  +-- src/                          +-- src/
  |     +-- main.c,v                      +-- main.c
  |     +-- utils.c,v                     +-- utils.c
  +-- include/                      +-- include/
        +-- utils.h,v                     +-- utils.h
```

この構造を見ると、CVSの設計思想が透けて見える。リポジトリ側にはRCSの ,v ファイルが並ぶ。CVSは新しいファイル形式を発明しなかった。既存のRCSの仕組みをそのまま活用し、その上にディレクトリレベルの管理層を追加した。

作業ディレクトリ側には、各ディレクトリに `CVS/` というメタデータディレクトリが自動生成される。この中の `Root` ファイルにはリポジトリの場所（CVSROOT）が記録され、`Repository` ファイルにはリポジトリ内の対応パスが記録され、`Entries` ファイルには各ファイルのリビジョン番号とタイムスタンプが記録される。gitの `.git/` ディレクトリの原型と言ってよい。

### CVSROOT——リポジトリの管理中枢

リポジトリのルートに置かれる `CVSROOT` ディレクトリは、リポジトリ全体の設定と動作を制御する管理中枢だ。

`modules` ファイルは、リポジトリ内のディレクトリやファイルの集合に名前を付ける。`cvs checkout module-name` でモジュール単位のチェックアウトが可能になる。

`loginfo` ファイルは、コミット時に実行されるスクリプトを定義する。コミットログをメーリングリストに送信する、ビルドを自動起動するといった「フック」を設定できる。これは現代のCI/CDパイプラインの原型と呼べる仕組みだ。gitの `post-commit` フックや、GitHub Actionsの `on: push` トリガーの祖先がここにある。

`commitinfo` ファイルは、コミット前に実行されるバリデーションを定義する。コーディング規約のチェックや、特定のファイルへの変更を制限するゲートキーパーの役割を果たす。gitの `pre-commit` フックに直接対応する。

注目すべきは、これらの設定ファイル自体が ,v ファイルとしてバージョン管理されていることだ。リポジトリの設定の変更履歴も追跡できる。「インフラのコード化」という発想が、すでにここに萌芽として存在していた。

### Copy-Modify-Mergeモデル

CVSの技術的革新の核心は、Copy-Modify-Mergeモデルだ。RCSのLock-Modify-Unlockモデルとの違いを、操作の流れで比較する。

```
Lock-Modify-Unlock（RCS）:

  開発者A:  ロック取得 → 編集 → コミット → ロック解放
  開発者B:  ............ロック待ち............→ ロック取得 → 編集 → ...

  問題: Aが終わるまでBは何もできない


Copy-Modify-Merge（CVS）:

  開発者A:  コピー取得 → 編集 → update → コミット
  開発者B:  コピー取得 → 編集 → update → コミット

  利点: AとBが同時に作業できる
  代償: updateの際にマージが必要になることがある
```

このモデルの前提には、一つの重要な経験則がある。複数の開発者が同じファイルの同じ箇所を同時に変更する確率は、直感に反して低いという事実だ。100行のファイルの5行目を変更する人と、80行目を変更する人が同時にいたとしても、変更箇所が重ならなければ自動的にマージできる。実際の開発において、衝突（コンフリクト）が発生するのは全コミットのうちごく一部に過ぎない。

Prisma社での実績がこの経験則を裏付けた。SunOS 4.0.3カーネルソースのアップグレードでは、233の修正ファイルのうち139ファイル——約60%——がクリーンにマージできた。手動介入が必要だったのは94ファイルだった。ロック方式であれば、233ファイルすべてについて順番待ちが発生していたはずだ。

Copy-Modify-Mergeモデルは、データベースの分野でいう「楽観的並行制御」（optimistic concurrency control）に相当する。「衝突は起きないだろう」と楽観的に仮定して処理を進め、実際に衝突が起きた場合にのみ解決処理を行う。対照的に、ロック方式は「悲観的並行制御」（pessimistic concurrency control）だ。「衝突が起きるかもしれない」と悲観的に仮定して、事前にロックで防止する。

どちらが正しいかは、衝突の頻度と衝突解決のコストに依存する。衝突が頻繁に起き、かつ解決コストが高い場合は悲観的制御が有利だ。衝突がまれで、解決コストが低い場合は楽観的制御が有利だ。ソフトウェア開発の多くの場面では後者の条件が成立するため、CVSの設計判断は正しかった。

### ファイル単位のバージョニング——CVSの遺産と限界

CVSはリポジトリという概念を導入したが、内部的にはRCSの設計を引き継いでいる。各ファイルは独立にバージョニングされ、ファイルごとに 1.1、1.2、1.3... とリビジョン番号が振られる。ブランチでは 1.1.1.1 のように追加の数字が付く。

```
main.c のリビジョン:   1.1 → 1.2 → 1.3 → 1.4
utils.c のリビジョン:  1.1 → 1.2 → 1.3
utils.h のリビジョン:  1.1 → 1.2
```

この設計は、三つのファイルの「1.3」がまったく異なるタイミングのコミットを指すことを意味する。main.c の 1.3 と utils.c の 1.3 は、同じ変更セットの一部かもしれないし、まったく無関係な変更かもしれない。

プロジェクト全体のスナップショットを特定するには、各ファイルのリビジョン番号の組み合わせを記録する必要がある。CVSではこれを「タグ」で実現した。`cvs tag release-1.0` と実行すると、その時点の全ファイルのリビジョン番号に `release-1.0` というラベルが付けられる。

だが根本的な問題は、CVSにはアトミックコミット——複数ファイルの変更を一つの不可分な単位として記録する機能——が存在しなかったことだ。`cvs commit` は各ファイルを順番に処理する。コミットの途中でネットワークが切断されたり、プロセスが中断されたりすると、一部のファイルだけがコミットされ、残りは古いリビジョンのまま取り残される。

この問題は、CVSの最大の弱点として広く認識されることになるが、それは第5回で詳しく扱う。

### クライアント・サーバモデルへの進化

初期のCVSはローカルファイルシステム上のリポジトリのみをサポートしていた。リポジトリと作業ディレクトリが同じマシン上に存在する必要があった。これは物理的に同じ場所にいるチームには十分だったが、地理的に分散したチームには対応できなかった。

1993年、Cygnus SolutionsのJim Kingdonがクライアント・サーバモードを実装した。Kingdonの動機は個人的なものだった。彼はバージニア州のコミューンに住んでおり、シリコンバレーのオフィスに移住する意思がなかった。1993年当時、リモートワークのインフラは未成熟で、CVSをネットワーク越しに使う手段が存在しなかった。Kingdonは自分が必要とするものを、自分で作った。

Jim BlandyとKarl Fogel——後にSubversionプロジェクトの中心人物となる二人——が、Kingdonのパッチの公式採用を推進した。これによりCVSは、TCP/IP接続を介したリモートリポジトリアクセスをサポートするようになった。

クライアント・サーバモードには複数のアクセス方式が用意された。

`:local:` は従来通りのローカルアクセスだ。`:ext:` はSSH（Secure Shell）経由の接続で、SSHの暗号化によって安全な通信が保証される。`:pserver:` は「password server」の略で、CVS独自の認証プロトコルを使用する。ポート番号は2401で、IANAに公式に登録されている。

`:pserver:` の認証は、現代の基準では深刻なセキュリティ上の問題がある。パスワードは「不用意な漏洩を防ぐ」程度の簡易なエンコーディングしか施されず、暗号化されない。ネットワークを盗聴すれば容易にパスワードを取得できる。だが、1990年代にはSSHの普及がまだ進んでおらず、`:pserver:` の手軽さが優先された。

`:pserver:` のもう一つの用途は、匿名の読み取り専用アクセスだ。パスワードなしでリポジトリの内容を取得できる設定が可能で、これはオープンソースプロジェクトにとって重要な機能だった。ソースコードを誰でもダウンロードできる状態を作ることが、OSSプロジェクトの参入障壁を下げた。

```
# CVSリポジトリへの接続例（匿名pserver）
cvs -d :pserver:anonymous@cvs.example.org:/cvsroot login
cvs -d :pserver:anonymous@cvs.example.org:/cvsroot checkout project
```

このクライアント・サーバモデルの追加が、CVSを「同じオフィスのチーム用ツール」から「世界中の開発者をつなぐインフラ」へと変貌させた。そしてその変貌を決定的にしたのが、1999年に登場するSourceForgeだった。

### SourceForge——CVSが作ったエコシステム

1999年11月17日、VA SoftwareがSourceForgeを開設した。SourceForgeは、フリー・オープンソースソフトウェア開発者に無料で一元的な開発プラットフォームを提供した最初のサービスだった。

SourceForgeが提供したツールの中核はCVSリポジトリだった。加えて、バグトラッカー、メーリングリスト、Webホスティングが一体のパッケージとして提供された。現代のGitHubが提供するサービスの原型が、ここにすべて揃っている。

成長は急速だった。2000年末には数千プロジェクト、2001年末には約30,000プロジェクトが登録された。OSSプロジェクトにとって、SourceForge上にリポジトリを持つことが事実上の標準となった。

SourceForgeの成功は、CVSの成功と不可分だった。CVSのクライアント・サーバモデルがなければ、世界中の開発者がリモートで共同作業するプラットフォームは成立しなかった。匿名pserverアクセスがなければ、誰でもソースコードをダウンロードできるオープンな文化は育たなかった。

あなたが今、`git clone` で何気なくリポジトリを取得し、`git push` で変更を送信するとき、そのワークフローの基本構造はCVSとSourceForgeの時代に確立されたものだ。

---

## 4. ハンズオン：CVSサーバを立てて、プロジェクトを管理する

ここからは実際にCVSを動かす。CVSを実務で使うことはもうないだろう。だが、CVSの操作を体験することで、gitの `init`、`clone`、`add`、`commit`、`update`、`diff`、`log` という一連の操作が、CVSの操作体系の直系の子孫であることを実感できる。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y cvs

# Ubuntu / Debian の場合
# sudo apt install cvs

# macOS の場合（Homebrew）
# brew install cvs
```

### 演習1：リポジトリの初期化——「場所」を作る

```bash
WORKDIR="${HOME}/vcs-handson-04"
mkdir -p "${WORKDIR}"
cd "${WORKDIR}"

# CVSリポジトリの作成
export CVSROOT="${WORKDIR}/cvsrepo"
cvs init
```

`cvs init` がリポジトリを初期化する。`CVSROOT` 環境変数で指定したディレクトリに、管理用のディレクトリ構造が生成される。

```bash
# リポジトリの構造を確認
ls -la "${CVSROOT}"
ls -la "${CVSROOT}/CVSROOT"
```

`CVSROOT/` ディレクトリの中に、`modules,v`、`loginfo,v`、`commitinfo,v` といった管理ファイルが ,v 形式で格納されているのが見える。リポジトリの設定自体がバージョン管理されている。

RCSでは `mkdir RCS` で管理ディレクトリを作るだけだった。CVSの `cvs init` は、リポジトリの管理構造をまるごと生成する。この違いが「ファイル単位の管理」と「プロジェクト単位の管理」の差だ。

### 演習2：プロジェクトのインポート——ファイルをリポジトリに登録する

```bash
# プロジェクト用のディレクトリを作成
mkdir -p "${WORKDIR}/myproject/src"
cd "${WORKDIR}/myproject"

# ソースファイルを作成
cat > src/main.c << 'EOF'
#include <stdio.h>
#include "utils.h"

int main(int argc, char *argv[]) {
    const char *name = (argc > 1) ? argv[1] : "World";
    greet(name);
    return 0;
}
EOF

cat > src/utils.h << 'EOF'
#ifndef UTILS_H
#define UTILS_H

void greet(const char *name);

#endif
EOF

cat > src/utils.c << 'EOF'
#include <stdio.h>
#include "utils.h"

void greet(const char *name) {
    printf("Hello, %s!\n", name);
}
EOF

cat > Makefile << 'EOF'
CC = gcc
CFLAGS = -Wall -Wextra
SRC = src/main.c src/utils.c
TARGET = hello

$(TARGET): $(SRC)
    $(CC) $(CFLAGS) -Isrc -o $@ $(SRC)

clean:
    rm -f $(TARGET)
EOF

# プロジェクトをリポジトリにインポート
cvs import -m "Initial import of hello project" myproject vendor start
```

`cvs import` はディレクトリツリーをまるごとリポジトリに登録する。RCSでは各ファイルを個別に `ci` する必要があったが、CVSではプロジェクト全体を一括で登録できる。

`vendor` と `start` はベンダータグとリリースタグだ。CVSは外部から提供されたソースコードと自社の修正を分離管理する「ベンダーブランチ」を最初から設計に組み込んでいた。Prisma社がSunOSカーネルのソースコードを管理していた経緯を思い出してほしい。

### 演習3：チェックアウト——プロジェクトをまるごと取得する

```bash
# 作業用ディレクトリに移動
cd "${WORKDIR}"
rm -rf myproject  # インポート元は不要

# リポジトリからチェックアウト
cvs checkout myproject
cd myproject
```

`cvs checkout` がリポジトリからプロジェクト全体を取得する。ディレクトリ構造が再現され、各ディレクトリに `CVS/` メタデータディレクトリが生成される。

```bash
# ディレクトリ構造の確認
find . -name "CVS" -type d
cat CVS/Root
cat CVS/Repository
cat CVS/Entries
```

`CVS/Root` にはリポジトリの場所が、`CVS/Repository` にはリポジトリ内のパスが、`CVS/Entries` には各ファイルのリビジョン番号が記録されている。gitの `.git/HEAD`、`.git/config`、`.git/index` に概念的に対応する。

### 演習4：編集とコミット——ロックなしの変更サイクル

```bash
# ファイルを自由に編集（ロック不要）
cat > src/utils.c << 'EOF'
#include <stdio.h>
#include <string.h>
#include "utils.h"

void greet(const char *name) {
    printf("Hello, %s!\n", name);
    if (strcmp(name, "World") != 0) {
        printf("Nice to meet you!\n");
    }
}
EOF

# 変更内容を確認
cvs diff src/utils.c

# コミット
cvs commit -m "Add personalized greeting message" src/utils.c
```

ここで重要なのは、編集前に `co -l` のようなロック操作が不要であることだ。ファイルを直接編集し、`cvs diff` で差分を確認し、`cvs commit` で変更を記録する。

`cvs diff` は `rcsdiff` の、`cvs commit` は `ci` の後継だ。だが大きな違いがある。`ci` が一つのファイルを対象とするのに対し、`cvs commit` はディレクトリツリー全体を対象にできる。

### 演習5：updateとマージ——CVSの真骨頂

ここからがCVSの真価を発揮する部分だ。二人の開発者による並行編集をシミュレーションする。

```bash
# 二つ目の作業コピーを作成（別の開発者を想定）
cd "${WORKDIR}"
cvs checkout -d myproject-dev2 myproject
cd myproject-dev2

# 開発者2がutils.hに関数宣言を追加
cat > src/utils.h << 'EOF'
#ifndef UTILS_H
#define UTILS_H

void greet(const char *name);
void farewell(const char *name);

#endif
EOF

# 開発者2がutils.cにfarewell関数を追加
cat > src/utils.c << 'EOF'
#include <stdio.h>
#include <string.h>
#include "utils.h"

void greet(const char *name) {
    printf("Hello, %s!\n", name);
    if (strcmp(name, "World") != 0) {
        printf("Nice to meet you!\n");
    }
}

void farewell(const char *name) {
    printf("Goodbye, %s!\n", name);
}
EOF

# 開発者2がコミット
cvs commit -m "Add farewell function"
```

次に、開発者1の作業コピーに戻り、`cvs update` でリポジトリの最新状態を取得する。

```bash
# 開発者1の作業コピーに戻る
cd "${WORKDIR}/myproject"

# リポジトリの最新状態を取得
cvs update
```

`cvs update` は、リポジトリで他の開発者がコミットした変更を、自分の作業コピーに取り込む。変更箇所が重ならなければ、自動的にマージされる。CVSは各ファイルの更新状態を以下の文字で表示する。

```
U filename   -- リポジトリから更新（Updated）
M filename   -- ローカルで変更済み、マージ成功（Modified/Merged）
C filename   -- 衝突が発生（Conflict）
? filename   -- CVS管理外のファイル
```

RCSのファイルロック方式では、この並行編集は不可能だった。開発者Aがファイルをロックしている間、開発者Bは同じファイルを編集できなかった。CVSは「同じファイルを二人が同時に編集してよい」と宣言し、衝突が起きたときだけ人間の介入を求める。

### 演習6：cvs logで履歴を追跡する

```bash
# ファイルの変更履歴を表示
cvs log src/utils.c
```

`cvs log` は `rlog` の後継だ。各リビジョンの日時、著者、ログメッセージ、変更行数が表示される。

ここで、ファイル単位のリビジョン番号に注目してほしい。`src/utils.c` のリビジョンが 1.3 でも、`src/utils.h` のリビジョンは 1.2 かもしれない。各ファイルが独立にバージョニングされているためだ。gitではコミットハッシュがリポジトリ全体のスナップショットを指すが、CVSのリビジョン番号はファイル単位だ。

```bash
# タグを付けて、プロジェクト全体のスナップショットを記録
cvs tag milestone-1
```

### RCSとCVSとgitの対応表

```
RCS            CVS                  git                    意味
-----------    ------------------   -------------------    ----------------
(なし)         cvs init             git init               リポジトリ作成
ci -i          cvs import           git add + git commit   初期登録
co             cvs checkout         git clone              プロジェクト取得
co -l          (不要)               (不要)                 編集用取得
ci             cvs commit           git commit             変更を記録
rcsdiff        cvs diff             git diff               差分を表示
rlog           cvs log              git log                履歴を表示
(なし)         cvs update           git pull               最新取得+マージ
(なし)         cvs tag              git tag                タグ付け
```

この表は、バージョン管理の基本操作が世代を超えて一貫していることを示している。RCSの `ci`/`co` は CVSの `commit`/`checkout` になり、さらにgitの `commit`/`clone` になった。操作の粒度は「ファイル」から「プロジェクト」へ、そして「スナップショット全体」へと拡大したが、概念の連続性は保たれている。

---

## 5. まとめと次回予告

### この回の要点

第一に、CVSは1986年にDick Grune（Vrije Universiteit Amsterdam）がシェルスクリプトとして開発した。動機は、異なるスケジュールで作業する三人のチームでの共同開発を可能にすることだった。1989年にBrian Berliner（Prisma, Inc.）がC言語で全面的に書き直し、1990年にFSFに提出されてGPLの下で配布された。

第二に、CVSはバージョン管理に「リポジトリ」という概念を導入した。RCSがファイル単位の管理だったのに対し、CVSはプロジェクト全体のディレクトリツリーを一つの管理単位とした。内部的にはRCSの ,v ファイル形式をそのまま利用しつつ、その上にディレクトリレベルの管理機能を構築した。

第三に、CVSはRCSのファイルロック方式（悲観的並行制御）を捨て、Copy-Modify-Mergeモデル（楽観的並行制御）を採用した。複数の開発者が同じファイルを同時に編集でき、衝突は後からマージで解決する。Prisma社でのSunOSカーネル開発での実績が、このモデルの実用性を証明した。

第四に、1993年のクライアント・サーバモード追加と1999年のSourceForge開設により、CVSは「ネットワーク越しの協調開発」を初めて大規模に実現した。あなたが今使う `git clone`/`git push` のワークフローの基本構造は、この時代に確立された。

### 冒頭の問いへの暫定回答

「リポジトリ」という概念は、なぜ必要だったのか。

答えは、ソフトウェア開発が「一人で一つのファイルを管理する作業」ではなく「複数人で複数のファイルを協調して管理する作業」であるからだ。RCSの ,v ファイルは個々のファイルの履歴を管理するには十分だったが、プロジェクト全体の一貫性を保証する仕組みを持っていなかった。リポジトリは、ファイルの集合に構造を与え、チームの協調作業を支える基盤となった。

だが、CVSのリポジトリにも限界がある。ファイル単位のバージョニング、アトミックコミットの不在、ディレクトリのバージョン管理不可——これらの構造的な弱点は、CVSの普及とともに顕在化していく。

### 次回予告

次回は、CVSが栄光の頂点にいた時代の話だ。

SourceForgeを中心としたOSSエコシステムにおいて、CVSはデファクトスタンダードとしての地位を確立した。2000年代前半、CVSを使わずにOSS開発に参加することは事実上不可能だった。

だが、その栄光は同時にCVSの弱点を白日の下にさらすことになった。アトミックコミットの不在、ディレクトリのバージョン管理不可、リネーム非対応、バイナリファイルの扱いの問題——CVSの「致命的弱点」は、使えば使うほど開発者を苦しめた。

**第5回「CVSの栄光と限界——SourceForge時代の記憶」**

CVSは何を成し遂げ、何に失敗したのか。そしてCVSの限界が、次世代のバージョン管理ツールに何を要求したのか。あなたが `git add -A` で何気なくディレクトリごとステージングできることが、どれほどの試行錯誤の果てに実現したものか、考えたことがあるだろうか。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Grune, D., "Concurrent Versions System CVS," Original scripts and documentation. <https://dickgrune.com/Programs/CVS.orig/>
- Berliner, B., "CVS II: Parallelizing Software Development," USENIX Conference Proceedings, pp. 341-352, 1990. <https://docs-archive.freebsd.org/44doc/psd/28.cvs/paper.pdf>
- GNU CVS Manual, Version 1.11.23. <https://www.gnu.org/software/trans-coord/manual/cvs/cvs.html>
- CVS—Concurrent Versions System, nongnu.org. <https://cvs.nongnu.org/>
- Fogel, K., "Producing Open Source Software," O'Reilly Media, 2005.
- Wikipedia, "Concurrent Versions System." <https://en.wikipedia.org/wiki/Concurrent_Versions_System>
- Wikipedia, "SourceForge." <https://en.wikipedia.org/wiki/SourceForge>
