# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第7回：集中型VCSの設計哲学——それは本当に「悪」だったのか？

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 集中型VCSが選ばれた技術的・組織的背景——ネットワーク帯域、ストレージコスト、組織構造
- Lock-Modify-Unlock と Copy-Modify-Merge の二つの並行性制御モデルの設計思想
- CAP定理のアナロジーで理解する集中型と分散型の設計トレードオフ
- パスベースアクセス制御や単一信頼点（Single Source of Truth）という集中型の構造的利点
- 2020年代でも集中型VCSが合理的な領域——ゲーム業界とPerforce
- Conway's Law が示唆するVCS選択と組織構造の相互作用
- CVS/SVNの集中型環境で、アクセス制御と単一信頼点のメリットを体験するハンズオン

---

## 1. 全員が同じフロアにいた頃

2004年頃の話だ。私はある中規模のWeb開発会社で、5人ほどのチームでECサイトのバックエンドを開発していた。

オフィスは都内のビルのワンフロア。開発チーム全員が同じ島に座っていた。サーバルームは隣の部屋にあり、CVSサーバはそこに置かれた古いPCで動いていた。100Mbpsのイーサネットで結ばれた環境だ。

`cvs update` を打つと、数秒で最新のコードが手元に落ちてくる。`cvs commit` を打てば、即座にリポジトリに反映される。声をかけて「今から auth モジュールを触るよ」と言えば、コンフリクトのリスクは大幅に下がった。サーバが落ちることは稀にあったが、隣の部屋に行って再起動すれば済む話だった。

当時の私にとって、この環境に不満はなかった。正確に言えば、不満がなかったのではなく、不満を感じるための比較対象がなかった。「中央サーバがすべてを管理する」という設計は、5人が同じフロアで働く環境にとって、自然な選択だった。

数年後、私は分散型VCSに出会い、集中型VCSの「限界」を知ることになる。だが、限界を知ることと、それが「悪」だったと断じることは違う。

集中型VCSは、分散型に「劣っている」のか。それとも「違う問題を解いている」のか。

今回は、CVS時代の開発現場を離れ、少し抽象度を上げて考えてみたい。集中型VCSの設計哲学そのものを再検証する。

---

## 2. 集中型が「自然」だった時代——技術的制約と組織構造

### ネットワーク帯域とストレージの現実

集中型VCSの設計を評価するには、それが生まれた時代の技術的制約を正確に理解する必要がある。

1990年代後半、インターネット接続の標準は56kbpsのダイアルアップだった。企業内LANこそ10Mbps〜100MbpsのEthernetが普及していたが、拠点間の接続は専用線に依存し、高額だった。2000年代初頭にブロードバンドが登場しても、一般的な速度は256kbps〜1Mbps程度に留まった。

ストレージコストも無視できなかった。1990年頃、ハードディスクは1GBあたり約250ドルだった。中規模のプロジェクトでも、リポジトリの全履歴が数百MBに達することは珍しくない。開発者が10人いれば、リポジトリの複製を10個保持するだけで数GBの追加ストレージが必要になる。

分散型VCSの根幹は、「リポジトリの全履歴をすべての開発者のローカルマシンに複製する」ことにある。2005年にgitが誕生した時点でさえ、Linuxカーネルのリポジトリは巨大だった。1990年代にこのアプローチを取ることは、帯域とストレージの両面から非現実的だった。

集中型VCSの設計は、こうした制約への合理的な回答だった。リポジトリは中央サーバに一つだけ保持する。開発者は作業に必要なファイルの最新版だけをチェックアウトし、変更をコミットする。ネットワークを流れるデータは差分だけ——全履歴をコピーする必要はない。

### 組織構造との整合

技術的制約だけが集中型VCSを支えていたわけではない。組織の構造もまた、集中型のモデルと深く共鳴していた。

1968年、Melvin Conwayは論文"How Do Committees Invent?"の中で、のちに「Conway's Law」と呼ばれる洞察を示した。「システムを設計する組織は、その組織のコミュニケーション構造のコピーを生み出すことを余儀なくされる」。Fred Brooksが『The Mythical Man-Month』でこの法則に言及し、広く知られるようになった。

この法則をVCSの文脈に当てはめてみよう。

2000年代前半のソフトウェア開発組織の多くは、集中型のコミュニケーション構造を持っていた。チームメンバーは同じオフィスに通勤し、プロジェクトマネージャーが進捗を集中管理し、リリース判断は一元的に行われた。この組織構造において、中央サーバにリポジトリを置く集中型VCSは、組織のワークフローと自然に整合した。

マネージャーは中央リポジトリのログを見ればコミット状況を把握できた。リリースエンジニアは中央リポジトリからタグを切ってビルドを作った。すべてのワークフローが「中央」を起点として設計されていた。

分散型VCSの思想——各開発者が対等なリポジトリを持ち、相互にパッチを交換する——は、Linuxカーネルのようなオープンソースプロジェクトの開発スタイルには合致した。だが、2000年代の典型的な企業の開発チームにとっては、組織構造と噛み合わない異質なモデルだった。

### 「中央」が合理的だった具体的な場面

具体的に、集中型VCSが合理的だった場面を挙げてみよう。

第一に、明確な権限管理が必要な場合。機密性の高いコードを扱う企業では、「誰がどのファイルにアクセスできるか」を厳密に制御する必要があった。集中型VCSの中央サーバは、アクセス制御の自然な実施ポイントだった。

第二に、コンプライアンスと監査の要件がある場合。金融機関や医療系システムの開発では、「誰が、いつ、何を変更したか」の追跡可能性が規制上の要件だった。すべての変更が一箇所に記録される集中型VCSは、監査証跡の管理を単純にした。

第三に、大規模なバイナリファイルを扱う場合。ゲーム開発や組み込みソフトウェア開発では、テクスチャ、モデルデータ、ファームウェアバイナリなど、マージ不可能な大容量ファイルが大量に存在する。これらを全開発者のローカルに複製するのは非効率であり、中央サーバでの管理と排他ロックが合理的だった。

これらの場面は、2020年代の今でも消えていない。

---

## 3. 二つの並行性制御モデル——設計思想の比較

### Lock-Modify-Unlock：悲観的な世界観

バージョン管理における並行性制御は、大きく二つのモデルに分けられる。SVN Bookはこれを明確に定義している。

最初のモデルは「Lock-Modify-Unlock」——ロックして、編集して、ロックを解除する。RCSが採用したこのモデルは、ファイルを編集する前にロックを取得し、編集中は他の誰もそのファイルを変更できないようにする。編集が終わったらロックを解除し、他の開発者が編集可能になる。

```
開発者A                         中央サーバ                        開発者B
   |                               |                               |
   |--- ロック要求(main.c) ------->|                               |
   |<-- ロック取得 ----------------|                               |
   |                               |                               |
   |   main.c を編集中             |    ロック要求(main.c) -------->|
   |                               |<-- 拒否：ロック中 ------------|
   |                               |                               |
   |--- コミット ----------------->|                               |
   |<-- ロック解除 ----------------|                               |
   |                               |                               |
   |                               |    ロック要求(main.c) -------->|
   |                               |<-- ロック取得 ----------------|
```

このモデルの利点は明快だ。コンフリクトが原理的に発生しない。あるファイルを同時に二人が編集することがないのだから、マージの必要もない。正しさの保証が構造的に組み込まれている。

だが、SVN Bookが指摘するように、このモデルには深刻な問題がある。

開発者Aがファイルをロックしたまま昼食に出かける。あるいは休暇に入る。他の開発者はそのファイルに触れない。管理者がロックを強制解除するまで、そのファイルの開発は止まる。「ロックの忘れ解除」は、このモデルにおける日常的な運用問題だった。

さらに根本的な問題がある。ファイルAとファイルBが論理的に依存している場合、開発者AがファイルAをロックし、開発者BがファイルBをロックすると、お互いの作業が中途半端な状態で行われ、結果として整合性のないコードがリポジトリに入る可能性がある。ファイル単位のロックは、プロジェクト全体の論理的一貫性を保証しない。

### Copy-Modify-Merge：楽観的な世界観

CVSが革新的だったのは、二つ目のモデル「Copy-Modify-Merge」を主流にしたことだ。

各開発者がリポジトリからファイルのコピー（作業コピー）を取得し、並行して作業し、最後にマージする。衝突が起きたら、その時点で解消する。

```
開発者A                         中央サーバ                        開発者B
   |                               |                               |
   |--- checkout ----------------->|<-- checkout ------------------|
   |<-- main.c (rev 1.3) ---------|--- main.c (rev 1.3) --------->|
   |                               |                               |
   |   main.c を編集中             |          main.c を編集中      |
   |                               |                               |
   |--- commit (rev 1.4) -------->|                               |
   |<-- 成功 ----------------------|                               |
   |                               |                               |
   |                               |<-- commit --------------------|
   |                               |--- 拒否：最新版ではない ----->|
   |                               |                               |
   |                               |<-- update --------------------|
   |                               |--- マージ or コンフリクト --->|
   |                               |                               |
   |                               |<-- commit (rev 1.5) ----------|
   |                               |--- 成功 --------------------->|
```

SVN Bookは、このモデルの利点を「実際には驚くほどうまく機能する」と述べている。複数の開発者が同時に同じファイルを編集しても、変更箇所が重ならなければ自動的にマージされる。衝突が発生する頻度は、多くのプロジェクトにおいて想像よりも低い。そして衝突の解消に要する時間は、ロック方式で他の開発者が待たされる時間よりもはるかに短い。

このモデルは「楽観的並行性制御」とも呼ばれる。衝突は「たまに起きる例外」であり、ほとんどの場合は並行作業が問題なく統合できるという楽観的な前提に立っている。対してLock-Modify-Unlockは「悲観的並行性制御」——衝突は「必ず起きる脅威」であり、構造的に防止すべきだという前提に立つ。

### 両方の必要性

現実のソフトウェア開発では、両方のモデルが必要な場面がある。

テキストベースのソースコードに対しては、Copy-Modify-Mergeが圧倒的に効率的だ。変更箇所が重ならない限り、並行作業は自動的に統合される。

だが、バイナリファイル——画像、3Dモデル、コンパイル済みライブラリ——に対しては、マージという概念自体が成立しない。二つのPhotoshopファイルの「差分をマージする」ことはできない。こうしたファイルに対しては、Lock-Modify-Unlock方式が合理的だ。

Subversionはこの現実を理解していた。Subversionの基本モデルはCopy-Modify-Mergeだが、特定のファイルに対してロック機構（`svn lock`）を設定できる。`svn:needs-lock` プロパティを設定したファイルは、読み取り専用としてチェックアウトされ、編集する前にロックの取得を強制される。テキストファイルには楽観的制御、バイナリファイルには悲観的制御——この使い分けができることは、集中型VCSの設計上の柔軟性だった。

gitには、ネイティブなファイルロック機構がない。Git LFSがロック機能を後から追加したが、本体の設計思想にはないものだ。これは設計上の欠陥ではなく、gitが解こうとした問題が「大量のテキストファイルの並行開発」であり、バイナリファイルの排他制御は射程外だったことを意味する。

---

## 4. CAP定理のアナロジー——集中型が選んだトレードオフ

### 一貫性か、可用性か

2000年、カリフォルニア大学バークレー校のEric Brewerが、分散コンピューティングに関する根本的な制約を提唱した。CAP定理（のちに2002年、MITのSeth GilbertとNancy Lynchが形式的に証明）は、分散システムにおいて以下の三つの性質を同時に満たすことはできないと述べる。

- **Consistency（一貫性）**: すべてのノードが同じデータを見る
- **Availability（可用性）**: すべてのリクエストに応答が返る
- **Partition tolerance（分断耐性）**: ネットワークの分断が発生してもシステムが動作し続ける

CAP定理は厳密にはデータベースや分散システムに対する定理であり、VCSに直接適用されるものではない。だが、集中型VCSと分散型VCSの設計思想の違いを理解するためのアナロジーとしては、示唆に富んでいる。

### 集中型VCSのトレードオフ

集中型VCSは、**一貫性（C）** を最優先に設計されている。

中央サーバが「正しい状態」を一元的に保持する。すべての開発者は、中央サーバのリポジトリを唯一の信頼できる情報源として参照する。「最新のコードはどれか」「リビジョン234の内容は何か」という問いに対して、集中型VCSは常に一意の答えを持つ。

この一貫性の代償は、**分断耐性（P）** の放棄だ。中央サーバとの接続が切れたら、コミットもログの参照もできない。オフィスのネットワークが落ちれば、チーム全体の開発が停止する。出張先のホテルからVPN接続が不安定なら、コードの変更履歴すら確認できない。

だが、ここで考えてほしい。1990年代後半から2000年代前半の典型的な開発チームにとって、「ネットワークの分断」はどの程度の頻度で起きる問題だったか。

全員が同じオフィスにいて、同じLANに接続している。サーバは隣の部屋にある。ネットワークの分断は「年に数回のサーバ障害」であり、日常的な問題ではなかった。飛行機の中でコードを書く必要がある開発者は少数派だった。

つまり、集中型VCSが分断耐性を犠牲にしたことは、当時の環境においては合理的なトレードオフだった。ほとんど発生しない問題のために、一貫性という強い保証を手放す理由はなかった。

### 分散型VCSのトレードオフ

分散型VCSは、**可用性（A）** と**分断耐性（P）** を選んだと見ることができる。

各開発者がリポジトリの完全なコピーをローカルに持つ。ネットワークが切れても、ローカルでコミット、ブランチ作成、ログの参照が可能だ。可用性と分断耐性は確保されている。

代償は、**一貫性（C）** の弱体化だ。各開発者のローカルリポジトリは、互いに異なる状態を持ちうる。「最新のコードはどれか」という問いに対して、分散型VCSは構造的に一意の答えを持たない。mainブランチのHEADが「正」であるのは、チームの「約束事」であって、システムが強制するものではない。

gitの世界では「blessed repository」（祝福されたリポジトリ）というパターンで擬似的な中央を設けることが一般的だ。GitHub上のoriginリポジトリがその役割を果たす。だが、これはgitの設計が強制するものではなく、運用上の規約に過ぎない。技術的には、どの開発者のローカルリポジトリも対等だ。

```
集中型VCS:
                          +------------------+
                          |   中央サーバ     |
                          | （唯一の正）     |
                          +--------+---------+
                          /        |         \
                    +----+    +----+    +----+
                    | WC |    | WC |    | WC |
                    +----+    +----+    +----+
                    作業コピー（履歴なし）

分散型VCS:
     +--------+      +--------+      +--------+
     | Repo A |<---->| Repo B |<---->| Repo C |
     | (完全) |      | (完全) |      | (完全) |
     +--------+      +--------+      +--------+
         ↑
       「blessed」は約束事に過ぎない
```

### アナロジーの限界

ここで注意すべきは、このアナロジーには限界があるということだ。CAP定理は分散データストアにおけるリアルタイムの読み書きに関する定理であり、VCSのような非同期的なバッチ処理的操作に厳密に適用されるものではない。

だが、「一貫性を優先するか、可用性を優先するか」という設計判断の構造は、VCSの設計思想を理解する上で有用なフレームワークだ。集中型VCSは一貫性を選び、分散型VCSは可用性を選んだ。どちらが「正しい」かは、利用環境と要件に依存する。

---

## 5. 集中型VCSの構造的利点——今なお有効な設計

### パスベースアクセス制御

集中型VCSの構造的な利点の中で、分散型VCSが今なお完全には再現できていないものがある。パスベースのアクセス制御だ。

Subversionでは、リポジトリ内の特定のパスに対して、ユーザーごとに `r`（読み取り専用）または `rw`（読み書き可能）のアクセス権を設定できる。設定はauthzファイルに記述する。

```ini
# Subversion authz 設定例
[groups]
dev-team = alice, bob, carol
qa-team = dave, eve

[/]
* = r

[/trunk/src]
@dev-team = rw

[/trunk/config/production]
@dev-team = r
admin = rw

[/trunk/test]
@qa-team = rw
@dev-team = r

[/branches/secret-project]
alice = rw
bob = rw
* =
```

この設定では、開発チームはソースコードを読み書きできるが、本番設定ファイルは読むことしかできない。QAチームはテストディレクトリを読み書きできるが、ソースコードの変更はできない。秘密プロジェクトのブランチは、AliceとBob以外にはアクセスすらできない。

gitには、このようなパスベースのネイティブなアクセス制御が存在しない。gitのリポジトリは「全か無か」——クローンすれば全履歴が手に入る。GitLabのProtected Branchesやgitoliteなどの外部ツールで部分的に制御できるが、ディレクトリ単位で「このファイルは特定のユーザーには見えない」という制御はgitの設計思想と根本的に相容れない。

なぜか。gitはリポジトリの完全性を暗号学的ハッシュで保証する。コミットオブジェクトのハッシュは、そのコミットに含まれるすべてのファイルの内容から計算される。特定のファイルを除外してリポジトリを複製すると、ハッシュの整合性が崩れる。一貫性を犠牲にしたくなければ、リポジトリは丸ごと複製するしかない。

集中型VCSでは、中央サーバがアクセスのゲートキーパーとして機能するため、パスベースの制御が構造的に可能だ。これは設計思想の優劣ではなく、アーキテクチャの違いから生まれる特性だ。

### 単一信頼点の価値

「Single Source of Truth（唯一の信頼できる情報源）」という概念は、集中型VCSの最大の構造的利点の一つだ。

企業のソフトウェア開発では、「正しいバージョンはどれか」が曖昧になることは許されない場面がある。監査対応、コンプライアンス、リリース管理——これらの業務において、「リビジョン12345が公式のリリース候補だ」と中央リポジトリが一意に定義できることの価値は大きい。

Subversionの連番リビジョン番号は、この文脈で特に力を発揮した。`svn log -r 12345` で正確にその時点のリポジトリ状態を参照できる。「リビジョン12345」という言葉は、チーム全員にとって同じ意味を持つ。gitのコミットハッシュ `a3f2e1b` よりも、人間が扱いやすい識別子だった。

分散型VCSでは、GitHubやGitLabのリモートリポジトリが「事実上の中央」として機能する。だが、これは技術的に強制されたものではなく、チームの合意による規約だ。開発者がローカルで `git commit --amend` や `git rebase` を行えば、同じコミットが異なる内容を持つことになる。強制プッシュが実行されれば、リモートの履歴すら書き換えられる。

集中型VCSには、こうした「履歴の書き換え」という概念自体がない。中央リポジトリにコミットされたものは、それが「事実」だ。この不変性は、制約であると同時に、信頼性の源泉でもあった。

### Perforce——2020年代でも集中型が選ばれる理由

2020年代の今でも、集中型VCSが合理的に選ばれている領域がある。ゲーム業界はその代表だ。

Perforce（Helix Core）は、AAA級ゲーム開発における事実上の業界標準として機能している。その理由は明確だ。

ゲーム開発のリポジトリは、テクスチャ、3Dモデル、音声データ、動画といった巨大なバイナリアセットで構成される。リポジトリサイズが数百GBに達することは珍しくない。この規模のリポジトリの全履歴をすべての開発者のローカルマシンに複製する——gitのデフォルトの動作——は、現実的ではない。

Perforceでは、開発者は必要なファイルだけをサーバから同期する。バイナリファイルには排他ロックが適用され、アーティストAが編集中のテクスチャを、アーティストBが同時に編集してしまう事故を防ぐ。パスベースのアクセス制御で、プログラマはアートアセットの特定ディレクトリにアクセスできないようにし、逆にアーティストはエンジンのソースコードに触れないようにすることもできる。

gitはGit LFSやsparse checkout、partial cloneといった機能で大規模リポジトリへの対応を試みている。だが、これらはgitの設計思想に後から接ぎ木された機能であり、Perforceのようにアーキテクチャの根幹から大規模バイナリ管理を考慮した設計とは異なる。

集中型VCSは「死んだ」のではない。テキストベースのソースコードの協調開発という領域ではgitが圧倒的に優れているが、バイナリアセットの管理、厳密なアクセス制御、監査証跡の一元管理といった領域では、集中型の設計思想が今なお合理的な選択肢であり続けている。

---

## 6. ハンズオン：集中型VCSのメリットをシミュレーションする

ここまでの議論を、実際に手を動かして確認してみよう。CVSとSubversionを使って、集中型VCSの構造的なメリット——アクセス制御と単一信頼点——を体験する。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y cvs subversion
```

### 演習1：CVSにおける中央リポジトリの「唯一性」

集中型VCSの基本的な性質——中央リポジトリが唯一の正である——ことを確認する。

```bash
WORKDIR="${HOME}/vcs-handson-07"
mkdir -p "${WORKDIR}"
cd "${WORKDIR}"

# CVSリポジトリの初期化
export CVSROOT="${WORKDIR}/cvsrepo"
cvs init

# プロジェクトの作成とインポート
mkdir -p "${WORKDIR}/project-import/src"
cd "${WORKDIR}/project-import"

cat > src/app.c << 'SRCEOF'
#include <stdio.h>

int main(void) {
    printf("Centralized VCS Demo\n");
    return 0;
}
SRCEOF

cat > src/config.h << 'SRCEOF'
#ifndef CONFIG_H
#define CONFIG_H
#define APP_VERSION "1.0"
#define APP_NAME "CVS Demo"
#endif
SRCEOF

cvs import -m "Initial import" myproject vendor start
cd "${WORKDIR}"
rm -rf project-import

# 二人の開発者をシミュレート（二つの作業コピー）
cvs checkout -d workspace-alice myproject
cvs checkout -d workspace-bob myproject

echo ""
echo "=== 中央リポジトリが唯一の正 ==="
echo "同じリポジトリから二つの作業コピーを作成しました"
echo "alice: ${WORKDIR}/workspace-alice"
echo "bob:   ${WORKDIR}/workspace-bob"
echo "両方とも同じ中央リポジトリ（${CVSROOT}）を参照しています"
```

### 演習2：コミットの即時反映——一貫性の体験

```bash
echo ""
echo "=== 演習2: コミットの即時反映 ==="

# Aliceがファイルを変更してコミット
cd "${WORKDIR}/workspace-alice"
sed -i 's/1.0/1.1/' src/config.h
cvs commit -m "Alice: Bump version to 1.1" 2>&1

echo ""
echo "--- Aliceのコミット後のリポジトリ状態 ---"
cvs log src/config.h 2>&1 | head -20

# Bobがupdateすると、Aliceの変更が即座に反映される
cd "${WORKDIR}/workspace-bob"
echo ""
echo "--- Bobがupdate前のconfig.h ---"
cat src/config.h

cvs update 2>&1
echo ""
echo "--- Bobがupdate後のconfig.h ---"
cat src/config.h

echo ""
echo "-> Aliceのコミットは中央リポジトリに即座に反映され、"
echo "   Bobがupdateすることで最新版を取得できます"
echo "-> 「正しいバージョンはどれか」に曖昧さがありません"
```

### 演習3：Subversionのパスベースアクセス制御

```bash
echo ""
echo "=== 演習3: Subversionのパスベースアクセス制御 ==="

cd "${WORKDIR}"

# SVNリポジトリの作成
svnadmin create "${WORKDIR}/svnrepo"

# authzファイルの作成
cat > "${WORKDIR}/svnrepo/conf/authz" << 'AUTHZEOF'
[groups]
developers = alice, bob
managers = carol

[/]
* = r

[/trunk/src]
@developers = rw

[/trunk/config/production]
@developers = r
@managers = rw

[/trunk/docs/internal]
@managers = rw
* =
AUTHZEOF

# svnserve.confの設定
cat > "${WORKDIR}/svnrepo/conf/svnserve.conf" << 'CONFEOF'
[general]
anon-access = none
auth-access = write
authz-db = authz
password-db = passwd
CONFEOF

# パスワードファイルの作成
cat > "${WORKDIR}/svnrepo/conf/passwd" << 'PASSWDEOF'
[users]
alice = alice_pass
bob = bob_pass
carol = carol_pass
PASSWDEOF

echo "--- authzファイルの内容 ---"
cat "${WORKDIR}/svnrepo/conf/authz"

echo ""
echo "=== アクセス制御の設定 ==="
echo ""
echo "  [/trunk/src]          developers = rw  (開発者は読み書き可能)"
echo "  [/trunk/config/production] developers = r  (開発者は読み取りのみ)"
echo "                        managers = rw     (管理者は読み書き可能)"
echo "  [/trunk/docs/internal] managers = rw    (管理者のみアクセス可能)"
echo "                        * =              (その他は一切アクセス不可)"
echo ""
echo "-> ディレクトリごとに、誰が何をできるかを厳密に制御できます"
echo "-> Gitにはこのようなパスベースのネイティブなアクセス制御がありません"
echo "-> Gitのリポジトリは「全か無か」——クローンすれば全履歴が手に入ります"
```

### 演習4：集中型の弱点——サーバ停止の影響

```bash
echo ""
echo "=== 演習4: 集中型の弱点——サーバが利用不可な場合 ==="

cd "${WORKDIR}/workspace-alice"

# ファイルを変更する（ローカルでの変更は可能）
echo "// Local change" >> src/app.c
echo ""
echo "--- ファイルのローカル変更は可能 ---"
echo "ローカルでファイルを編集すること自体は、サーバなしでもできます"
echo ""

# しかし、CVSROOTを無効にするとコミットできない
ORIGINAL_CVSROOT="${CVSROOT}"
export CVSROOT="${WORKDIR}/nonexistent-repo"

echo "--- サーバが利用不可な場合のコミット試行 ---"
cvs commit -m "Offline commit attempt" 2>&1 || true

echo ""
echo "--- サーバが利用不可な場合のログ参照試行 ---"
cvs log src/app.c 2>&1 | head -5 || true

# CVSROOTを元に戻す
export CVSROOT="${ORIGINAL_CVSROOT}"

echo ""
echo "-> 中央サーバが利用不可になると、コミットもログ参照もできません"
echo "-> これが集中型VCSの根本的な制約です"
echo "-> 分散型VCS（Git）では、ローカルリポジトリにコミットでき、"
echo "   過去の履歴もすべて参照できます"
echo ""
echo "-> ただし、全員が同じオフィスにいた時代、この制約は"
echo "   年に数回のサーバ障害時にしか顕在化しませんでした"
```

### 演習5：集中型と分散型の設計選択を比較する

```bash
echo ""
echo "=== 演習5: 設計選択の比較まとめ ==="
echo ""
echo "+------------------+-------------------+-------------------+"
echo "| 観点             | 集中型VCS         | 分散型VCS         |"
echo "+------------------+-------------------+-------------------+"
echo "| 一貫性           | 強い（構造的保証）| 弱い（規約に依存）|"
echo "| 可用性           | サーバ依存        | 高い（ローカル）  |"
echo "| 分断耐性         | なし              | あり              |"
echo "| アクセス制御     | パスベース（細粒度）| リポジトリ単位   |"
echo "| バイナリ管理     | 効率的            | 非効率（LFS必要） |"
echo "| 監査証跡         | 一元管理          | 分散（集約必要）  |"
echo "| オフライン作業   | 不可              | 完全に可能        |"
echo "| ブランチコスト   | 高い（CVS）       | ほぼゼロ          |"
echo "+------------------+-------------------+-------------------+"
echo ""
echo "どちらが「正しい」かは、利用環境と要件に依存します。"
echo "2000年代の企業開発チームにとって、集中型は合理的な選択でした。"
echo "2020年代のOSS/分散チームにとって、分散型が合理的です。"
echo "ゲーム開発のように、今なお集中型が最適な領域も存在します。"
```

### 演習で見えたこと

五つの演習を通じて、集中型VCSの設計思想を体験した。

中央リポジトリが唯一の信頼できる情報源であること。パスベースのアクセス制御で、誰がどのファイルにアクセスできるかを厳密に制御できること。その代償として、サーバが利用不可になればすべてが止まること。

これらは集中型VCSの「仕様」であって「バグ」ではない。一貫性と制御を優先する設計判断の帰結だ。その設計判断が適切だったかどうかは、利用環境に依存する。

---

## 7. まとめと次回予告

### この回の要点

第一に、集中型VCSの設計は、1990年代〜2000年代の技術的制約——限られたネットワーク帯域とストレージコスト——への合理的な回答だった。リポジトリの全履歴をすべての開発者のローカルマシンに複製するという分散型のアプローチは、この時代には現実的ではなかった。

第二に、組織構造がツール選択に影響する。Conway's Lawが示唆するように、全員が同じオフィスにいて集中的なコミュニケーション構造を持つ組織にとって、集中型VCSは自然な選択だった。分散型VCSの思想は、Linuxカーネルのような地理的に分散した開発コミュニティから生まれたものであり、2000年代の典型的な企業チームの構造とは噛み合わなかった。

第三に、バージョン管理における並行性制御には、Lock-Modify-Unlock（悲観的制御）とCopy-Modify-Merge（楽観的制御）の二つのモデルがある。CVSがCopy-Modify-Mergeを主流にした一方で、バイナリファイルの管理にはLock-Modify-Unlockが今なお合理的だ。Subversionは両方のモデルをサポートする設計上の柔軟性を持っていた。

第四に、集中型VCSにはパスベースのアクセス制御、単一信頼点（Single Source of Truth）、一元的な監査証跡といった構造的な利点がある。これらの特性は、コンプライアンスや監査要件の厳しい企業環境で今なお価値を持つ。gitには、パスベースのアクセス制御に相当するネイティブ機能がない。

第五に、ゲーム業界でPerforceが標準的に使われているように、集中型VCSが合理的な領域は2020年代にも存在する。大規模バイナリアセットの管理、排他ロック、パスベースのアクセス制御が必要な場面では、集中型の設計思想が依然として最適解となりうる。

### 冒頭の問いへの暫定回答

集中型VCSは、分散型に「劣っている」のか。それとも「違う問題を解いている」のか。

答えは明確だ。集中型VCSは「時代の最適解」だった。そして、その最適解が有効な領域は、2020年代の今も消えていない。

集中型VCSの設計は、一貫性と制御を優先するトレードオフの上に成り立っている。可用性と分断耐性を犠牲にする代わりに、「正しいバージョンはどれか」「誰がどのファイルにアクセスできるか」という問いに対して、構造的に明確な答えを持つ。

分散型VCSは、このトレードオフを逆転させた。可用性と分断耐性を優先する代わりに、一貫性を規約に委ねた。その結果、オフライン作業、高速なブランチ操作、地理的に分散した開発チームの協調作業を実現した。

どちらが「正しい」かは、状況次第だ。だが、一つだけ確かなことがある。gitが「正しい」と無条件に信じている人間は、集中型VCSが「正しかった」時代を知らない——あるいは、知っていても忘れている。

技術の評価は、常に文脈の中で行われるべきだ。その技術が生まれた時代の制約を無視して、現在の基準だけで判断するのは、歴史に対する不公正だ。

### 次回予告

次回から、連載は新たな章に入る。第3章「Subversion——CVSを正しく作り直す試み」の幕開けだ。

CVSの限界が明らかになった2000年代初頭、「CVSを正しく作り直す」という明確な目標を掲げたプロジェクトが始動した。CollabNetのKarl FogelとBen Collins-Sussmanが率いたSubversion（SVN）は、CVSの上位互換を目指し、アトミックコミット、ディレクトリのバージョン管理、リネーム対応、そして連番リビジョン番号という設計を採用した。

**第8回「Subversionの誕生——"CVS done right"」**

CVSの何を「正しくやり直そう」としたのか。その試みは、どこまで成功し、どこで限界に突き当たったのか。Subversionの設計思想を、CVSとの比較の中で解き明かす。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Brewer, E., "Towards Robust Distributed Systems," Keynote at PODC 2000. <https://en.wikipedia.org/wiki/CAP_theorem>
- Gilbert, S. & Lynch, N., "Perspectives on the CAP Theorem," MIT, 2002. <https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf>
- Conway, M.E., "How Do Committees Invent?," Datamation, April 1968. <https://www.melconway.com/Home/pdf/committees.pdf>
- SVN Book, "Versioning Models." <https://svnbook.red-bean.com/en/1.0/ch02s02.html>
- SVN Book, "Locking." <https://svnbook.red-bean.com/en/1.8/svn.advanced.locking.html>
- SVN Book, "Path-Based Authorization." <https://svnbook.red-bean.com/en/1.7/svn.serverconfig.pathbasedauthz.html>
- Perforce Software, "Version Control for Binary Files." <https://www.perforce.com/blog/vcs/version-control-for-binary-files>
- Perforce Software, "Git vs. Perforce P4: How to Choose." <https://www.perforce.com/blog/vcs/git-vs-perforce-how-choose-and-when-use-both>
- RhodeCode Blog, "Why enterprises still use Subversion source control in 2026?" <https://rhodecode.com/blog/162/why-enterprises-still-use-subversion-source-control-in-2026>
- mkomo.com, "A History of Storage Cost (update)." <https://mkomo.com/cost-per-gigabyte>
- Backblaze Blog, "The Cost Per Gigabyte of Hard Drives Over Time." <https://www.backblaze.com/blog/hard-drive-cost-per-gigabyte/>
- Kyle Cordes, "Linus Torvalds explains distributed source control." <https://kylecordes.com/2007/linux-git-distributed>
- Two-Bit History, "Version Control Before Git with CVS." <https://twobithistory.org/2018/07/07/cvs.html>
