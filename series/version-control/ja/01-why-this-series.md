# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第1回：なぜこの連載を書くのか——git ありきの世界への違和感

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 「バージョン管理＝git」という等式がなぜ危険なのか
- gitが支配的地位を獲得するまでの歴史的経緯
- バージョン管理の三つの本質——変更の記録、協調の仕組み、歴史の保存
- cp, diff, patchだけで「バージョン管理もどき」を体験する方法

---

## 1. ある断絶の風景

ある日、私は実務経験3年ほどの若いエンジニアと話していた。彼は優秀だった。Reactでフロントエンドを書き、Terraformでインフラを構築し、GitHub Actionsでデプロイパイプラインを組む。モダンな開発者としての能力に不足はない。

話の流れで、私はこう聞いた。「gitの前って、何を使ってバージョン管理してたか知ってる？」

彼は少し考えてから、こう答えた。「Subversion……ですか？　名前は聞いたことあります」

間違ってはいない。だが、その答え方が気になった。彼の目には、歴史の授業で「鎌倉幕府」を聞かれたときのような、自分とは無関係な過去の出来事を答える色があった。

私はその場では何も言わなかった。だが、帰り道でずっと考えていた。

彼にとって、gitは空気だ。呼吸するように `git init` し、`git commit` し、`git push` する。それ自体はまったく正しい。正しいのだが——空気の成分を知らずに呼吸している人間は、空気が薄くなったとき、何が起きているのか理解できない。

高山で息苦しくなったとき、「酸素分圧が低い」と理解できるか。それとも、ただ「苦しい」と感じるだけか。この差は、平地にいるかぎり見えない。だが、いつか必ず高山に登るときが来る。

gitが「空気」になった世界で、私たちは何を失ったのか。あるいは、何を「最初から持たなかった」のか。

この連載は、その問いから始まる。

あなたはgitを「選んで」使っているだろうか。それとも、他に選択肢がなかったから使っているだろうか。

---

## 2. 数字が語る「git一強」の現実

まず事実を確認しよう。2020年代半ばの現在、ソフトウェア開発におけるgitの支配的地位はどの程度のものなのか。

### 圧倒的な数字

GitHubが2025年10月に公開したOctoverse 2025レポートによれば、GitHubの登録開発者数は1億8,000万人を超えた。10億以上のプロジェクトが存在し、過去1年だけで3,600万人以上が新規に参加している。毎秒1人以上が新たにGitHubアカウントを作っている計算だ。

もちろん、GitHubはgitのホスティングサービスの一つに過ぎない。GitLabもBitbucketもある。だが、GitHubの規模だけでこの数字である。

バージョン管理ツール全体におけるgitのシェアはどうか。Stack Overflow Developer Survey 2022——バージョン管理ツールに関する設問が設けられた最新の調査——では、gitの使用率は**93.87%** だった。プロフェッショナル開発者に限れば96.65%に上る。2位のSubversion（SVN）は5.18%、3位のMercurialは1.13%。バージョン管理ツールを一切使っていないと答えた開発者は全体の4.3%で、学習者に限ると17%だった。

この数字を、素直に受け取ってほしい。gitの使用率は94%。SVNは5%。Mercurialは1%。

これは「主流」とか「デファクトスタンダード」という表現ではもはや足りない。gitはバージョン管理の**同義語**になった。「バージョン管理を使っていますか？」と聞くことと「gitを使っていますか？」と聞くことが、事実上、同じ質問になってしまった。

### 「前提」になったgit

gitが単なる「よく使われるツール」を超えて、開発エコシステムの「前提条件」になっている点にも注目する必要がある。

JetBrainsが2025年10月に公開したState of CI/CD調査によれば、個人プロジェクトでのCI/CDツール1位はGitHub Actionsで、利用率62%。組織でも41%でトップだ。GitHub Actions、GitLab CI/CD、Jenkins、CircleCI、Azure DevOps Pipelines——主要なCI/CDツールをすべて列挙しても、そのいずれもがgitリポジトリへのプッシュやプルリクエストをトリガーとする設計になっている。

2017年にWeaveworksのAlexis Richardsonが「GitOps」という概念を提唱して以降、この傾向は加速した。Infrastructure as Codeの実践では、Terraform定義もCloudFormationテンプレートもCDKコードも、すべてgitリポジトリに格納され、git operationsを通じてインフラのライフサイクルが管理される。私自身、日常的にAWS CDKやStep Functionsの定義をgitで管理しているが、もはやgitなしには成り立たないワークフローになっている。

gitは「開発ツール」から「インフラの基盤」へと昇格した。かつてOSがソフトウェアの前提条件だったように、gitが開発プロセスの前提条件になった。

### 「選択」から「前提」への転換点

この転換が起きた瞬間を、私は比較的正確に指摘できる。2008年だ。

2008年4月、GitHubが正式にローンチした。Tom Preston-Werner、Chris Wanstrath、P.J. Hyett、Scott Chaconの4人が立ち上げたこのサービスは、gitに「ソーシャル」の要素を加えた。Fork、Pull Request、Issues——これらの仕組みが、OSSへの参加障壁を劇的に下げた。

GitHubの登場以前、OSSプロジェクトに貢献するには、メーリングリストに参加し、パッチを `git format-patch` で作成し、`git send-email` で送信するか、プロジェクト固有のパッチ投稿システムを使う必要があった。Linuxカーネル開発は2025年の今でもこの方式を維持しているが、大半のプロジェクトはGitHubのPull Requestモデルに移行した。

2018年6月、MicrosoftがGitHubを75億ドルで買収した。当時のGitHubユーザー数は約2,800万人だった。企業のバックアップを得たGitHubは加速度的に成長し、2023年1月にユーザー1億人を突破、2025年には1億8,000万人に到達した。

この過程で、何が起きたか。「gitを使うかどうか」という選択が、「gitを前提として何を選ぶか」という問いに置き換わった。チーム開発を始めるとき、「どのバージョン管理ツールを使うか」を議論するチームは、もはやほとんど存在しない。議論は「GitHub、GitLab、Bitbucketのどれを使うか」から始まる。gitは議論の対象ではなく、議論の前提になった。

### 「git以前」を知る世代の消失

2026年現在、実務経験10年以下のエンジニア——つまり2016年以降にキャリアを始めた世代——の圧倒的多数は、gitしか知らない。CVSを実際に使ったことがある人は稀だし、Subversionでさえ「名前は聞いたことがある」程度だろう。

これは自然な世代交代だ。COBOL世代がアセンブラ時代を知らないように、技術の世代交代は必然である。問題は、世代交代によって失われる知識の種類だ。

COBOLプログラマがアセンブラを知らなくても、COBOLは十分に使える。だが、gitを使うエンジニアがバージョン管理の本質——gitが何を解決しているのか、gitの設計の背後にある問い——を知らないとき、失われるのは単なる歴史的知識ではない。失われるのは、「なぜこうなっているのか」を理解し、「次に何が来るか」を予測する力だ。

私のキャリアは24年を超える。1990年代後半、Slackware 3.5をインストールしてLinuxに入門した。2000年代はCVSとSubversionの時代をくぐり抜け、2005年にGitの誕生を横目で見て、2010年代にGitへの移行プロジェクトを経験し、2020年代の今はClaude CodeやMCPを使ったAI支援開発に取り組んでいる。

この24年間で、私は少なくとも5つのバージョン管理のパラダイムを体験した。`cp httpd.conf httpd.conf.bak` の手動管理、RCSのファイル単位管理、CVSのネットワーク越し協調開発、Subversionのアトミックコミット、Gitの分散型リポジトリ。

それぞれの段階で、新しい仕組みが「前の仕組みの何を解決したか」を、私は身体で知っている。だからこそ、言いたいことがある。

gitは答えではない。問いに対する、ひとつの解である。

問いを知らずに解だけを使う人間は、次の問いに対応できない。この連載は、その問いを辿り直す旅だ。

---

## 3. バージョン管理とは何か——三つの本質

gitの話をする前に、もっと根本的なところから始めよう。「バージョン管理」とは何か。

多くのエンジニアがこの言葉を聞いて真っ先に思い浮かべるのは `git commit` だろう。あるいは `git push` や `git merge` かもしれない。だが、それらはバージョン管理の「方法」であって、「本質」ではない。

私は24年間の経験を通じて、バージョン管理の本質は三つの問いに集約されると考えるに至った。

### 第一の問い：何が変わったのか（What changed?）

ファイルの状態が、いつ、どのように変化したかを追跡すること。これがバージョン管理の最も原始的で、最も根源的な機能だ。

この問いだけに答えるなら、`cp` と `diff` で十分である。ファイルをコピーして保存し、二つのバージョンの差分を比較する。1970年代のUNIXプログラマが最初にやったことは、まさにこれだった。

1974年、Bell LabsのDouglas McIlroyとJames W. Huntが開発した `diff` コマンドがUnix第5版に同梱された。McIlroyはUNIXパイプの発明者としても知られる人物だ。1985年には、後にPerlの作者となるLarry Wallが `patch` コマンドを公開した。`diff` で差分を取り、`patch` で適用する。このシンプルな組み合わせが、50年後の今でもソフトウェア開発の基盤として生き続けている。

gitの `git diff` は、この系譜の正統な後継者だ。だが、gitが `diff` を内部で使っているからといって、gitが `diff` そのものではない。gitは `diff` が答えられない問いに答えるために生まれた。

### 第二の問い：誰が変えたのか、そしてどう統合するのか（Who changed it, and how do we integrate?）

一人で、一つのファイルを、順番に変更していくなら、第一の問いだけで十分だ。だが、現実の開発はそうはいかない。

複数の人間が、同じコードベースを、同時に変更する。この状況をどう扱うか。

大きく分けて二つのアプローチが歴史の中で生まれた。一つは「ロック方式」——誰かがファイルを編集している間、他の人はそのファイルに触れない。SCCS（1972年、Marc Rochkind、Bell Labs）やRCS（1982年、Walter Tichy、Purdue University）はこの方式を採用した。もう一つは「コピー・修正・マージ方式」——全員が自由にコピーを編集し、後から変更を統合する。CVS（1986年にDick Gruneがシェルスクリプトとして公開、開発自体は1984年から）がこの方式を初めて実用化した。

gitは後者の系譜に属する。しかもgitは、CVSやSubversionとは異なり、「中央サーバ」を前提としない。全員が完全なリポジトリのコピーを持ち、対等な立場で変更を統合できる。この「分散型」という設計思想は、2005年のGit誕生の核心にある。

だが、ここで一歩引いて考えてほしい。「分散型が集中型より優れている」という命題は、無条件に正しいのだろうか。集中型が適していた現場、集中型でなければ解決できなかった問題は、本当に存在しなかったのか。この問いは、第7回で深く掘り下げる。

### 第三の問い：なぜ変えたのか（Why did it change?）

変更の「内容」と「主体」が記録されたとしても、まだ足りないものがある。「理由」だ。

なぜこの関数の名前を変えたのか。なぜこの条件分岐を追加したのか。なぜこのライブラリのバージョンを上げたのか。

gitのコミットメッセージは、この問いに答えるための仕組みだ。だが、ここに注意が必要だ。gitはコミットメッセージの記入を強制する仕組みは持っているが、その内容の「質」を保証する仕組みは持っていない。`fix bug` とだけ書かれたコミットメッセージは、形式的にはバージョン管理されているが、実質的には歴史を保存していない。

「なぜ変えたのか」を記録することは、ツールの問題であると同時に、文化とプラクティスの問題でもある。どんなに優れたバージョン管理ツールを使っても、コミットメッセージが雑なら、歴史は失われる。

### gitはこの三つをどう解いているか

概観だけ示しておこう。

第一の問い——変更の記録——に対して、gitは「スナップショット＋内容アドレッシング」という方式を採用した。ファイルの内容をSHA-1ハッシュ（現在はSHA-256への移行が進行中）で管理し、同一内容のファイルは重複なく保存される。

第二の問い——協調の仕組み——に対して、gitは「分散リポジトリ＋マージアルゴリズム」で応えた。全員が完全な履歴を持ち、ブランチとマージを軽量に実行できる。

第三の問い——歴史の保存——に対して、gitは「コミットオブジェクト＋DAG（有向非巡回グラフ）」という構造で、コミットの親子関係を永続的に記録する。

これらの詳細は第15回以降で徹底的に解説する。ここでは、gitがこの三つの問いに対する「ひとつの解」であることを確認しておきたい。そして、この三つの問いそのものは、gitの誕生よりはるか以前——1970年代——から存在していたことを。

### gitが解いていない問題

完璧なバージョン管理ツールは存在しない。gitもまた例外ではない。

たとえば、巨大なバイナリファイルの効率的な管理。gitの内容アドレッシング方式は、テキストファイルに対しては極めて効率的だが、数GBの動画ファイルやゲームアセットに対しては本質的に不向きだ。Git LFSはこの問題への妥協策であり、解決策ではない。

たとえば、パスベースのアクセス制御。Subversionでは、リポジトリ内のディレクトリごとに読み書き権限を設定できた。gitにはこの機能がない。分散型の設計思想が、部分的なアクセス制御と原理的に相容れないからだ。モノレポで開発している大企業が、この問題にどう対処しているかは、第18回で詳しく扱う。

そして、「なぜこの変更をしたか」を強制する仕組み。繰り返すが、gitはコミットメッセージの質を保証しない。空のメッセージでのコミットを `--allow-empty-message` で許可することすらできる。歴史の保存は、結局のところ、人間の規律に委ねられている。

これらの「未解決の問題」は、gitの欠陥ではない。gitの設計思想がもたらすトレードオフだ。何かを得れば、何かを失う。大切なのは、何を得て何を失ったのかを自覚することだ。

---

## 4. ハンズオン：gitを使わずにバージョン管理する

ここからは、手を動かす時間だ。

gitが内部で何をしているかを理解する最良の方法は、gitなしで同じことをやってみることだと私は考えている。`cp`、`diff`、`patch`——この三つのコマンドだけで「バージョン管理もどき」を構築する。

### 環境の準備

Linux環境であれば、必要なツールはすべてプリインストールされている。macOSでも `diff` と `patch` は標準で利用可能だ。Windowsの場合はWSL2を推奨する。Dockerを使う場合は以下で十分だ。

```bash
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y diffutils patch
```

### 演習1：スナップショットの手動管理

まず、簡単なプロジェクトを作る。

```bash
# プロジェクトディレクトリを作成
mkdir -p ~/vcs-handson/project
cd ~/vcs-handson/project

# 最初のバージョン：簡単なシェルスクリプト
cat > hello.sh << 'EOF'
#!/bin/bash
# hello.sh - 挨拶スクリプト v1
echo "Hello, World!"
EOF
chmod +x hello.sh
```

さて、これを「バージョン管理」しよう。gitを使わずに。

```bash
# スナップショット取得（v1）
cd ~/vcs-handson
cp -r project project_v1
```

ファイルを変更する。

```bash
# プロジェクトを編集（v2へ）
cd ~/vcs-handson/project
cat > hello.sh << 'EOF'
#!/bin/bash
# hello.sh - 挨拶スクリプト v2
NAME=${1:-"World"}
echo "Hello, ${NAME}!"
echo "Today is $(date +%Y-%m-%d)"
EOF
```

変更内容を確認する。

```bash
# 差分を確認
diff -u ~/vcs-handson/project_v1/hello.sh ~/vcs-handson/project/hello.sh
```

出力はこうなるはずだ。

```diff
--- /root/vcs-handson/project_v1/hello.sh
+++ /root/vcs-handson/project/hello.sh
@@ -1,3 +1,5 @@
 #!/bin/bash
-# hello.sh - 挨拶スクリプト v1
-echo "Hello, World!"
+# hello.sh - 挨拶スクリプト v2
+NAME=${1:-"World"}
+echo "Hello, ${NAME}!"
+echo "Today is $(date +%Y-%m-%d)"
```

`-` で始まる行が削除された行、`+` で始まる行が追加された行だ。このunified diff形式は、1991年にWayne DavisonがGNU diffに追加したもので、gitが `git diff` で表示する形式とまったく同じである。

この差分をファイルとして保存しよう。

```bash
# パッチ保存用ディレクトリを作成し、差分をパッチファイルとして保存
mkdir -p ~/vcs-handson/patches
diff -u ~/vcs-handson/project_v1/hello.sh ~/vcs-handson/project/hello.sh \
  > ~/vcs-handson/patches/v1_to_v2.patch
```

### 演習2：patchで変更を適用する

保存したパッチを使って、v1からv2を復元してみよう。

```bash
# v1のコピーを作成して、パッチを適用
cd ~/vcs-handson
cp -r project_v1 project_restored
cd project_restored
patch < ~/vcs-handson/patches/v1_to_v2.patch
```

パッチの適用後、ファイルの内容を確認すると、v2と同一になっているはずだ。

```bash
# 復元されたファイルと現行バージョンを比較
diff ~/vcs-handson/project/hello.sh ~/vcs-handson/project_restored/hello.sh
```

出力が何もなければ、完全に一致している。**差分さえ保存しておけば、任意のバージョンを復元できる**。これがバージョン管理の第一原理だ。

### 演習3：手動マージの地獄を体験する

ここからが本番だ。二人の開発者が、同じファイルを別々に変更したらどうなるか。

```bash
cd ~/vcs-handson

# 開発者Aliceの作業：エラーハンドリングを追加
cp -r project_v1 work_alice
cat > work_alice/hello.sh << 'EOF'
#!/bin/bash
# hello.sh - 挨拶スクリプト（Alice版）
if [ -z "$BASH_VERSION" ]; then
  echo "Error: This script requires bash" >&2
  exit 1
fi
echo "Hello, World!"
EOF

# 開発者Bobの作業：多言語対応を追加
cp -r project_v1 work_bob
cat > work_bob/hello.sh << 'EOF'
#!/bin/bash
# hello.sh - 挨拶スクリプト（Bob版）
LANG=${1:-"en"}
case $LANG in
  ja) echo "こんにちは、世界！" ;;
  en) echo "Hello, World!" ;;
  *)  echo "Hello, World!" ;;
esac
EOF
```

AliceとBobの変更をそれぞれ差分で確認する。

```bash
echo "=== Aliceの変更 ==="
diff -u project_v1/hello.sh work_alice/hello.sh

echo ""
echo "=== Bobの変更 ==="
diff -u project_v1/hello.sh work_bob/hello.sh
```

さて、この二つの変更を「マージ」したい。v1（共通の祖先）を基準にして、AliceとBobの変更を統合する。`diff3` コマンドを使おう。

```bash
# 3-way diff：Alice版、元版、Bob版の順で指定
diff3 -m work_alice/hello.sh project_v1/hello.sh work_bob/hello.sh
```

出力を見てほしい。`diff3` は二人の変更が重なる部分（コンフリクト）を `<<<<<<<`、`=======`、`>>>>>>>` というマーカーで表示する。この表記に見覚えはないだろうか。そう、`git merge` がコンフリクト時に表示するマーカーと同じだ。gitはこの `diff3` の仕組みを内部で使っている。

このコンフリクトを手動で解消してみてほしい。AliceのエラーハンドリングとBobの多言語対応を、一つのファイルに統合する。テキストエディタでマーカーを消し、両方の変更が正しく動作するコードを書く。

これは、慣れていれば数分で終わる作業だ。だが、ファイルが10個あったら？ 100個あったら？ 変更が100行に及んでいたら？ そして、3人目の開発者Charlieが同時に別の変更をしていたら？

### この演習から学べること

この作業を100回繰り返す覚悟があるだろうか。なければ、あなたにはバージョン管理ツールが必要だ。

ただし、忘れないでほしい。バージョン管理ツールが内部でやっていることは、本質的にはあなたが今手でやったことと同じだ。

`git commit` は、スナップショットを保存している。`git diff` は、`diff` を実行している。`git merge` は、`diff3` の発展形を使って三者間の差分を統合している。gitはこれらの操作を自動化し、高速化し、堅牢にしたツールだ。だが、原理は変わらない。

原理を知っている人間は、ツールの挙動を「予測」できる。予測できれば、問題が起きたときに原因を「推理」できる。推理できれば、自力で「解決」できる。

原理を知らない人間は、ツールが期待通りに動かないとき、Stack OverflowでコマンドをコピーするかAIに聞くしかない。それで解決することも多い。だが、本当に厄介な問題——gitの内部状態が壊れたとき、リベースが意図しない結果になったとき、マージコンフリクトが複雑に絡み合ったとき——には、原理の理解なしには対処できない。

---

## 5. まとめと次回予告

### この回の要点

第一に、gitは2020年代のソフトウェア開発において圧倒的な支配的地位にある。開発者の94%がgitを使い、CI/CDからInfrastructure as Codeまで、あらゆるツールがgitを前提として設計されている。

第二に、gitは「答え」ではなく「問いに対するひとつの解」である。問いとは、バージョン管理の三つの本質——変更の記録、協調の仕組み、歴史の保存——である。この問いは1970年代から存在しており、gitはその問いに対する2005年時点の最適解だった。

第三に、gitが支配的になった結果、「なぜgitなのか」を問う機会が失われている。gitを使えることと、gitを理解していることは、まったく別のことだ。

第四に、gitの内部で起きていることは、`cp`、`diff`、`patch` という原始的な操作の自動化・高速化・堅牢化である。原理を知ることが、ツールの挙動を予測し、問題を自力で解決する力につながる。

### 冒頭の問いへの暫定回答

gitが空気になった世界で失われたもの。それは「選択する力」だ。

選択肢を知らなければ、選択はできない。選択をしていなければ、「なぜそうしているのか」を説明できない。説明できなければ、「次にどうすべきか」を判断できない。

この連載の目的は、失われた選択肢を取り戻すことだ。

### 次回予告

次回は、もっと時間を巻き戻す。

バージョン管理ツールが存在しなかった時代——`cp -r` と `tar` だけが友だちだった世界に立ち帰ろう。1970年代のBell Labsで `diff` はどう生まれたか。そしてなぜ、`diff` と `patch` だけでは足りなくなったのか。

**第2回「すべてはcp -rから始まった——バージョン管理以前の世界」**

あなたがgitで最初に覚えたコマンドは何だっただろうか。そのコマンドが何をしているか、gitの内部で何が起きているか、説明できるだろうか。もし言葉に詰まるなら、この連載はあなたのために書いている。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- GitHub, "Octoverse 2025," October 2025. <https://github.blog/news-insights/octoverse/octoverse-2025/>
- Stack Overflow, "Developer Survey 2022 -- Version Control," June 2022. <https://survey.stackoverflow.co/2022/>
- JetBrains, "The State of CI/CD in 2025," October 2025. <https://blog.jetbrains.com/teamcity/2025/10/the-state-of-cicd/>
- Hunt, J. W. and McIlroy, M. D., "An Algorithm for Differential File Comparison," Bell Labs CSTR #41, July 1976.
- Myers, E. W., "An O(ND) Difference Algorithm and Its Variations," Algorithmica, 1986.
- Wall, L., "patch version 1.3," posted to mod.sources, May 24, 1985.
- Torvalds, L., "Initial revision of 'git', the information manager from hell," April 7, 2005. Commit e83c5163316f89bfbde7d9ab23ca2e25604af290.
- Richardson, A., "GitOps -- Operations by Pull Request," Weaveworks Blog, 2017.
