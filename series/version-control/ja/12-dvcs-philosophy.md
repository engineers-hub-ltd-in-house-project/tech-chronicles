# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第12回：分散型VCSの思想——なぜ"中央"をなくしたかったのか

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 分散型バージョン管理の思想がどのような技術的・文化的背景から生まれたのか
- TeamWare（1992年）からBitKeeper、GNU arch、Monotone、Darcsに至る分散型VCSの系譜
- GNU arch、Monotone、Darcsの設計思想の違いと、それぞれが切り拓いた地平
- DAG（有向非巡回グラフ）と暗号学的ハッシュによるデータモデルの基本原理
- OSSコミュニティの自律分散的な開発スタイルと分散型VCSの共鳴
- Gitが登場する「前夜」の技術的蓄積がGitに何を遺したか

---

## 1. サーバが落ちた日

2006年のある金曜日のことだ。

私が参加していたプロジェクトのSubversionサーバが、ストレージ障害で停止した。朝9時に出社し、`svn update` を実行すると、接続がタイムアウトする。インフラ担当に連絡すると、「RAIDの再構築中で、復旧は夕方になる見込み」とのことだった。

チームの全員が、その瞬間から「作業はできるが記録できない」状態に陥った。コードを書くことはできる。ビルドもテストもできる。だが、コミットできない。`svn diff` でローカルの差分は見られるが、それは「pristineコピー」との差分であり、複数のステップにわたる変更を段階的に記録することはできない。

私はその日、三つの機能修正を行った。だが、サーバが復旧したとき、三つの変更を一つのコミットにまとめるか、手動で差分を分割して三つのコミットにするかという、本来不要な作業に直面した。結局、私はすべてを一つの巨大なコミットにまとめた。コミットメッセージには「Fix A, B, and C」と書いた。アトミックコミットの理念とは程遠い、雑な記録だった。

この体験は、私に一つの問いを突きつけた。**なぜ、バージョン管理の操作がサーバの可用性に依存しなければならないのか。**

この問いは、私だけのものではなかった。2000年代前半、世界中のソフトウェア開発者が同じ問いに直面していた。そして、その問いに対する答えとして「分散型バージョン管理」という思想が立ち上がった。

だが、分散型VCSは突然出現したわけではない。Gitが2005年に登場するまでに、少なくとも10年以上にわたる思想的・技術的蓄積があった。TeamWare、GNU arch、Monotone、Darcs——これらの先駆者たちが切り拓いた地平の上に、Gitは立っている。

この回では、「分散型バージョン管理は、技術的必然だったのか、思想的選択だったのか」という問いを追う。答えを先に言えば——両方だ。技術的要件と文化的理想が交差するところに、分散型VCSは生まれた。

あなたが日常的に使っている `git commit` が、サーバへの接続なしにローカルで完結すること。`git log` が瞬時に結果を返すこと。これらの「当たり前」は、誰かが「なぜ中央サーバが必要なのか」と問い直した結果だ。その問いの歴史を、今回は追いかけてみよう。

---

## 2. 分散への胎動——1992年から2001年

### TeamWare——企業内での先駆

分散型バージョン管理の歴史は、多くの人が想像するよりも古い。

1992年11月、Sun Microsystemsが「SPARCworks/TeamWare」を発表した。1993年に商用化されたTeamWareは、分散型ソースコードリビジョン管理システムだった。各開発者がローカルにリポジトリの完全なコピーを持ち、変更をピアツーピアで同期する——この基本的なアイデアは、10年以上後に登場するGitと本質的に同じだ。

TeamWareの最大の展開はSun自身の内部であった。SolarisやJavaの大規模ソースツリーの管理にTeamWareが使用された。Sun内部という閉じた環境での実践ではあったが、「分散型VCSが大規模開発に耐えうる」ことを実証した最初の事例の一つだった。

Larry McVoyはSunでTeamWareに携わったエンジニアだ。McVoyはTeamWareの設計思想を継承し、1998年にLinuxカーネルメーリングリストで新しい分散型VCSの構想を提案した。そして2000年にBitMover社を設立し、BitKeeperを商用製品としてリリースした。BitKeeperは1999年3月にself-hostingを達成し、2000年5月4日に最初の公開リリースを行った。

TeamWareからBitKeeperへの系譜は重要だ。分散型VCSの思想は、OSSコミュニティの理想主義から生まれたわけではない。Sun Microsystemsという大企業の内部で、大規模ソフトウェア開発の現実的な要求に応える形で生まれた。「中央サーバに全員が依存する」というモデルの脆弱性は、数百人の開発者がSolarisのカーネルを共同開発する現場で、すでに認識されていたのだ。

### なぜ「中央」が問題になったのか

集中型VCSの限界は、前回までに詳しく見てきた。ここでは、分散型VCSが解決しようとした問題を、改めて整理する。

**問題1：単一障害点（Single Point of Failure）**

中央サーバが停止すれば、全員のワークフローが停止する。サーバのストレージ障害、ネットワーク障害、あるいは単純なメンテナンスウィンドウ——いかなる理由であれ、サーバに到達できない間は、コミット、履歴の参照、ブランチの作成といった基本操作が行えない。

**問題2：ネットワーク依存性**

すべてのVCS操作がネットワーク越しにサーバと通信する。`svn log` でコミット履歴を見るにも、`svn blame` で行ごとの著者を確認するにも、サーバへのリクエストが必要だ。ネットワーク遅延が増えれば、操作の体感速度が直接的に劣化する。

**問題3：スケーラビリティの壁**

開発者の数が増えれば、サーバへの同時リクエストが増加する。リポジトリのサイズが増えれば、各操作の処理時間が増加する。集中型アーキテクチャでは、サーバのキャパシティがボトルネックになる。

**問題4：権限構造の硬直性**

集中型VCSでは、コミット権限は中央サーバのアクセス制御によって管理される。OSS開発において、新しいコントリビュータにコミット権限を付与するかどうかは政治的な判断を伴う。コントリビュータは「パッチを送って、コミット権限を持つ人にマージしてもらう」というワークフローを強いられる。

これらの問題のうち、1から3は技術的な問題だ。サーバの冗長化、ネットワークの高速化、サーバの増強で緩和できる。だが、4は構造的な問題だ。集中型VCSでは、「コミットする権利」と「フォークする自由」が構造的に制限されている。

OSS開発コミュニティにとって、この構造的制限は深刻だった。Linuxカーネルの開発は、数千人の開発者がメーリングリストでパッチを交換し、各サブシステムのメンテナが取り込みを判断するという、本質的に分散した構造を持っていた。この開発モデルは、中央サーバ型VCSの前提と根本的に相容れなかった。

### GNU arch——最初の分散型OSSプロジェクト

2001年11月、Tom LordがGNU archの開発を開始した。CVSに代わる分散型リビジョン管理システムとして設計されたGNU archは、OSSコミュニティから生まれた最初期の分散型VCSの一つだった。

GNU archの核心的なアイデアは、各リビジョンにグローバルに一意な識別子を付与することだった。CVSやSubversionのリビジョン番号はリポジトリローカルなものだが、GNU archのリビジョン識別子は全世界で一意だった。これにより、まったく異なるソースからの変更を、識別子だけで追跡し、マージやcherry-pickが可能になった。

当初、archはシェルスクリプトの集合体（コマンド名はlarch）として実装された。後にCで書き直され、tla（Tom Lord's Arch）というコマンド名になった。2003年にGNUプロジェクトの公式プロジェクトとなった。

GNU archは先駆的だったが、いくつかの問題を抱えていた。ユーザーインターフェースは複雑で、学習曲線が急峻だった。性能面でも課題があり、大規模プロジェクトでの使用には限界があった。2005年8月にLordがメンテナンスを辞任し、2009年にはdeprecatedステータスとなった。

だが、GNU archが切り拓いた道は消えなかった。CanonicalはGNU archを基盤にBazaar（baz）を開発し、2005年にはゼロから書き直したBazaar-NG（bzr）を後継として発表した。bzrは2008年にGNUプロジェクトに受け入れられ、UbuntuとLaunchpadのエコシステムで広く使用された。GNU archの思想は、形を変えて生き続けた。

---

## 3. 三つの先駆者——Monotone、Darcs、BitKeeper

### Monotone——暗号学的完全性の追求

2003年4月6日、Graydon HoareがMonotoneの最初の公開リリースを行った。Hoareは2002年夏に開発を開始しており、後にRustプログラミング言語の作者としても知られることになる人物だ。

Monotoneの設計思想は、三つの原則に集約される。

**第一に、暗号学的ハッシュによるリビジョン識別。** Monotoneは各リビジョンをSHA-1ハッシュで識別した。ファイルの内容、ディレクトリ構造、コミットメタデータ——これらのハッシュが連鎖することで、リポジトリ全体のデータ完全性が暗号学的に保証される。ある一つのリビジョンが改竄されれば、そのハッシュが変わり、それを参照するすべてのリビジョンのハッシュも変わる。Merkle木（ハッシュ木）の性質だ。

このアイデアは、Gitに直接影響を与えた。Gitのオブジェクトモデル——blob、tree、commit、tagのすべてがSHA-1ハッシュで識別される——は、Monotoneが先行して実証した概念だ。

**第二に、SQLiteバックエンドによるローカルデータベース。** Monotoneは各リポジトリのデータをSQLiteデータベースに格納した。単一ファイルのトランザクショナルデータベースという選択は、ファイルシステム上にリポジトリデータを直接配置するよりも、アトミック性と一貫性の保証が容易だった。

**第三に、公開鍵暗号によるチェンジセット署名。** Monotoneでは、各チェンジセットにRSA署名が付与される。誰がその変更を行ったかが暗号学的に検証可能であり、信頼の委譲——「このユーザーの署名を信頼する」という設定——をクライアント側で行える。中央サーバがアクセス制御を行うのではなく、各開発者が「誰を信頼するか」を自分で決定する。

Monotoneのネットワーク同期はnetsyncプロトコルで行われた。TCPまたはSSH上で動作するこのプロトコルは、ピアツーピアのリポジトリ同期を実現した。

```
Monotoneのデータモデル:

  ┌──────────────┐    SHA-1ハッシュで
  │  リビジョン    │    一意に識別
  │  (revision)   │◄─────────────────
  └──────┬───────┘
         │ 親リビジョンへの参照
         ▼
  ┌──────────────┐    各リビジョンが
  │  リビジョン    │    親を参照 → DAG
  │  (revision)   │
  └──────┬───────┘
         │
         ▼
  ┌──────────────┐
  │  リビジョン    │    ルートリビジョン
  │  (revision)   │    （親なし）
  └──────────────┘

  + RSA署名による認証
  + SQLiteによるローカルストレージ
  + netsyncによるP2P同期
```

Monotoneは技術的に先進的だったが、性能面で課題があった。大規模リポジトリでの操作速度が実用レベルに達しなかったため、Linuxカーネルの開発者コミュニティには採用されなかった。Linus Torvaldsは、MonotoneのアイデアをGitの設計に取り入れつつも、性能面での妥協を拒否した。この点は第14回で詳しく扱う。

### Darcs——パッチ理論という異端

同じ2003年4月、David RoundyがDarcsの公開リリースを行った。Darcsは、Monotoneとは根本的に異なるアプローチで分散型VCSを実現した。

Roundyの着想はGNU archのパッチフォーマットに関する議論（2002年6月）から始まった。その議論はarch本体にコードとしてマージされることはなかったが、Roundyに「パッチ理論」（theory of patches）という独自の概念を構築させた。最初はC++で実装されたが、2002年秋にHaskellで書き直され、2003年4月に公開された。

Darcsの設計思想はパッチを「第一級市民」として扱うことにある。他のVCSでは、リポジトリの状態はスナップショットの列として表現され、パッチ（差分）はスナップショット間の導出物に過ぎない。Darcsでは、パッチこそがリポジトリの本質であり、リポジトリの状態はパッチの集合から導出される。

この発想の転換は、ブランチとマージの概念を根底から変える。

従来のVCS（CVS、Subversion、そしてGitも含む）では、ブランチは「履歴の分岐」であり、マージは「分岐した履歴の統合」だ。マージ時には、共通祖先を見つけ、両方の変更を統合する必要がある。

Darcsでは、リポジトリはパッチの（半順序の）集合だ。あるパッチは他のパッチに依存するかもしれないし、独立しているかもしれない。「ブランチ」という概念は、単に「異なるパッチの集合」として表現される。「マージ」は、あるリポジトリのパッチを別のリポジトリに適用することであり、パッチの可換性（commutation）——つまり、パッチの適用順序を入れ替えても結果が同じになるかどうか——がパッチ理論の核心だ。

```
従来のVCS（スナップショットベース）:

  状態A ──→ 状態B ──→ 状態C ──→ 状態D
         パッチ1    パッチ2    パッチ3

  パッチは状態間の「差分」として存在

Darcs（パッチベース）:

  {パッチ1, パッチ2, パッチ3} → 状態

  状態はパッチの集合から「導出」される
  パッチ間の順序は半順序（独立なパッチは順序不同）

  パッチの可換性:
    パッチA ○ パッチB = パッチB' ○ パッチA'
    （依存関係がなければ、順序を入れ替えても同じ結果）
```

Darcsのパッチ理論は、数学的に美しい概念だ。パッチの可換性により、cherry-pickが自然な操作として表現される。「特定のパッチだけを取り込む」ことが、Darcsではモデルの本質的な操作なのだ。

だが、Darcsには深刻な実用上の問題があった。パッチの可換性を計算するアルゴリズムが、特定のケースで指数関数的な計算量を要する「指数関数的マージ問題（exponential merge problem）」だ。リポジトリの履歴が複雑になると、マージ操作が事実上終わらなくなる場合があった。

Haskellの型システムによる正確性保証とQuickCheckによるランダムテストは、Darcsのコードの正しさを検証するには有効だった。だが、アルゴリズムの計算量という根本的な問題は、言語の選択では解決できなかった。

Darcsのパッチ理論は「正しいが遅い」という状態にあり、大規模プロジェクトへの適用には限界があった。しかし、パッチ理論の思想はDarcsで終わらなかった。Pijulという後継プロジェクト（第22回で扱う予定）が、パッチ理論を新しい形で再実装している。

### BitKeeper——商用の完成度

BitKeeperについては次回（第13回）で詳しく扱うが、ここでは分散型VCSの系譜における位置づけを簡潔に述べる。

Larry McVoyがSun MicrosystemsのTeamWareから持ち込んだ分散型の設計思想は、BitKeeperにおいて商用グレードの完成度に到達した。分散リポジトリ、高速マージ、リネーム追跡——これらの機能は、当時のOSS系分散型VCSのいずれをも凌駕していた。

BitKeeperの技術的先進性は、Linuxカーネルの開発者コミュニティが2002年に採用を決めたことからも明らかだ。Linus Torvaldsは、BitKeeperが彼の要求する性能と機能を満たす「唯一の」ツールだと認めていた。

だが、BitKeeperはプロプライエタリ製品であり、そのことがOSSコミュニティ内で深刻な軋轢を生んだ。この軋轢がどう爆発し、Gitの誕生につながったかは、次回の主題だ。

---

## 4. 分散型VCSの技術的基盤——DAGとハッシュ

### DAG——非線形な履歴の表現

分散型VCSの技術的基盤には、二つの重要な概念がある。DAG（有向非巡回グラフ）と暗号学的ハッシュだ。

集中型VCSでは、コミット履歴は基本的に線形だ。Subversionの連番リビジョン（r1, r2, r3, ...）が示すように、各コミットには一意の順序が存在する。ブランチは「本流からの分岐」として表現されるが、本質的には中央リポジトリ上の線形的な操作列だ。

分散型VCSでは、複数の開発者が独立にコミットを積み重ねるため、履歴は本質的に非線形になる。AさんとBさんが同時に独立したコミットを行えば、その時点で履歴は分岐する。これを自然に表現するのがDAG（有向非巡回グラフ）だ。

```
集中型VCS（Subversion）の履歴モデル:

  r1 ─→ r2 ─→ r3 ─→ r4 ─→ r5 ─→ r6
                            ↑
                        すべてが線形

分散型VCS（Git/Monotone等）の履歴モデル（DAG）:

  A1 ─→ A2 ─→ A3 ──────────┐
                              ▼
  B1 ─→ B2 ─→ B3 ─→ M1 ─→ M2
              ↑       ↑
              │      マージコミット
           独立した並行開発
```

DAGでは、各コミット（ノード）が一つ以上の親コミットを参照する。通常のコミットは親が一つ、マージコミットは親が二つ（以上）だ。ルートコミットだけが親を持たない。

DAGの重要な性質は「非巡回」——サイクルがない——ことだ。コミットAの子孫がコミットA自身になることはない。これにより、コミット間に明確な祖先・子孫の関係が定義され、マージ時の共通祖先の探索が数学的に定義できる。

### 暗号学的ハッシュ——内容に基づく識別

集中型VCSでは、リビジョンの識別子はサーバが発行する連番だった。分散型VCSでは中央サーバが存在しないため、連番は使えない。代わりに使われたのが、暗号学的ハッシュ——コミットの内容そのものから計算される識別子だ。

Monotoneが採用し、Gitが継承したこのアプローチは、以下のように機能する。

```
コミットのハッシュ計算:

  コミットの内容:
    - ツリーのハッシュ（ファイル構造全体のハッシュ）
    - 親コミットのハッシュ
    - 著者名、日時
    - コミットメッセージ

  SHA-1(上記すべてを連結) → 40桁の16進数

  例: a1b2c3d4e5f6... （40文字）
```

このアプローチには、三つの重要な性質がある。

**性質1：内容アドレッサビリティ。** ハッシュはコミットの内容から決定論的に計算される。同じ内容のコミットは、いつ、どこで作成されても、同じハッシュを持つ。これにより、分散した環境でもコミットの一意な識別が保証される。

**性質2：完全性の検証。** コミットのハッシュは、その内容と親コミットのハッシュを含む。親コミットのハッシュはさらにその親のハッシュを含む。つまり、あるコミットのハッシュを検証すれば、そのコミットに至るまでの全履歴の完全性が暗号学的に保証される。これはMerkle木（ハッシュ木）と呼ばれるデータ構造の性質だ。データの改竄は、ハッシュの不一致として即座に検出される。

**性質3：分散環境での一貫性。** 中央サーバが連番を発行する必要がないため、オフラインでもコミットの識別子を確定できる。二つのリポジトリが独立にコミットを積み重ねた後、同期する際にも、ハッシュに基づいて重複の排除と差分の特定が可能だ。

```
Merkle木の性質:

  コミット C3 (hash: abc...)
    │
    ├── 親: C2 (hash: def...)
    │     │
    │     └── 親: C1 (hash: 789...)
    │
    └── ツリー T3 (hash: xyz...)
          │
          ├── blob fileA (hash: 111...)
          └── blob fileB (hash: 222...)

  C3のハッシュは、C2のハッシュとT3のハッシュを含む
  → C3のハッシュを検証 = C2以前の全履歴の完全性を検証
  → どこか一箇所でも改竄すれば、C3のハッシュが変わる
```

### 全履歴のローカル保持

分散型VCSの三つ目の技術的特徴は、リポジトリの全履歴を各開発者のローカルマシンに保持することだ。

集中型VCSでは、中央サーバが履歴の「正本」を持ち、開発者のローカルには「最新のスナップショット」と「pristineコピー」だけが存在する。分散型VCSでは、`clone`（または `pull`）の時点で、リポジトリの全データ——すべてのコミット、すべてのファイルバージョン、すべてのブランチ——がローカルにコピーされる。

この設計がもたらす利点は明確だ。

第一に、ほとんどのVCS操作がローカルで完結する。`log`、`diff`、`blame`、`commit`、`branch`、`merge`——これらすべてがネットワーク通信なしで実行できる。リモートとの同期が必要なのは `push` と `pull`（Gitの場合は `fetch`）だけだ。

第二に、天然のバックアップが成立する。リポジトリをクローンした全員がバックアップを持っている。中央サーバが全損しても、いずれかの開発者のローカルリポジトリから復旧できる。

第三に、オフラインでの完全な作業が可能だ。飛行機の中でも、ネットワーク障害の最中でも、コミット、ブランチ作成、マージ、履歴の参照——すべてが通常通り機能する。

代償はストレージだ。リポジトリの全履歴をローカルに保持するため、大規模リポジトリでは初回のクローンに時間がかかり、ディスク消費も大きくなる。この代償が問題にならないプロジェクトでは分散型が圧倒的に有利だが、テラバイト級のバイナリアセットを持つプロジェクトでは、前回見たように集中型の方が適している場合がある。

---

## 5. ハンズオン：Monotoneを体験する——Gitの「前夜」に触れる

Gitの設計に直接影響を与えたMonotoneを実際に操作し、SHA-1ハッシュによるリビジョン識別、RSA鍵による認証、そしてDAGベースの履歴管理を体験しよう。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y monotone
```

### 演習1：Monotoneデータベースの作成とリビジョンの記録

```bash
WORKDIR="${HOME}/vcs-handson-12"
mkdir -p "${WORKDIR}"
cd "${WORKDIR}"

echo "=== 演習1: Monotoneデータベースの作成とリビジョンの記録 ==="

# RSA鍵ペアの生成（Monotoneは暗号学的認証が必須）
echo ""
echo "--- RSA鍵ペアを生成 ---"
mtn genkey handson@example.com --db=project.mtn 2>&1 <<'PASSEOF'


PASSEOF
echo "-> MonotoneではRSA鍵による認証が必須"
echo "-> 「誰がこの変更を行ったか」が暗号学的に検証可能"

# ワークスペースの作成とファイルの追加
echo ""
echo "--- ワークスペースを初期化 ---"
mtn setup --branch=com.example.project --db=project.mtn workspace
cd workspace

cat > hello.c << 'EOF'
#include <stdio.h>

int main(void) {
    printf("Hello from Monotone!\n");
    return 0;
}
EOF

mtn add hello.c
echo ""
echo "--- 最初のコミット ---"
mtn commit -m "Add hello.c" --author=handson@example.com 2>&1 || true
echo ""
echo "--- リビジョン一覧 ---"
mtn log --brief 2>&1 | head -5
echo ""
echo "-> リビジョンがSHA-1ハッシュで識別されている"
echo "-> Subversionの連番（r1, r2, ...）とは根本的に異なるモデル"
```

### 演習2：ブランチとDAGの構造を確認する

```bash
echo ""
echo "=== 演習2: ブランチとDAGの構造を確認する ==="

# 二つ目のコミット
cat > hello.c << 'EOF'
#include <stdio.h>

int main(void) {
    printf("Hello from Monotone!\n");
    printf("Revision control with cryptographic integrity.\n");
    return 0;
}
EOF

mtn commit -m "Add description line" --author=handson@example.com 2>&1 || true

echo ""
echo "--- リビジョン一覧（DAGの確認）---"
mtn log --brief 2>&1 | head -10
echo ""
echo "--- 特定リビジョンの詳細 ---"
LATEST=$(mtn automate heads 2>/dev/null | head -1)
if [ -n "${LATEST}" ]; then
  mtn log --to "${LATEST}" --last=1 2>&1
fi
echo ""
echo "-> 各リビジョンが親リビジョンのハッシュを参照"
echo "-> これがDAG（有向非巡回グラフ）の構造"
echo "-> Git の git log --graph と同じ概念"
```

### 演習3：Monotoneの設計思想をGitと比較する

```bash
echo ""
echo "=== 演習3: MonotoneとGitの概念的対応 ==="

echo ""
echo "Monotoneの設計思想とGitの対応:"
echo ""
echo "  Monotone                    Git"
echo "  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  SHA-1リビジョン識別   →    SHA-1コミットハッシュ"
echo "  RSA署名による認証     →    GPG署名（オプション）"
echo "  SQLiteバックエンド    →    ファイルシステム直接"
echo "  netsyncプロトコル     →    git://, ssh://, https://"
echo "  DAGベースの履歴       →    DAGベースの履歴"
echo ""
echo "Gitが変えたこと:"
echo "  - SQLiteの代わりにファイルシステムを直接使用（性能重視）"
echo "  - 暗号署名を必須ではなくオプションに（参入障壁の低減）"
echo "  - Linuxカーネル規模での性能を最優先に設計"
echo ""
echo "-> Monotoneのアイデアの多くがGitに受け継がれた"
echo "-> 最大の違いは「性能へのこだわり」"
```

### 演習で見えたこと

三つの演習を通じて、Monotoneの基本操作を体験した。

RSA鍵ペアの生成という手順は、CVSやSubversionにはなかった概念だ。「誰がこの変更を行ったか」を暗号学的に検証可能にするという設計思想は、分散環境でのコード完全性を保証するための本質的なアプローチだ。

リビジョンがSHA-1ハッシュで識別される点は、Gitと同じだ。`mtn log` で表示されるハッシュ文字列は、`git log` で見慣れたものと本質的に同じ概念だ。Subversionの連番リビジョン（r1234）とは根本的に異なるアプローチであり、分散環境での一意な識別を可能にしている。

Monotoneを触ることで、「Gitのアイデアの多くはMonotoneに由来する」という事実を体感できる。GitはMonotoneのアイデアを受け継ぎつつ、SQLiteの代わりにファイルシステムを直接使用し、暗号署名を必須からオプションに変え、Linuxカーネル規模での性能を最優先にした。結果としてMonotoneではなくGitが広く普及したが、Monotoneの思想的貢献は歴史に記録されるべきだ。

---

## 6. OSSコミュニティの開発スタイルとの共鳴

### メーリングリストとパッチ交換

分散型VCSの思想が、単なる技術的な最適化ではなく、文化的な共鳴を伴って受け入れられた背景を理解するには、OSSコミュニティの開発スタイルを知る必要がある。

2000年代前半のOSS開発、特にLinuxカーネルの開発は、メーリングリストを中心とした分散的な構造で運営されていた。開発者は自分の環境でコードを修正し、`diff -u` でパッチを生成し、メーリングリストに投稿する。サブシステムのメンテナがパッチをレビューし、問題がなければ自分のツリーに取り込む。各メンテナのツリーは、さらに上位のメンテナに取り込まれ、最終的にLinus Torvaldsのツリーに到達する。

この開発モデルは、本質的にピアツーピアだ。中央のサーバがコミット権限を管理しているわけではない。誰でもパッチを書いて投稿できる。メンテナが「取り込む」か「取り込まない」かを判断する。この判断の権限は階層的に分散している。

集中型VCSは、このモデルと構造的に相容れなかった。CVSやSubversionでは、「コミット権限」はサーバの管理者が付与する。パッチを投稿するだけのコントリビュータは、VCSの上では「外部」の存在だ。パッチのレビューとマージは、コミット権限を持つ人間がVCS外部で（メーリングリストやバグトラッカーで）受け取り、手動で適用する。VCSがコントリビューションのワークフローを自然に表現できなかったのだ。

分散型VCSは、この問題を構造的に解決した。全員がリポジトリの完全なコピーを持つ。誰でも自分のリポジトリにコミットできる。変更の「取り込み」は `pull` 操作であり、VCSのネイティブな機能だ。コミット権限の概念は消滅し、代わりに「誰のリポジトリから pull するか」という信頼の構造がワークフローを規定する。

```
集中型VCSでのOSS開発:

  コントリビュータ ──パッチ送信──→ メーリングリスト ──→ コミッター ──→ [中央リポジトリ]
                    （VCS外部）                      （手動適用）

  問題: コントリビューションがVCSのワークフローに統合されていない

分散型VCSでのOSS開発:

  コントリビュータ ──commit──→ [自分のリポジトリ] ──pull request──→ メンテナ ──→ [メンテナのリポジトリ]
                   （VCSの操作）                    （VCSの操作）

  解決: コントリビューションがVCSのネイティブ操作として表現される
```

### 「フォークの自由」

分散型VCSのもう一つの文化的意義は、「フォークの自由」だ。

OSSにおいて、プロジェクトのフォーク（分岐）は権利として保障されている。GPL、MIT、Apache——いずれのライセンスも、ソースコードの複製と修正の自由を保障する。だが、集中型VCSでは、フォークは「別のサーバにリポジトリを複製する」という重い操作だった。履歴ごとコピーするには、サーバ管理者の協力が必要な場合もあった。

分散型VCSでは、`clone` がフォークそのものだ。リポジトリをクローンした時点で、全履歴を含む完全なコピーが手元にある。そこから独自の変更を加え、独自のプロジェクトとして公開することも、元のプロジェクトに変更を提案することも、すべてがVCSのネイティブな操作として可能だ。

この「フォークの自由」が、OSSコミュニティの自律分散的な文化と深く共鳴した。分散型VCSは、ソフトウェアの自由を技術的に実現するインフラストラクチャだったのだ。

---

## 7. まとめと次回予告

### この回の要点

第一に、分散型VCSの思想は、1992年のSun Microsystems TeamWareにまで遡る。TeamWareの設計思想はBitKeeperに継承され、OSSコミュニティではGNU arch（2001年）が分散型VCSの先駆けとなった。

第二に、2003年にMonotoneとDarcsが相次いで登場し、分散型VCSの技術的基盤を確立した。MonotoneはSHA-1ハッシュによるリビジョン識別と暗号学的完全性保証をもたらし、DarcsはパッチをFirst-class citizenとして扱うパッチ理論を提示した。これらのアイデアは、後のGitの設計に直接的・間接的に影響を与えた。

第三に、分散型VCSの技術的基盤は、DAG（有向非巡回グラフ）による非線形な履歴表現、暗号学的ハッシュによる内容アドレッサビリティと完全性保証、全履歴のローカル保持の三要素で構成される。

第四に、分散型VCSの登場は純粋に技術的な最適化ではなかった。OSSコミュニティのメーリングリストベースのパッチ交換モデル、コントリビューションの自由、フォークの権利——これらの文化的要素と分散型VCSの設計思想は深く共鳴していた。

第五に、BitKeeperは商用グレードの完成度で分散型VCSの実用性を証明したが、プロプライエタリという性質がOSSコミュニティとの軋轢を生んだ。

### 冒頭の問いへの暫定回答

分散型バージョン管理は、技術的必然だったのか、思想的選択だったのか。

両方だ。

集中型VCSの技術的限界——単一障害点、ネットワーク依存性、スケーラビリティの壁——は、ソフトウェア開発の規模拡大とグローバル化に伴い、ますます深刻になっていた。この意味で、分散型VCSは技術的必然だった。

だが同時に、分散型VCSは思想的選択でもあった。OSSコミュニティの自律分散的な開発スタイル、「フォークの自由」への信念、「中央の管理者に依存しない」という価値観——これらがなければ、分散型VCSはこれほど急速に受け入れられなかっただろう。技術的には集中型の改善で対処する道もあったが、OSSコミュニティは「改善」ではなく「パラダイムの転換」を選んだ。

### 次回予告

分散型VCSの思想と先駆者たちを見てきた。次回は、その思想が爆発的に現実化する契機となった事件を追う。

**第13回「BitKeeper事件——Linuxカーネルとプロプライエタリの衝突」**

2002年、Linuxカーネル開発はBitKeeperを採用した。プロプライエタリなツールでOSSの象徴であるLinuxカーネルを管理する——この矛盾は、多くのコミュニティメンバーにとって受け入れがたいものだった。そして2005年4月、Andrew Tridgell（Samba開発者）によるリバースエンジニアリング疑惑をきっかけに、BitMover社はLinuxカーネル開発者への無償ライセンスを打ち切った。

この事件が、Linus TorvaldsにGitを作らせた。OSSの自由とツール選択の関係を根本から問い直す出来事の全貌を、次回は語る。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Wikipedia, "Sun WorkShop TeamWare." <https://en.wikipedia.org/wiki/Sun_WorkShop_TeamWare>
- Wikipedia, "Larry McVoy." <https://en.wikipedia.org/wiki/Larry_McVoy>
- Wikipedia, "BitKeeper." <https://en.wikipedia.org/wiki/BitKeeper>
- GNU Project, "GNU arch." <https://www.gnu.org/software/gnu-arch/>
- Wikipedia, "GNU arch." <https://en.wikipedia.org/wiki/GNU_arch>
- LWN.net, "Version Control with GNU Arch." <https://lwn.net/Articles/125792/>
- LWN.net, "The Monotone version control system." (2005年4月) <https://lwn.net/Articles/132000/>
- Hoare, G., "Monotone." GitHub (historical snapshot). <https://github.com/graydon/monotone>
- Wikipedia, "Darcs." <https://en.wikipedia.org/wiki/Darcs>
- Roundy, D., "Darcs: distributed version management in haskell." Haskell '05. <https://www.researchgate.net/publication/221562944_Darcs_distributed_version_management_in_haskell>
- Wikipedia, "GNU Bazaar." <https://en.wikipedia.org/wiki/GNU_Bazaar>
- Vernooij, J., "Bazaar-NG: 7 years of hacking on a distributed version control system." <https://www.jelmer.uk/pages/bzr-a-retrospective.html>
- Wikipedia, "Mercurial." <https://en.wikipedia.org/wiki/Mercurial>
- MacKall, M., "A Short History of Version Control." Architecture of Open Source Applications, Vol. 1. <https://aosabook.org/en/v1/mercurial.html>
- Wikipedia, "Distributed version control." <https://en.wikipedia.org/wiki/Distributed_version_control>
- Sink, E., "DVCS and DAGs, Part 1." <https://ericsink.com/entries/dvcs_dag_1.html>
- IPFS Docs, "Merkle Directed Acyclic Graphs (DAG)." <https://docs.ipfs.tech/concepts/merkle-dag/>
