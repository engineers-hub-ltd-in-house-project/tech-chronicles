# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第3回：SCCS/RCS——自動化への第一歩

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 世界最初のバージョン管理ツールSCCS（1972年）が解決しようとした問題
- RCS（1982年）がSCCSをどう改良したか——リバースデルタという発明
- インターリーブドデルタとリバースデルタの技術的違い
- ファイルロック方式の設計思想とそのトレードオフ
- RCSの実際の操作（ci/co/rcsdiff）を通じて「履歴の自動記録」を体感する

---

## 1. 「なるほど」と「でもこれは……」

前回、私はdiff/patchだけではバージョン管理にならないことを示した。ファイルの追加・削除・リネームの追跡、メタデータの管理、並行する変更の自動統合——これらはdiff/patchの守備範囲の外にある。

だが、そう結論づけたとき、一つの疑問が残ったはずだ。では、その「守備範囲の外」に最初に踏み込んだのは誰なのか。

私がRCSに初めて触れたのは、2000年代の初めだった。正確な年は覚えていないが、あるプロジェクトで先輩エンジニアが使っているのを見たのが最初だ。

先輩は設定ファイルを編集する前に `co -l config.h` と打ち、編集が終わると `ci -u config.h` と打った。そのたびに "enter log message" とプロンプトが出て、先輩は「VirtualHost追加」のような短いメッセージを入力していた。

「何をしているんですか」と聞くと、「履歴を残している」と言われた。`rlog config.h` を実行すると、いつ、誰が、何のために変更したかが時系列で表示された。

「なるほど」と思った。これは `httpd.conf.bak` とは次元が違う。変更の内容だけでなく、変更の理由が記録される。しかも自動的に。日付も、ユーザ名も、差分も、すべてツールが管理してくれる。

だが、同時に「でもこれは……」とも思った。

先輩は、そのファイルを編集している間、同じファイルを別の人が編集できないようにしていた。`co -l` の `-l` はロック（lock）の意味だ。先輩がロックを解除するまで、私はそのファイルに触れない。

3人のチームで1つの設定ファイルを管理しているうちはまだいい。だが、10人のチームで100のファイルを管理するようになったらどうなるか。「あのファイル、誰がロックしてるの？」「ロック解除してくれないと作業が進まない」——そういう問題が容易に想像できた。

RCSは確かに `httpd.conf.bak` の世界を終わらせた。しかし、RCSが解いた問題と同じくらいの大きさの、新しい問題を生み出していた。

最初のバージョン管理ツールは、何を「自動化」したかったのか。そして、何を自動化できて、何を自動化できなかったのか。それを知るためには、RCSより10年遡る必要がある。

---

## 2. 「差分保存」というアイデアの誕生

### SCCS——最初の一歩（1972年）

バージョン管理ツールの歴史は、1972年に始まる。

Bell LabsのMarc Rochkindは、SCCS（Source Code Control System）を開発した。実装言語はSNOBOL4、ターゲットプラットフォームはIBM System/370（OS/360 MVT）だった。翌1973年、RochkindはSCCSをC言語で書き直し、UNIX（PDP-11）上で動作するようにした。

Rochkindがこのツールを作った動機は明確だった。1975年にIEEE Transactions on Software Engineeringに発表した論文 "The Source Code Control System" で、彼はソースコード管理における4つの問題を挙げている。すべてのバージョンの保存、変更履歴の記録、変更権限の制御、バージョンの識別だ。

これらは、前回の記事で私がdiff/patchでは解けないと列挙した問題群と、ほぼ一致する。Rochkindは1972年の時点で、この問題群を体系的に認識し、解決策をソフトウェアとして実装した最初の人物だった。

ここで、当時の計算機環境を想像してほしい。1972年のIBM System/370は、メモリが数百KBから数MBの範囲だった。ディスクストレージのコストは現代と比較にならないほど高価だった。この環境で、ソースコードの「すべてのバージョンを保存する」とは、どういう設計判断を意味するか。

全バージョンをそのまま保存するのは論外だ。1,000行のファイルに100回の変更を加えたら、10万行分のストレージが必要になる。実際には変更されるのは各回数行から数十行程度だ。変わっていない部分まで毎回保存するのは、ストレージの無駄以外の何物でもない。

Rochkindの解答は「差分だけを保存する」というアイデアだった。diffが二つのファイルの差分を計算できるなら、初期バージョンと差分の列を保持するだけで、すべてのバージョンを再構成できる。これが「デルタ」（delta = 変化量）という概念の原型だ。

だが、「差分をどう保存するか」の設計には選択肢がある。SCCSが採用した方式は、後から振り返ると、かなり独特なものだった。

### インターリーブドデルタ——すべてを織り込む

SCCSが採用したデルタ保存方式は、**インターリーブドデルタ**（interleaved delta）、別名「weave」（織り込み）と呼ばれる。

この方式は、全リビジョンの全行を一つのデータブロックに「織り込む」。各行の前後に制御命令を挿入し、その行がどのリビジョンに属するかを示す。

具体的には、3種類の制御行がある。

```
^AI serial    挿入ブロックの開始（serialはデルタの通し番号）
^AD serial    削除ブロックの開始
^AE serial    ブロックの終了
```

例を見よう。あるファイルの初期バージョン（デルタ1）が以下だとする。

```
Hello, World!
Goodbye, World!
```

次のバージョン（デルタ2）で、2行目を変更したとする。

```
Hello, World!
Farewell, World!
```

SCCSのweaveファイルには、こう記録される。

```
^AI 1
Hello, World!
^AD 2
Goodbye, World!
^AE 2
^AI 2
Farewell, World!
^AE 2
^AE 1
```

デルタ1を取り出すには、serial 1に属する行を拾い、serial 2の削除ブロックを無視する。デルタ2を取り出すには、serial 2の削除対象を除外し、serial 2の挿入ブロックを含める。

この設計には重要な特性がある。**どのリビジョンを取り出しても、処理時間がほぼ均一**だということだ。最新版でも最初期の版でも、ファイル全体を一度走査するだけでよい。

一方で、リビジョンが増えるほどweaveファイル自体が大きくなる。100回変更が加わったファイルのweaveを走査する時間は、10回変更が加わったファイルのそれよりも長い。しかし、「最新版が速い」「古い版が遅い」という偏りは生じない。

### SCCSの管理ファイル——s.ファイル

SCCSは管理対象のファイルごとに、`s.filename` という名前の管理ファイルを生成する。元のファイル名の前に `s.` を付ける命名規則だ。

s.ファイルは6つのセクションで構成される。

```
+-------------------+
| チェックサム       |  エラー検出用の文字数合計
+-------------------+
| デルタテーブル     |  各変更の日時・ユーザ名・統計情報
+-------------------+
| ユーザ名リスト     |  変更権限を持つユーザの一覧
+-------------------+
| フラグ             |  内部キーワードの定義
+-------------------+
| コメント           |  ファイルに関する説明情報
+-------------------+
| ボディ             |  テキスト行と制御行の混在（weave）
+-------------------+
```

注目してほしいのは、デルタテーブルに「日時」と「ユーザ名」が記録される点だ。これこそが、diff/patchにはなかったメタデータの自動記録であり、SCCSが「バージョン管理ツール」と呼ばれる所以だ。

「いつ」「誰が」変更したかが、人間の記憶ではなくファイルに刻まれる。そしてデルタコマンドを実行するたびに「なぜ変更したか」のコメントを求められる。変更の内容（what）、変更者（who）、変更日時（when）、変更理由（why）——バージョン管理の四つのWが、ここで初めて自動的に記録されるようになった。

### RCS——10年後の改良（1982年）

SCCSから10年後、Purdue UniversityのWalter F. TichyがRCS（Revision Control System）を発表した。

TichyがRCSを設計した動機には、いくつかの層がある。技術的には、SCCSのデルタ保存方式を改良し、最も頻繁に使われる最新リビジョンの取り出しを高速化したかった。実用的には、SCCSがAT&Tのプロプライエタリソフトウェアだったため、自由に使える代替手段が必要だった。

TichyのRCSに関する技術レポートは1982年3月にPurdue Universityから発表され、論文 "RCS—A System for Version Control" は1985年にSoftware—Practice and Experience誌に掲載された。

RCSがSCCSに対して行った最大の技術的改良は、**リバースデルタ**（reverse delta）方式の導入だ。

### リバースデルタ——「最新が速い」という設計判断

SCCSのインターリーブドデルタは、全リビジョンに均一なアクセス時間を提供する。だがTichyは、現実の開発においてすべてのリビジョンが同じ頻度で参照されるわけではないことに着目した。

圧倒的に多いのは、最新リビジョンの参照だ。開発者がファイルをチェックアウトするとき、ほとんどの場合は最新版を取り出す。古いリビジョンを参照するのは、バグの原因を調べるときや、以前の実装を確認するときくらいだ。

RCSのリバースデルタ方式は、この現実を設計に反映した。

- **トランク（幹）の最新リビジョン**を完全な形で保存する
- それより古いリビジョンは、**逆方向のデルタ**（新しい版から古い版への差分）として保存する
- ブランチ（枝）には**フォワードデルタ**（分岐点から先への差分）を使用する

```
リビジョン番号:  1.1  ←  1.2  ←  1.3  ←  1.4（完全保存）
                  ↑       ↑       ↑
              リバース  リバース  リバース
              デルタ    デルタ    デルタ
```

最新リビジョン（1.4）を取り出すには、保存されたテキストをそのままコピーするだけだ。これは事実上O(1)の操作である。

1.3を取り出すには、1.4に1つのリバースデルタを適用する。1.2なら2つ、1.1なら3つのデルタを適用する。古いリビジョンほど時間がかかるが、Tichyの洞察通り、古いリビジョンが参照される頻度は低い。

SCCSのweave方式と比較すると、トレードオフの構造が見える。

```
              SCCSのweave        RCSのリバースデルタ
最新版取出し  ファイル全体走査    単純コピー（高速）
古い版取出し  ファイル全体走査    デルタ連鎖適用（遅い）
アノテーション 追加コスト不要     全デルタ走査が必要
均一性        全バージョン均一    最新版が最速、古い版ほど遅い
```

どちらが「正しい」かは、使われ方次第だ。SCCSの設計は「どのバージョンも等しく重要」という前提に立ち、RCSの設計は「最新バージョンが最も重要」という前提に立つ。後者の前提が多くの現場で正しかったことが、RCSの普及につながった。

### ,v ファイル——RCSの管理単位

RCSは管理ファイルを `filename,v` という名前で生成する。SCCSの `s.filename` に相当するものだ。あるいは、作業ディレクトリに `RCS/` というサブディレクトリを作り、そこに ,v ファイルを格納することもできる。

,v ファイルの内部構造は、SCCSのs.ファイルとは異なる。最新リビジョンの完全なテキストが格納され、それに加えてメタデータ（各リビジョンの日時、著者、ログメッセージ）と、古いリビジョンへのリバースデルタが含まれる。

RCSのデルタは行ベースの編集コマンドで構成される。操作は「行の追加」と「行の削除」の2種類のみだ。これはdiffの出力と本質的に同じ形式であり、diffの技術がバージョン管理の内部表現に直結していることがわかる。

---

## 3. ロック方式の設計思想——「同時に触るな」

### なぜロックが必要だったのか

SCCSとRCSが共有するもう一つの重要な設計判断がある。ファイルロック方式だ。

ファイルをチェックアウト（取り出し）して編集するとき、そのファイルに「ロック」をかける。ロックされたファイルは、ロックを持つユーザだけが変更をチェックイン（記録）できる。他のユーザは読み取り専用でしかアクセスできない。

なぜこの設計が採用されたのか。1970年代から1980年代の開発環境を考えれば、理にかなっている。

第一に、自動マージの技術がまだ未成熟だった。二人が同じファイルの同じ箇所を変更した場合、その衝突を自動的に解決する信頼できるアルゴリズムが確立されていなかった。diff3（3-way merge）は存在したが、全自動で安全にマージできるケースは限られていた。

第二に、開発チームが物理的に同じ場所にいるのが普通だった。隣の席の人に「あのファイル使い終わったら教えて」と声をかけるのは、技術的な問題ではなく日常のコミュニケーションだった。

第三に、ファイル単位のロックは実装が単純だった。SCCSは `p.filename` というロックファイルを生成するだけだ。複雑なマージロジックは不要で、競合状態は原理的に発生しない。

### SCCSのロック——get -e と delta

SCCSでは、`get` コマンドでファイルを取り出す。読み取り専用で取り出す場合は単に `get s.filename` とする。編集用に取り出す場合は `get -e s.filename`（-eはeditの意）とし、このとき排他ロックが設定される。

ロックの情報は `p.filename` というファイルに記録される。他のユーザが同じファイルを `get -e` しようとすると、エラーになる。

編集が終わったら `delta s.filename` でチェックインし、ロックが解放される。編集を取り消す場合は `unget s.filename` でロックだけを解放する。

ロックされたファイルを緊急に解除する必要がある場合——たとえば、ロックした人が休暇に出てしまった場合——は、特権ユーザ（管理者）が介入する必要があった。このとき、ロック保持者に通知が送られる仕組みはなかった。

### RCSのロック——co -l と ci

RCSのロック機構は、SCCSを踏襲しつつ、いくつかの改善を加えた。

チェックアウトは `co filename` または `co filename,v`、ロック付きチェックアウトは `co -l filename`。チェックインは `ci filename`。ここで注目すべきは、RCSがSCCSの操作体系を改善した点だ。SCCSではs.ファイル名を指定する必要があったが、RCSでは作業ファイル名でも ,v ファイル名でも指定できる。ユーザは管理ファイルの存在を意識せずに操作できる。

RCSはさらに、**strict locking** モードと **non-strict** モードを選択できるようにした。`rcs -L filename` でstrict lockingを有効にすると、チェックインには必ずロックが必要になる。`rcs -U filename` でnon-strictにすると、ファイルの所有者はロックなしでもチェックインできる。個人で使うファイルにはnon-strict、複数人で共有するファイルにはstrictという使い分けが可能だ。

もう一つの改善は、ロック破棄の仕組みだ。SCCSでは特権ユーザのみがロックを解除できたが、RCSでは一般ユーザでもロックを破棄（break）できる。その際、ロック保持者にメール通知が送られる。これは小さな改善に見えるが、実際の開発現場では大きな違いだった。「管理者に連絡してロック解除してもらう」という手順が「自分で解除して、相手にメールで通知する」に変わるだけで、作業の流れが格段にスムーズになる。

### ロック方式のトレードオフ

ファイルロック方式は、並行編集の衝突を**防止する**。衝突が起きてから解決するのではなく、衝突が起きない状態を保証する。これは悲観的並行制御（pessimistic concurrency control）と呼ばれるアプローチだ。

対照的に、後のCVSやgitが採用した方式は、楽観的並行制御（optimistic concurrency control）だ。誰でも自由に変更でき、衝突が起きたときにマージで解決する。

悲観的制御の利点は明確だ。衝突解決のコストがゼロになる。二人が同じファイルの同じ行を変更して、手動マージに30分かかる——そういう事態は原理的に発生しない。

だが代償もある。並行性が犠牲になる。一つのファイルを同時に一人しか編集できないという制約は、チームの規模が大きくなるほど深刻なボトルネックになる。「あのファイルを触りたいが、Aさんがロックしている」「Aさんは別の作業中で、今日中には解除されない」——こういう待ち行列が日常的に発生する。

さらに、SCCS/RCSのロックは**ファイル単位**だ。一つのファイルの中で、まったく関係のない二つの関数をそれぞれ別の人が同時に修正したい場合でも、ファイル全体がロックされる。「同じファイルの別の箇所を触るだけなのに、順番待ちが必要」という状況は、開発者のフラストレーションの源泉となった。

この問題が、後のCVSの「Copy-Modify-Merge」モデルへの移行を強く動機づけた。だが、それは第4回以降の話だ。

---

## 4. ハンズオン：RCSを手で触り、「履歴の自動記録」を体感する

ここからは実際にRCSを動かす。2020年代にRCSを使う実務上の理由はない。だが、gitの `git init`、`git add`、`git commit`、`git log`、`git diff` という一連の操作が、RCSの `ci`、`co`、`rlog`、`rcsdiff` の直系の子孫であることを体感してほしい。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y rcs

# Ubuntu / Debian の場合
# sudo apt install rcs

# macOS の場合（Homebrew）
# brew install rcs
```

RCSのインストールにより、ci、co、rlog、rcsdiff、rcsmerge、rcsclean などのコマンドが使えるようになる。

### 演習1：最初のチェックイン——履歴の記録が始まる瞬間

```bash
WORKDIR="${HOME}/vcs-handson-03"
mkdir -p "${WORKDIR}"
cd "${WORKDIR}"

# RCS管理ファイルを格納するディレクトリを作成
mkdir -p RCS

# 最初のファイルを作成
cat > hello.c << 'EOF'
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
EOF

# 最初のチェックイン
# -i: 初期チェックイン（新規ファイル）
# -t-: 説明テキストを標準入力から読まない
ci -i -t-"A simple greeting program" -m"Initial version" hello.c
```

`ci` は "check in" の略だ。このコマンドを実行すると、二つのことが起きる。

第一に、`RCS/hello.c,v` という管理ファイルが生成される。ここに、ファイルの完全なテキスト、メタデータ（日時、ユーザ名、ログメッセージ）が記録される。

第二に、作業ファイル `hello.c` が**削除される**。これはRCSの流儀だ。「チェックインしたファイルはリポジトリに預けた」という意味で、作業コピーは消える。gitに慣れた目には奇異に映るが、「ソースの正本は管理ファイルの中にある」という思想の表れだ。

### 演習2：チェックアウトと再チェックイン——編集サイクルを回す

```bash
# ロック付きチェックアウト（編集するため）
co -l hello.c
```

`co` は "check out" の略だ。`-l` オプションでロックを取得する。これで `hello.c` が作業ディレクトリに復元され、かつ排他ロックがかかる。

ファイルを編集する。

```bash
cat > hello.c << 'EOF'
#include <stdio.h>

int main(int argc, char *argv[]) {
    const char *name = (argc > 1) ? argv[1] : "World";
    printf("Hello, %s!\n", name);
    return 0;
}
EOF

# 変更内容を確認
rcsdiff hello.c
```

`rcsdiff` は、作業ファイルと管理ファイル内の最新リビジョンとの差分を表示する。gitの `git diff` に相当する。

```bash
# チェックイン（ロック解除 + 作業ファイル維持）
ci -u -m"Add command-line argument support" hello.c
```

`-u` オプションは「チェックイン後に、ロックなしのチェックアウトを自動で行う」という意味だ。つまり、作業ファイルが削除されずに残る（ただし読み取り専用）。`-m` でログメッセージを指定する。

### 演習3：履歴を見る——rlog

```bash
rlog hello.c
```

この出力が、バージョン管理の本質を凝縮している。各リビジョンについて、日時、著者、ログメッセージ、変更行数（追加/削除）が記録されている。

`httpd.conf.bak` の世界では、「いつ変えたか」はファイルのタイムスタンプに頼るしかなかった。「誰が変えたか」は記録されなかった。「なぜ変えたか」は人間の記憶に委ねられていた。RCSはこれらすべてを、チェックインのたびに自動的に記録する。

```bash
# 特定リビジョンの内容を表示
co -p -r1.1 hello.c
```

`-p` はファイルを復元せず標準出力に表示するオプション、`-r1.1` はリビジョン1.1を指定する。過去の任意の時点のファイル内容を、いつでも正確に再現できる。

### 演習4：ロックの衝突を体験する

RCSのファイルロックを実際に体験する。一人で二つの「人格」を演じる。

```bash
# もう一つ変更を加える
co -l hello.c
cat > hello.c << 'EOF'
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    const char *name = (argc > 1) ? argv[1] : "World";
    printf("Hello, %s!\n", name);
    if (strcmp(name, "World") != 0) {
        printf("Nice to meet you!\n");
    }
    return 0;
}
EOF
ci -u -m"Add personalized greeting" hello.c

# 現在のロック状態を確認
rlog -L hello.c
```

ここで、二人目の開発者のつもりで、同じファイルを編集しようとする。

```bash
# ロック付きチェックアウトを試みる
# 現在ロックされていなければ成功する
co -l hello.c

# 編集中にロック状態を確認
rlog -L -R hello.c
```

もし別のユーザがすでにロックしていた場合、`co -l` はエラーメッセージを出して失敗する。これがファイルロック方式の現実だ。ファイルを編集したいのに、誰かがロックしているために待たされる。

### 演習5：rcsdiffでリビジョン間の差分を見る

```bash
# リビジョン1.1と1.2の差分
rcsdiff -r1.1 -r1.2 hello.c

# リビジョン1.1と最新の差分
rcsdiff -r1.1 hello.c
```

この操作は `git diff HEAD~2 HEAD~1` や `git diff HEAD~2` に直接対応する。gitが提供する差分表示機能は、RCSのrcsdiffの延長線上にある。

### 演習6：,v ファイルの中身を覗く

最後に、RCSの管理ファイルの中身を見てみよう。

```bash
cat RCS/hello.c,v
```

出力の冒頭にメタデータ（リビジョン番号、日時、著者名、ログメッセージ）があり、その後に最新リビジョンのテキスト全文がある。さらにその後に、古いリビジョンへのリバースデルタが続く。

テキストは `@` で囲まれている。これはRCSのファイル形式の規則で、テキスト中に `@` が出現する場合は `@@` にエスケープされる。

リバースデルタの部分を見ると、`d` で始まる行（削除指示）と `a` で始まる行（追加指示）が並んでいる。これが「最新版から一つ前の版への逆方向の差分」だ。

この構造を理解すると、RCSの動作原理が透けて見える。最新版の取り出しはテキスト全文のコピー、古い版の取り出しはデルタの逐次適用。シンプルで、予測可能で、テキストファイルとして直接読める。gitの .git/objects/ に格納されるバイナリオブジェクトとは対照的に、RCSの管理ファイルは人間が目で読める形式になっている。

---

## 5. まとめと次回予告

### この回の要点

第一に、バージョン管理ツールの歴史は1972年に始まる。Bell LabsのMarc Rochkindが開発したSCCS（Source Code Control System）が、ソースコードの変更履歴を自動的に記録する最初のツールだった。RochkindはIBM System/370上のSNOBOL4で初期版を実装し、翌年C言語でUNIXに移植した。

第二に、SCCSのインターリーブドデルタ（weave）方式は、全リビジョンの行を制御命令とともに一つのファイルに織り込む。どのリビジョンを取り出しても処理時間は均一だが、リビジョンが増えるほどファイル全体が大きくなる。10年後のRCS（Walter F. Tichy、1982年、Purdue University）はリバースデルタ方式を導入し、最も頻繁に使われる最新リビジョンの取り出しを高速化した。

第三に、SCCS/RCSはファイルロック方式——悲観的並行制御——を採用した。衝突を防止する代わりに並行性を犠牲にする設計判断であり、チームの規模が大きくなるとボトルネックになった。RCSはロック破棄時のメール通知など細部を改善したが、根本的な問題は解消されなかった。

第四に、SCCS/RCSの操作体系（チェックイン、チェックアウト、差分表示、履歴表示）は、現代のgitの操作体系の直接的な祖先だ。`ci` → `git commit`、`co` → `git checkout`、`rcsdiff` → `git diff`、`rlog` → `git log`。概念の連続性を体感することで、gitの操作が「天から降ってきた」ものではなく、50年以上の試行錯誤の蓄積であることがわかる。

### 冒頭の問いへの暫定回答

最初のバージョン管理ツールが「自動化」したかったのは、変更の四つのW——What（何を変えたか）、Who（誰が変えたか）、When（いつ変えたか）、Why（なぜ変えたか）——の記録だ。

SCCSとRCSは、この自動記録を実現した。だが、「単一ファイルの」履歴管理に限定された。プロジェクト全体の複数ファイルにまたがる変更を一つの単位として管理する機能——後にアトミックコミットと呼ばれるもの——は持っていなかった。そして、ファイルロック方式は「複数人が同じファイルを同時に触る」問題を、禁止することで「解決」した。禁止は解決ではない。

### 次回予告

次回は、SCCS/RCSの限界を超えようとした人物の話だ。

1986年、オランダのVrije Universiteit AmsterdamのDick Gruneが、RCSのラッパースクリプトとしてCVS（Concurrent Versions System）の原型を開発した。「Concurrent」——並行——という名前が示す通り、CVSはRCSのファイルロック方式を捨て、「Copy-Modify-Merge」モデルを採用した。ロックせず、自由にコピーし、自由に変更し、変更を後からマージする。

さらに1989年、Brian BerlinerがCVSをC言語で書き直し、ネットワーク対応の本格的なバージョン管理ツールに仕立て上げた。これにより、物理的に離れた場所にいる開発者が、同じリポジトリに対して作業できるようになった。

**第4回「CVSの誕生——RCSの限界を超えて」**

ロックを捨てた代わりに、CVSは何を得て、何を新たに背負い込んだのか。そして「リポジトリ」という概念が、なぜバージョン管理の歴史で決定的に重要だったのか。あなたが `git clone` で何気なく取得するリポジトリの概念は、どこから来たのだろうか。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Rochkind, M. J., "The Source Code Control System," IEEE Transactions on Software Engineering, Vol. SE-1, No. 4, pp. 364-370, December 1975. <https://dl.acm.org/doi/10.1109/TSE.1975.6312866>
- Rochkind, M. J., "A Retrospective on the Source Code Control System," IEEE Transactions on Software Engineering, 2024. <https://www.mrochkind.com/mrochkind/docs/SCCSretro2.pdf>
- Tichy, W. F., "RCS—A System for Version Control," Software—Practice and Experience, Vol. 15, No. 7, pp. 637-654, July 1985. <https://www.gnu.org/software/rcs/tichy-paper.pdf>
- GNU RCS Manual, Version 5.10.1. <https://www.gnu.org/software/rcs/manual/rcs.html>
- Oracle Solaris Documentation, sccsfile(4). <https://docs.oracle.com/cd/E86824_01/html/E54775/sccsfile-4.html>
- BitKeeper Documentation, "Document the SCCS weave." <https://www.bitkeeper.org/src-notes/SCCSWEAVE.html>
- Wikipedia, "Interleaved deltas." <https://en.wikipedia.org/wiki/Interleaved_deltas>
