# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第24回：git ありきの世界に改めて問う——あなたは何を選ぶか

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- バージョン管理の50年史が示す「最適解は常に変わる」という教訓
- Everett Rogersの「イノベーションの普及」理論から見たGitの現在地
- Chesterton's FenceとLindy Effect——技術選定における二つのヒューリスティック
- Architecture Decision Records（ADR）を用いた技術選定の記録手法
- 自分のチーム・プロジェクトに最適なVCS/ワークフローを選定するための評価マトリクス

---

## 1. 連載を書き終えて

第1回の冒頭で、私はある若手エンジニアとの会話を書いた。「gitの前って、何を使ってバージョン管理してたか知ってる？」と聞いたとき、彼の目に浮かんだ、歴史の授業で「鎌倉幕府」を聞かれたときのような表情。自分とは無関係な過去の出来事を答える色。

あれから23回、SCCSからJujutsuまで、50年以上のバージョン管理の歴史を辿ってきた。

この連載を書く中で、私自身が最も驚いたのは、自分の24年間のキャリアを言語化する過程で見えてきたものだった。CVSのCopy-Modify-Mergeモデルに感動した2000年代前半の自分。Subversionのアトミックコミットに安堵した2000年代後半の自分。Gitの分散モデルに戸惑い、やがてその設計思想の深さに打たれた2010年代の自分。そして今、JujutsuやSaplingの登場に、あの頃と同じ知的興奮を覚えている自分。

振り返ってみれば、私のキャリアはバージョン管理の進化と並走していた。それぞれの時代で「これが最適解だ」と信じていたものが、次の時代には「あの頃の制約下での最善」に変わっていった。CVSが最適だった時代があり、Subversionが最適だった時代があり、Gitが最適な時代がある。そして、Gitが最適でなくなる時代も、おそらく来る。

この連載を通じて、私が伝えたかったのはこのことだ。最適解は常に変わる。だが、問いは変わらない。

第23回で整理した「三つの本質」——変更の記録（What changed?）、協調の仕組み（Who changed it, and how do we integrate?）、歴史の保存（Why did it change?）——は、SCCSの時代も、Gitの時代も、そしてGitの次の時代も、バージョン管理が答えるべき問いであり続ける。

最終回となる今回は、この連載で得た知識を「明日からどう活かすか」を考える。技術史は過去の話ではない。未来を選ぶための道具だ。

あなたは今日、バージョン管理に何を使っているだろうか。そして、なぜそれを「選んでいる」と言えるだろうか。

---

## 2. 歴史が教えてくれること——「最適解は常に変わる」

### 50年の変遷を俯瞰する

この連載で辿った50年の歴史を、改めて一望してみよう。

1972年、Marc J. RochkindがBell LabsでSCCSを開発した。単一ファイルの変更履歴を、インターリーブドデルタで記録する仕組みだった。当時のコンピューティング環境——単一マシン、限られたストレージ、ネットワークなし——の中で、SCCSは「変更の記録」という最初の問いに答えた。

1982年、Walter F. TichyがPurdue大学でRCSを発表した。リバースデルタ方式を採用し、最新バージョンへのアクセスを高速化した。だが、SCCSもRCSも、ファイル単位の管理とロック方式の並行制御という制約を持っていた。

1986年、Dick GruneがCVSを公開した。RCSの上にネットワーク層とCopy-Modify-Mergeモデルを構築し、「協調の仕組み」に革命をもたらした。複数の開発者が同じファイルを同時に編集し、後からマージできるようになった。SourceForgeの全盛期、CVSはOSS開発のデファクトスタンダードだった。

2000年、CollabNetのKarl FogelとBen Collins-Sussmanが「CVS done right」を掲げてSubversionの開発を始めた。アトミックコミット、ディレクトリのバージョン管理、連番リビジョン番号——CVSの欠点を一つずつ潰していった。Subversionは、集中型VCSの完成形だった。

2005年、Linus TorvaldsがGitを開発した。BitKeeper問題をきっかけに、分散型VCSの思想を極限まで推し進めた設計だった。コンテンツアドレッサブルストレージ、DAGによるコミット管理、ブランチ＝ポインタ——Gitは、バージョン管理の三つの本質すべてに対して、根本的に新しい解を提示した。

2008年、GitHubがローンチした。GitにソーシャルコーディングとPull Requestモデルを加え、Gitの普及を決定的にした。2025年、GitHubの登録開発者数は1億人を超え、リポジトリ数は10億に達した。

そして今、Jujutsu、Sapling、Pijulといった次世代VCSが、Gitでは解決しきれない問題——ステージングエリアの複雑さ、コンフリクトの扱いにくさ、巨大リポジトリのスケーリング——に取り組んでいる。

50年の歴史が教えてくれるのは、単純だが深い教訓だ。どの時代のエンジニアも、自分たちが使っているツールを「最適解」だと信じていた。そして、その信念はその時代においては正しかった。だが、永遠に正しかったわけではない。

### 技術の普及パターン——Rogersのモデルで見るGit

Everett Rogersは1962年の著書『Diffusion of Innovations』で、技術の普及を5段階の採用者カテゴリで説明した。イノベーター（冒険的な2.5%）、アーリーアダプター（尊敬される13.5%）、アーリーマジョリティ（慎重な34%）、レイトマジョリティ（懐疑的な34%）、ラガード（伝統的な16%）。

Rogersのモデルをバージョン管理の歴史に当てはめると、興味深いパターンが見える。

Gitの場合、2005年の誕生から2008年のGitHub登場までがイノベーター期だった。Linuxカーネル開発者やOSSコミュニティの先鋭的な層が、既存のSubversionやMercurialからGitに移行した。2008年から2012年頃がアーリーアダプター期。GitHubのPull Requestモデルに共感した開発者たちが、プロジェクト単位でGitを採用し始めた。2012年から2018年頃がアーリーマジョリティ期。企業での大規模採用が進み、「新規プロジェクトはGit」がデフォルトになった。2018年のMicrosoftによるGitHub買収以降、レイトマジョリティの採用が加速し、2025年のStack Overflow Developer Surveyでは開発者の93%以上がGitを使用するに至った。

ここで考えるべきは、Gitが普及曲線の飽和域に達しているという事実だ。93%という数字は、「ほぼ全員が使っている」ことを意味する。これ以上の普及率向上は構造的に困難だ。

Rogersは、技術の普及速度に影響する5つの特性を指摘した。相対的優位性（既存技術より良いか）、互換性（既存の価値観や慣行と適合するか）、複雑性（理解や利用が容易か）、試行可能性（小規模に試せるか）、観察可能性（効果が目に見えるか）。

Gitがこれほど普及した理由は、GitHubという「観察可能性の増幅装置」によって、Gitの利点が目に見える形で示されたことが大きい。OSSプロジェクトの活発なコミット履歴、Pull Requestでのコードレビュー、貢献者のグラフ——これらはGitの利点を可視化し、採用の動機を生んだ。

だが、飽和域に達した技術には、別の力学が働き始める。新しい参入者は「Gitを選んだ」のではなく「Gitしかなかった」のだ。選択ではなく前提。これは、まさに第1回で私が問題提起した状況だ。

### Chesterton's Fence——「なぜそこにあるか」を理解する

G.K. Chestertonは1929年に、あるシンプルだが深い原則を書いた。道の真ん中にフェンスが立っているのを見つけたとする。「改革者」は「このフェンスは無用だ、撤去しろ」と言う。だが、より知的な改革者はこう言う——「なぜこのフェンスがここにあるのか分からないなら、撤去を許可するわけにはいかない。理由を見つけてから来い」。

この原則は、技術選定にそのまま適用できる。

「なぜうちのチームはGitを使っているのか」と聞かれたとき、「みんなが使っているから」以上の理由を説明できるだろうか。あるいは逆に、「Gitをやめて新しいツールに移行しよう」と提案するとき、Gitが現在果たしている役割——CI/CDパイプラインとの統合、コードレビューのワークフロー、デプロイメントの仕組み——をすべて理解した上での提案だろうか。

Chesterton's Fenceの教訓は二つある。

一つは、既存の技術選定には、見えない理由があるかもしれないということだ。企業がSubversionを使い続けている理由は、単なる「惰性」ではないかもしれない。パスベースのアクセス制御が必要かもしれない。巨大バイナリファイルの管理がGit LFSでは不十分かもしれない。部分チェックアウトが業務上不可欠かもしれない。第11回で論じた通り、Subversionには今なおGitに対して優位な領域がある。

もう一つは、「フェンスの理由を理解した上でなら、撤去してよい」ということだ。理由を知ることは、変更を禁じることではない。理由を知った上で、その理由がもはや有効でないと判断するなら、変更は正当化される。CVSからSubversionへの移行は、CVSの限界を正確に理解した上での正しい判断だった。SubversionからGitへの移行も同様だ。

歴史を知るとは、すべてのフェンスの理由を知ることだ。そうすれば、どのフェンスを残し、どのフェンスを撤去すべきかを、合理的に判断できる。

### Lindy Effect——「生き延びた時間」が語ること

Nassim Nicholas Talebが2012年の著書『Antifragile』で命名した「リンディ効果」は、非消耗品の将来の寿命期待値がその現在の年齢に比例するという経験則だ。10年間使われ続けた技術は、さらに10年使われる可能性が高い。100年間読まれ続けた本は、さらに100年読まれる可能性が高い。

リンディ効果をバージョン管理に適用すると、何が見えるだろうか。

diffアルゴリズムは1976年にHuntとMcIlroyによって開発された。2026年現在で50年だ。リンディ効果に従えば、diffはさらに50年使われ続ける可能性がある。実際、Gitのgit diffも、JujutsuもSaplingも、内部でdiffアルゴリズムを使っている。差分の計算という本質は、ツールが変わっても変わらない。

Gitは2005年に誕生した。21年が経過している。リンディ効果に従えば、Gitはさらに21年以上使われ続ける可能性がある。これは直感にも合う。GitHubのエコシステム、CI/CDとの統合、数十億のリポジトリ——Gitを「置き換える」コストは途方もない。

だが、リンディ効果はあくまでヒューリスティックであり、保証ではない。CVSは1986年から2010年代初頭まで約25年間使われたが、Gitに置き換えられた。リンディ効果が予測する「さらに25年」は実現しなかった。

ここで重要なのは、CVSが置き換えられたのは、CVSが「ダメだった」からではなく、CVSが解いていた問題の「条件が変わった」からだ。ネットワーク帯域が広がり、開発チームが地理的に分散し、OSS開発のモデルがグローバル化した。CVSの設計前提——同一ネットワーク内の中規模チーム——が、もはや現実と合わなくなった。

同じことがGitにも起こりうる。第22回で論じた通り、Gitの設計前提にも限界がある。巨大リポジトリのスケーリング、ステージングエリアの認知的コスト、AIとの協調における著者性の問題。これらの条件が十分に変われば、Gitの次のツールが台頭する可能性はある。

リンディ効果が教えてくれるのは、「Gitはすぐにはなくならない」ということだ。だが、「Gitが永遠に最適であり続ける」とは言っていない。この区別は重要だ。

### Joel Spolskyの警告——全面書き直しの誘惑

2000年4月、Joel Spolskyは「Things You Should Never Do, Part I」というブログ記事で、Netscapeがブラウザのコードを全面的に書き直す決断をしたことを「ソフトウェア企業が犯しうる最悪の戦略的ミス」と批判した。全面書き直しによってNetscape 5.0は欠番となり、約3年のリリース遅延が発生し、Internet Explorerに対する競争優位を失った。

Spolskyの警告は、技術選定にも当てはまる。「Gitを全面的にやめて、新しいVCSに移行する」という判断は、多くの場合、Netscapeの過ちに似た結果を招く。既存のCI/CDパイプライン、コードレビューのワークフロー、デプロイメントの自動化、チームの習熟度——これらすべてを一度に捨てるコストは、新しいツールの利点を容易に上回る。

だが、ここにも例外はある。Linus Torvaldsは2005年にBitKeeperの代替を一から作るという「全面書き直し」を選び、見事に成功した。その成功の条件は明確だった——既存のツールの設計思想そのものが自分の要求と合致しなかったこと、そして自分が解くべき問題を徹底的に理解していたことだ。

Linusは、CVSやSubversionの内部構造を知り尽くした上で、それらとは根本的に異なる設計を選んだ。彼は「フェンスの理由」を完全に理解した上で、意図的にフェンスを撤去したのだ。

全面的な置き換えが正当化されるのは、既存のツールの設計前提そのものが、もはや有効でない場合に限られる。そしてその判断を正しく行うためには、既存のツールがなぜそう設計されたかを深く理解している必要がある。

歴史を知ることは、判断のための前提条件なのだ。

---

## 3. 技術選定のフレームワーク——「なぜそのツールか」を説明できるエンジニアになるために

### 技術選定は「工学的判断」である

この連載を通じて繰り返し強調してきたのは、バージョン管理の選択は好みの問題ではなく、工学的判断だということだ。

工学的判断とは、制約条件の中で最適なトレードオフを選ぶことだ。「最良の選択」は存在しない。「この制約条件の下で、このトレードオフが最も受容可能な選択」が存在するだけだ。

バージョン管理ツールの選定において、考慮すべき制約条件は以下のカテゴリに分類できる。

**プロジェクトの特性。** リポジトリのサイズ、ファイルの種類（テキストかバイナリか）、変更の頻度、ブランチの数と寿命。巨大なモノレポを管理するならGitの限界に突き当たる可能性がある。大量のバイナリアセットを扱うゲーム開発なら、Git LFSの制約が問題になりうる。

**チームの構造。** チームの規模、地理的分散の度合い、コミュニケーションの頻度、スキルレベルの分布。Conway's Lawが示す通り、ツールの設計はチームのコミュニケーション構造と適合する必要がある。5人の同一拠点チームに分散型VCSの全機能が必要かは、真剣に問うべき問題だ。

**エコシステムとの統合。** CI/CDパイプライン、コードレビューツール、プロジェクト管理ツール、デプロイメントシステム。2026年現在、これらのほぼすべてがGitを前提として設計されている。Git以外のツールを選ぶ場合、エコシステムとの統合コストを正確に見積もる必要がある。

**組織のポリシー。** アクセス制御の要件、コンプライアンス、監査の必要性、ライセンスの制約。パスベースの細粒度アクセス制御が求められる環境では、Subversionの方がGitより適している場合がある。

**将来の変化。** チームの成長予測、プロジェクトの拡大方向、技術スタックの進化。今日の最適解が、3年後も最適である保証はない。移行コストを見越した選択が求められる。

### Richard Gabrielの「Worse is Better」——Gitはなぜ勝ったのか

技術選定を考える上で、Richard Gabrielが1989年に提唱した「Worse is Better」の原則は避けて通れない。

Gabrielは、LispとUNIXの設計哲学を対比した。Lispの「MITアプローチ」は、インターフェースの正しさを最優先する。正しさを達成するために、実装がいかに複雑になっても構わない。対するUNIXの「New Jerseyアプローチ」は、実装のシンプルさを最優先する。インターフェースが多少不格好になっても、実装がシンプルであることを重視する。

Gabrielの洞察は、「Worse is Better」なシステムの方が普及しやすいということだった。実装がシンプルであれば、移植が容易であり、多くの環境で動作し、早期に広まり、改善のサイクルが回りやすい。結果として、設計上は「劣って」いても、市場で「勝つ」。

この力学は、バージョン管理の歴史にもそのまま当てはまる。

Subversionは、設計上はCVSよりも「正しい」ツールだった。アトミックコミット、ディレクトリのバージョン管理、リネーム追跡——CVSの欠陥をすべて修正した。だが、SubversionはCVSの後継者であって、パラダイムの革新者ではなかった。

Gitは、多くの面でSubversionよりも「正しくない」ツールだった。初学者にとっての学習曲線は急峻だった。ステージングエリアは概念的に複雑だった。コマンド体系には一貫性が欠けていた。だが、Gitの実装は驚くほどシンプルだった——少なくとも、そのコアモデルは。blob、tree、commit、tagの4オブジェクト。SHA-1ハッシュによるコンテンツアドレッシング。この単純なモデルの上に、あらゆる機能が構築された。

そして、GitHubがGitに「観察可能性」を与えた瞬間、「Worse is Better」の力学が発動した。Gitは急速に普及し、エコシステムが形成され、改善のサイクルが回り始めた。設計上の不格好さ——ステージングエリア、detached HEAD、reflogの複雑さ——は、普及によって「みんなが知っているから問題にならない」状態に変わった。

この力学を理解することは、技術選定において重要だ。「技術的に最も優れたツール」が必ずしも「最適な選択」ではない。エコシステムの成熟度、コミュニティのサイズ、ドキュメントの充実度、人材の確保しやすさ——これらの「外部要因」が、技術的な優劣を容易に覆す。

2026年現在、JujutsuはGitよりも設計上「正しい」ツールだと私は思う。ステージングエリアの廃止、コンフリクトのファーストクラス化、オペレーションログによる完全な操作履歴。だが、Jujutsuがバージョン管理の次の「勝者」になるかどうかは、技術的な優秀さだけでは決まらない。エコシステム、コミュニティ、タイミング——Rogersの5特性とGabrielの力学が、結果を左右する。

### ADR——技術選定の「なぜ」を記録する

Michael Nygardが2011年に提唱したArchitecture Decision Records（ADR）は、アーキテクチャ上の決定とその理由を、構造化された短い文書として記録する手法だ。

ADRの構造はシンプルだ。タイトル、ステータス（提案中・承認済・非推奨など）、コンテキスト（決定に至った背景）、決定（選択した内容）、結果（決定によって生じる影響）。

第23回で論じた「歴史の保存（Why did it change?）」は、コードの変更に関する「なぜ」だった。ADRは、技術的な意思決定に関する「なぜ」を記録する仕組みだ。コミットメッセージがコードの変更理由を記録するように、ADRは技術選定の理由を記録する。

バージョン管理ツールの選定は、ADRで記録すべき典型的な意思決定だ。「なぜGitを使うのか」「なぜGitHub Flowを採用するのか」「なぜモノレポではなくマルチレポを選んだのか」——これらの決定を文書化しておくことで、将来のチームメンバーが「フェンスの理由」を理解できる。

具体的な例を示そう。

```
# ADR-001: バージョン管理システムとしてGitを採用する

## ステータス
承認済（2026-02-16）

## コンテキスト
新規プロジェクトのバージョン管理システムを選定する必要がある。
チームは8名で、うち6名はGitの実務経験が3年以上。
CI/CDにはGitHub Actionsを使用予定。
リポジトリの想定サイズはテキストファイル中心で500MB以下。

## 検討した選択肢
1. Git + GitHub
2. Jujutsu（jj）+ GitHub
3. Subversion

## 決定
Git + GitHubを採用する。

## 理由
- チームの大半がGitに習熟しており、学習コストが最小
- GitHub Actionsとのネイティブ統合がCI/CDの構築を効率化する
- Jujutsuは技術的に魅力的だが、1.0未達のためプロダクション利用にリスク
- プロジェクトの規模ではGitのスケーリング限界に達する見込みがない
- Subversionは分散型ワークフロー（リモートワーク対応）の要件と合わない

## 結果
- Gitの標準的なワークフロー（GitHub Flow）を採用する
- コミットメッセージのフォーマットはConventional Commitsに準拠する
- Jujutsuの成熟度を年次で再評価し、移行の妥当性を検討する
- この決定は、チーム規模が30名を超えた場合に再検討する
```

このADRが存在すれば、2年後に新しくチームに参加したエンジニアが「なぜGitを使っているのか」を理解できる。そして、条件が変わったとき——たとえばリポジトリが巨大化したとき、チームが急拡大したとき——ADRに記録された前提条件を検証し、合理的に再評価できる。

ADRなしには、技術選定の理由は口伝えの「部族の知識」になる。メンバーが入れ替わるたびに、理由は失われる。Chesterton's Fenceの前に立ったとき、なぜそのフェンスがあるのか、誰も答えられない。そうなると、「前からそうだったから」という惰性か、「全部やり直そう」という暴走のどちらかしかなくなる。

### 評価マトリクスの設計

技術選定を構造化するために、バージョン管理ツールの評価マトリクスを設計する。これは、特定のツールを推奨するためのものではない。「自分のプロジェクトにとって何が重要か」を明確にし、合理的な比較を可能にするためのフレームワークだ。

```
VCS評価マトリクス

評価項目                        重み  Git  jj   SVN  Sapling
─────────────────────────────────────────────────────────────
【変更の記録】
  コミットの粒度制御            ___   ___  ___  ___  ___
  バイナリファイル対応          ___   ___  ___  ___  ___
  大規模リポジトリ性能          ___   ___  ___  ___  ___

【協調の仕組み】
  ブランチ/マージの効率         ___   ___  ___  ___  ___
  オフライン作業対応            ___   ___  ___  ___  ___
  アクセス制御の粒度            ___   ___  ___  ___  ___
  コードレビュー統合            ___   ___  ___  ___  ___

【歴史の保存】
  履歴の追跡性                  ___   ___  ___  ___  ___
  操作の取り消し容易性          ___   ___  ___  ___  ___
  監査/コンプライアンス対応     ___   ___  ___  ___  ___

【エコシステム】
  CI/CD統合                     ___   ___  ___  ___  ___
  IDE/エディタ統合              ___   ___  ___  ___  ___
  ホスティングサービス          ___   ___  ___  ___  ___

【チーム】
  学習コスト                    ___   ___  ___  ___  ___
  人材の確保しやすさ            ___   ___  ___  ___  ___
  ドキュメント/コミュニティ     ___   ___  ___  ___  ___
─────────────────────────────────────────────────────────────
加重合計                              ___  ___  ___  ___
```

このマトリクスの要点は三つある。

第一に、「重み」の列が最も重要だ。すべての項目が等しく重要なわけではない。自分のプロジェクトにとって何が最も重要かを明確にすることが、マトリクスの本質的な価値だ。ゲーム開発ならバイナリファイル対応の重みが高くなる。グローバル分散チームならオフライン作業対応が重要になる。規制産業なら監査対応が最優先かもしれない。

第二に、「エコシステム」と「チーム」のカテゴリが、純粋な技術評価を補完する。Richard Gabrielの「Worse is Better」が示す通り、技術的な優劣だけでは選択は決まらない。エコシステムの成熟度とチームの現実が、しばしば技術的な差異を凌駕する。

第三に、このマトリクスは一度作ったら終わりではない。プロジェクトの進展、チームの成長、技術の進化に応じて、定期的に再評価すべきだ。ADRにマトリクスの結果を記録し、条件が変わったときに再評価のトリガーとする。

---

## 4. ハンズオン：VCS評価マトリクスを実践する

このハンズオンは、連載最終回にふさわしく、特定のツールの操作ではなく、自分自身のプロジェクトを分析する演習だ。Gitリポジトリを対象に、評価マトリクスの各項目を定量的・定性的に測定する方法を示す。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash

# 必要なパッケージのインストール
apt update && apt install -y git bc

# gitの設定
git config --global user.email "developer@example.com"
git config --global user.name "Developer"
git config --global init.defaultBranch main
```

### 演習1：プロジェクトの現状を定量的に把握する

```bash
WORKDIR="${HOME}/vcs-handson-24"
mkdir -p "${WORKDIR}"
cd "${WORKDIR}"

echo "=== 演習1: プロジェクトの現状を定量的に把握する ==="
echo ""

# サンプルプロジェクトを作成（実際のプロジェクトでも実行可能）
git init sample-project
cd sample-project

# 現実的な履歴を構築する
# --- 初期開発フェーズ ---
cat > main.py << 'PYEOF'
class App:
    def __init__(self):
        self.config = {}

    def run(self):
        print("App running")
PYEOF

cat > config.json << 'JSONEOF'
{
    "version": "1.0.0",
    "debug": false,
    "database": {
        "host": "localhost",
        "port": 5432
    }
}
JSONEOF

git add -A
git commit -m "Initial project setup with App class and config"

# --- 機能追加フェーズ ---
cat > auth.py << 'PYEOF'
class AuthManager:
    def __init__(self, secret_key):
        self.secret_key = secret_key

    def authenticate(self, token):
        return self.verify(token, self.secret_key)

    def verify(self, token, key):
        # Simplified verification
        return token is not None and len(token) > 0
PYEOF

git add auth.py
git commit -m "Add authentication module"

# --- バグ修正 ---
cat > main.py << 'PYEOF'
import logging

logger = logging.getLogger(__name__)

class App:
    def __init__(self):
        self.config = {}
        self.running = False

    def run(self):
        if self.running:
            logger.warning("App is already running")
            return
        self.running = True
        logger.info("App started")
PYEOF

git add main.py
git commit -m "$(cat <<'EOF'
Fix duplicate run prevention and add logging

The App class could be started multiple times without any guard,
causing resource leaks. Added a running state flag and logging
for better observability.
EOF
)"

# --- ブランチ作業 ---
git checkout -b feature/api
cat > api.py << 'PYEOF'
class APIHandler:
    def __init__(self, app):
        self.app = app

    def handle_request(self, method, path, body=None):
        if method == "GET":
            return self.handle_get(path)
        elif method == "POST":
            return self.handle_post(path, body)
        return {"status": 405, "error": "Method not allowed"}

    def handle_get(self, path):
        return {"status": 200, "path": path}

    def handle_post(self, path, body):
        return {"status": 201, "path": path, "body": body}
PYEOF

git add api.py
git commit -m "Add API handler with GET/POST support"
git checkout main
git merge feature/api -m "Merge feature/api: REST API handler"

# --- さらに履歴を積む ---
echo "# Sample Project" > README.md
echo "" >> README.md
echo "A demonstration project for VCS evaluation." >> README.md
git add README.md
git commit -m "Add project README"

cat > tests.py << 'PYEOF'
import unittest

class TestApp(unittest.TestCase):
    def test_app_creation(self):
        from main import App
        app = App()
        self.assertIsNotNone(app)

    def test_app_config(self):
        from main import App
        app = App()
        self.assertEqual(app.config, {})

class TestAuth(unittest.TestCase):
    def test_auth_with_valid_token(self):
        from auth import AuthManager
        auth = AuthManager("secret")
        self.assertTrue(auth.authenticate("valid-token"))

    def test_auth_with_empty_token(self):
        from auth import AuthManager
        auth = AuthManager("secret")
        self.assertFalse(auth.authenticate(""))
PYEOF

git add tests.py
git commit -m "Add unit tests for App and AuthManager"

echo "--- リポジトリの定量データ ---"
echo ""

# コミット数
COMMIT_COUNT=$(git rev-list --count HEAD)
echo "コミット数: ${COMMIT_COUNT}"

# ファイル数
FILE_COUNT=$(git ls-files | wc -l)
echo "追跡ファイル数: ${FILE_COUNT}"

# 総行数
TOTAL_LINES=$(git ls-files | xargs wc -l 2>/dev/null | tail -1 | awk '{print $1}')
echo "総行数: ${TOTAL_LINES}"

# リポジトリサイズ
REPO_SIZE=$(du -sh .git | awk '{print $1}')
echo "リポジトリサイズ (.git): ${REPO_SIZE}"

# 貢献者数
CONTRIBUTOR_COUNT=$(git shortlog -sn | wc -l)
echo "貢献者数: ${CONTRIBUTOR_COUNT}"

# ブランチ数
BRANCH_COUNT=$(git branch -a | wc -l)
echo "ブランチ数: ${BRANCH_COUNT}"

# マージコミットの割合
MERGE_COUNT=$(git log --merges --oneline | wc -l)
echo "マージコミット数: ${MERGE_COUNT} / ${COMMIT_COUNT}"

echo ""
echo "-> これらの数値が評価マトリクスの「重み付け」を決める基礎データとなる"
echo "   ファイル数が少なく貢献者が1名なら「協調の仕組み」の重みは低い"
echo "   バイナリファイルが多いなら「バイナリ対応」の重みが高くなる"
```

### 演習2：コミットメッセージの品質を測定する

```bash
echo ""
echo "=== 演習2: コミットメッセージの品質を測定する ==="
echo ""

cd "${WORKDIR}/sample-project"

echo "--- 全コミットメッセージの一覧 ---"
git log --format="%h %s" --no-merges
echo ""

# コミットメッセージの文字数分析
echo "--- コミットメッセージの文字数分析 ---"
TOTAL_COMMITS=$(git log --no-merges --format="%s" | wc -l)
SHORT_COMMITS=$(git log --no-merges --format="%s" | awk 'length < 20' | wc -l)
DETAILED_COMMITS=$(git log --no-merges --format="%B" | grep -c "^$" || echo "0")

echo "非マージコミット数: ${TOTAL_COMMITS}"
echo "件名20文字未満のコミット: ${SHORT_COMMITS}"
echo ""

# 本文（body）のあるコミットの数
BODY_COUNT=$(git log --no-merges --format="%B---SEPARATOR---" | grep -B1 "^---SEPARATOR---$" | grep -v "^---SEPARATOR---$" | grep -v "^--$" | grep -v "^$" | head -20 | wc -l)

echo "--- コミットメッセージの詳細表示 ---"
git log --no-merges --format="--- %h ---%n件名: %s%n本文: %b%n"
echo ""

echo "-> 「歴史の保存」の品質は、コミットメッセージの質で決まる"
echo "   良いコミットメッセージ: 件名で「何を」、本文で「なぜ」を説明"
echo "   悪いコミットメッセージ: 'fix bug', 'update', 'WIP'"
echo ""
echo "-> あなたのプロジェクトのgit logを開いて、同じ分析をしてみよう"
echo "   「なぜ」が記録されているコミットは何割あるだろうか？"
```

### 演習3：VCS評価マトリクスを作成する

```bash
echo ""
echo "=== 演習3: VCS評価マトリクスを作成する ==="
echo ""

cat << 'MATRIX'
以下のマトリクスを、あなたのプロジェクトに合わせて記入してください。
各項目を1-5で評価し、重みを1-3で設定してください。

重み:  1=あまり重要でない  2=重要  3=非常に重要
評価:  1=不適合  2=やや不適合  3=普通  4=適合  5=最適

┌─────────────────────────────┬────┬─────┬─────┬─────┬─────┐
│ 評価項目                    │重み│ Git │ jj  │ SVN │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│【変更の記録】               │    │     │     │     │     │
│ コミットの粒度制御          │    │     │     │     │     │
│ バイナリファイル対応        │    │     │     │     │     │
│ 大規模リポジトリ性能        │    │     │     │     │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│【協調の仕組み】             │    │     │     │     │     │
│ ブランチ/マージの効率       │    │     │     │     │     │
│ オフライン作業対応          │    │     │     │     │     │
│ アクセス制御の粒度          │    │     │     │     │     │
│ コードレビュー統合          │    │     │     │     │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│【歴史の保存】               │    │     │     │     │     │
│ 履歴の追跡性                │    │     │     │     │     │
│ 操作の取り消し容易性        │    │     │     │     │     │
│ 監査/コンプライアンス対応   │    │     │     │     │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│【エコシステム】             │    │     │     │     │     │
│ CI/CD統合                   │    │     │     │     │     │
│ IDE/エディタ統合            │    │     │     │     │     │
│ ホスティングサービス        │    │     │     │     │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│【チーム】                   │    │     │     │     │     │
│ 学習コスト                  │    │     │     │     │     │
│ 人材の確保しやすさ          │    │     │     │     │     │
│ ドキュメント/コミュニティ   │    │     │     │     │     │
├─────────────────────────────┼────┼─────┼─────┼─────┼─────┤
│ 加重合計                    │    │     │     │     │     │
└─────────────────────────────┴────┴─────┴─────┴─────┴─────┘

記入のポイント:
1. まず「重み」を全項目記入する（プロジェクトの特性を反映）
2. 次に各ツールの評価を記入する
3. 加重合計 = Σ(重み × 評価) で計算する
4. 合計が最も高いツールが「このプロジェクトに最も適した」候補

注意:
- マトリクスは意思決定の補助であって、決定そのものではない
- 定量化できない要因（チームの士気、将来の戦略）も考慮すべき
- 結果はADRとして記録し、将来の再評価に備える
MATRIX

echo ""
echo "-> このマトリクスの最大の価値は「重み付け」のプロセスにある"
echo "   重みを決める議論の中で、チームが何を重視しているかが明確になる"
echo "   それ自体が、技術選定の質を高める"
```

### 演習4：ADRを書いてみる

```bash
echo ""
echo "=== 演習4: ADRを書いてみる ==="
echo ""

cd "${WORKDIR}/sample-project"

mkdir -p docs/decisions

cat > docs/decisions/001-vcs-selection.md << 'ADREOF'
# ADR-001: バージョン管理システムの選定

## ステータス

承認済

## コンテキスト

本プロジェクトのバージョン管理システムを選定する必要がある。

プロジェクトの特性:
- テキストファイル中心（ソースコード + 設定ファイル）
- チーム規模: 現在4名、1年後に8名の見込み
- リモートワーク中心（3拠点に分散）
- CI/CDにGitHub Actionsを使用予定

検討した選択肢:
1. Git + GitHub
2. Jujutsu (jj) + GitHub
3. Subversion + 自前サーバー

## 決定

Git + GitHub を採用する。

## 理由

- チーム全員がGitの実務経験を有している（学習コスト最小）
- GitHub ActionsによるCI/CDとのネイティブ統合が可能
- リモートワーク中心のため分散型VCSが適している
- Jujutsuは技術的に魅力的だが、バージョン1.0未達で
  プロダクション利用のリスクがある
- プロジェクト規模ではGitのスケーリング限界に達しない見込み

## 結果

- GitHub Flowをブランチ戦略として採用する
- コミットメッセージはConventional Commits形式に準拠する
- 年1回、VCS選定の妥当性を再評価する
- Jujutsuの1.0リリース時に再評価を実施する

## 再評価のトリガー

- リポジトリサイズが10GBを超えた場合
- チーム規模が20名を超えた場合
- バイナリアセットの管理が主要な課題になった場合
- Jujutsuが安定版に達した場合
ADREOF

git add docs/
git commit -m "$(cat <<'EOF'
Add ADR-001: Version control system selection

Document the decision to use Git + GitHub, including context,
alternatives considered, rationale, and re-evaluation triggers.
EOF
)"

echo "--- 作成したADR ---"
cat docs/decisions/001-vcs-selection.md
echo ""

echo "-> ADRは「なぜその技術を選んだか」を記録する"
echo "   これにより、将来のチームメンバーが"
echo "   Chesterton's Fenceの「理由」を理解できる"
echo ""
echo "-> 重要なのは「再評価のトリガー」の項目"
echo "   条件が変わったときに、惰性ではなく"
echo "   合理的な判断で技術選定を見直せる"
```

### 演習で見えたこと

四つの演習を通じて、バージョン管理ツールの選定を「感覚」ではなく「構造化された判断」として行う方法を示した。

演習1では、プロジェクトの定量データを収集した。リポジトリのサイズ、コミット数、貢献者数——これらの数値が、評価マトリクスの「重み付け」を決める基礎となる。

演習2では、コミットメッセージの品質を測定した。「歴史の保存」はツールの機能だけでなく、チームの運用習慣に依存する。ツールを変えても、コミットメッセージの質が変わらなければ、「歴史の保存」は改善しない。

演習3では、VCS評価マトリクスを作成した。このマトリクスの最大の価値は、「重み付け」のプロセスそのものにある。チームが何を重視しているかを明確にする議論が、技術選定の質を高める。

演習4では、ADRを実際に書いた。技術選定の理由を文書化し、再評価のトリガーを明記することで、「惰性」でも「暴走」でもない、合理的な技術選定のサイクルを作れる。

あなたのプロジェクトでは、VCSの選定理由が文書化されているだろうか。「なぜGitを使っているのか」に、根拠を持って答えられるだろうか。

---

## 5. まとめ——gitを「選んで」使え

### この回の要点

第一に、バージョン管理の50年の歴史が教えてくれる最も重要な教訓は、「最適解は常に変わる」ということだ。SCCSが最適だった時代があり、CVSが最適だった時代があり、Subversionが最適だった時代があり、Gitが最適な時代がある。そして、Gitが最適でなくなる時代も来る。技術の歴史は、一つの答えに収束する物語ではなく、問いの条件が変わり続ける中で、最適な解が移り変わっていく物語だ。

第二に、技術選定は工学的判断であり、好みの問題ではない。Rogersの普及理論、Gabrielの「Worse is Better」、Chesterton's Fence、Lindy Effect——これらのフレームワークは、技術選定における「なぜ」を構造化する道具だ。技術的な優劣だけでなく、エコシステムの成熟度、チームの現実、将来の変化を含めた総合的な判断が求められる。

第三に、技術選定の理由を記録し、定期的に再評価する仕組みが必要だ。ADRとVCS評価マトリクスは、この仕組みを具体化する方法だ。「なぜそのツールを使っているのか」を文書化し、条件が変わったときに合理的に見直す——これが、惰性でも暴走でもない、成熟した技術選定のあり方だ。

第四に、ツールの選択よりも、ツールの「使い方」の方が重要だ。第23回で示した通り、バージョン管理の「三つの本質」のうち「歴史の保存（Why?）」は、ツールではなく人間の運用に依存する。Gitを使っていても、コミットメッセージが「fix」の一言では、歴史は保存されない。逆に、Subversionを使っていても、コミットメッセージが丁寧に書かれていれば、歴史は豊かに保存される。

### 連載全体の結論

24回にわたるこの連載の結論は、第1回の冒頭で投げかけた問いへの回答でもある。

「gitが空気になった世界で、私たちは何を失ったのか」。

答えは、「選ぶ力」だ。

gitを「空気」として無意識に使っている人間は、gitを「選んでいる」のではない。他に選択肢がないから——正確には、他に選択肢があることを知らないから——gitを使っている。それは依存であって、選択ではない。

選ぶためには、選択肢を知る必要がある。SCCSがなぜファイルロックを採用したのか。CVSのCopy-Modify-Mergeモデルがなぜ革命だったのか。Subversionのアトミックコミットがなぜ重要だったのか。Gitのコンテンツアドレッサブルストレージがなぜ画期的だったのか。これらを知ることで初めて、Gitの設計判断が「トレードオフの結果」であることが理解できる。そして、トレードオフを理解した人間だけが、合理的な選択ができる。

選ぶためには、自分のニーズを知る必要がある。プロジェクトの特性、チームの構造、エコシステムとの統合、将来の変化——これらの条件を明確にし、評価基準に照らして判断する。同じ人間が同じツールを使い続けるとしても、「なぜそれを使うのか」を言語化できることが、依存と選択の分水嶺だ。

選ぶためには、選んだ理由を記録する必要がある。ADRに書く。マトリクスを残す。次に条件が変わったとき、ゼロから考え直すのではなく、前回の判断を起点に差分を評価できるようにする。

**gitを使うな、とは言わない。gitを「選んで」使え。**

2026年の今、多くのプロジェクトにとってGitは最適な選択であり続けているだろう。それ自体は全く問題ない。問題なのは、それが「選択」ではなく「前提」になっていることだ。

前提は思考を停止させる。選択は思考を要求する。

エンジニアは、思考する存在であるべきだ。

### 最後に——Enableということ

私がこの連載を書いた動機は、第1回で述べた通り、「Enable」だ。依存関係を作るのではなく、自走できる状態を作ること。

gitの使い方を教えることは、Enableではない。gitがなぜそう設計されたかを理解させることが、Enableだ。gitの前に何があったかを知ることが、Enableだ。gitの次に何が来るかを自分で考える力を持つことが、Enableだ。

この連載を読み終えたあなたは、バージョン管理について、連載開始前とは異なる視座を持っているはずだ。「git add、git commit、git push」の手順の背後にある50年の歴史と、その歴史が凝縮された設計思想が見えるようになっているはずだ。

その視座を、チームに持ち帰ってほしい。「なぜうちのチームはGitを使っているのか」と問いかけてほしい。答えが「みんなが使っているから」であるなら、この連載で得た知識をもとに、その答えを更新してほしい。

そして、いつかGitの次のツールが登場したとき——それがJujutsuかもしれないし、まだ名前のないツールかもしれない——あなたは、歴史を知る者として、合理的にそのツールを評価し、必要であれば移行を主導できる人間になっている。

バージョン管理の本質は変わらない。変更を記録し、協調を支え、歴史を保存する。50年前からそうであり、50年後もそうであろう。ツールは変わる。だが、本質を理解した人間は、どのツールの時代にも適応できる。

それが、「自走できる状態」だ。

24回にわたるこの連載にお付き合いいただき、感謝する。あなたの明日のバージョン管理が、「選択」であることを願っている。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Rogers, Everett M. "Diffusion of Innovations." Free Press, 1962. <https://en.wikipedia.org/wiki/Diffusion_of_innovations>
- Gabriel, Richard P. "Lisp: Good News, Bad News, How to Win Big." 1989. <https://www.dreamsongs.com/WorseIsBetter.html>
- Chesterton, G.K. "The Thing: Why I Am a Catholic." 1929. <https://fs.blog/chestertons-fence/>
- Taleb, Nassim Nicholas. "Antifragile: Things That Gain from Disorder." Random House, 2012. <https://en.wikipedia.org/wiki/Lindy_effect>
- Spolsky, Joel. "Things You Should Never Do, Part I." Joel on Software, April 6, 2000. <https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/>
- Nygard, Michael. "Documenting Architecture Decisions." Cognitect Blog, November 15, 2011. <https://www.cognitect.com/blog/2011/11/15/documenting-architecture-decisions>
- Stack Overflow Developer Survey 2025. <https://survey.stackoverflow.co/2025/>
- GitHub Octoverse 2025. <https://octoverse.github.com/>
- Jujutsu (jj) Version Control System. <https://github.com/jj-vcs/jj>
- Sapling SCM (Meta). <https://sapling-scm.com/>
- Git 3.0 SHA-256 Transition. <https://www.deployhq.com/blog/git-3-0-on-the-horizon-what-git-users-need-to-know-about-the-next-major-release>
