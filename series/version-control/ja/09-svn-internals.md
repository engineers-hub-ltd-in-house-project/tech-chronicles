# git ありきの世界に警鐘を鳴らす

## ——バージョン管理の根源から未来を考える

### 第9回：Subversionの内部構造——なぜ連番リビジョンは合理的だったのか

**連載「git ありきの世界に警鐘を鳴らす」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- Subversionの連番リビジョンが集中型アーキテクチャの必然的帰結である理由
- FSFSリポジトリの内部構造——node-revision、representation、changed-paths
- 「bubble-up」方式によるコミットの仕組みとDAG（有向非巡回グラフ）としてのツリー構造
- Copy-on-Write方式とskip-deltaアルゴリズムによるストレージ効率の実現
- svnadmin dumpフォーマットの構造とリポジトリのポータビリティ
- Gitのコンテンツアドレッサブルストレージとの設計思想の本質的な違い

---

## 1. 「1234を見てくれ」——人間のための識別子

私がSubversionを使っていた現場で、最も頻繁に口にした言葉がある。

「リビジョン1234を見てくれ。」

バグ報告のメールに書いた。コードレビューの依頼に添えた。チャットで同僚に伝えた。たった4桁の数字で、リポジトリのある一時点の状態を、チーム全員が一意に特定できた。`svn log -r 1234` を実行すれば、誰がいつ何を変更したかが表示される。`svn diff -r 1233:1234` で、その変更の差分が見える。`svn cat -r 1234 trunk/main.c` で、その時点のファイル内容が取得できる。

数字は人間の脳にとって扱いやすい。順序がある。大小関係がある。「リビジョン1234はリビジョン1200より新しい」——当たり前のことだが、これは強力な認知的道具だ。

私が初めてgitに触れたとき、最初に感じた違和感はコミットの識別子だった。`a3f2e1b4c5d6e7f8...` という40文字の16進数文字列。短縮形でも `a3f2e1b` のような7文字。覚えられない。順序もない。「このコミットはあのコミットより前なのか後なのか」が、識別子を見ただけではわからない。

当時の私は、これをgitの「欠点」だと感じた。Subversionの連番リビジョンのほうが、明らかに人間にとって扱いやすい。

だが、今なら理解している。gitがハッシュ値を採用したのは「連番にできなかった」のではない。分散型アーキテクチャにおいて、連番リビジョンは原理的に不可能なのだ。そして、ハッシュ値には連番にはない強力な利点がある。

逆に問えば、Subversionが連番リビジョンを実現できたのはなぜか。中央サーバがすべてのコミットを受け付け、一元的に番号を割り振るからだ。連番リビジョンは集中型アーキテクチャの構造的な帰結であり、設計上の「利点」でもある。

この回では、Subversionの内部構造を解剖する。リポジトリの中で何が起きているのか。リビジョンファイルはどのように構成されているのか。コミット時にツリーはどう更新されるのか。そしてなぜ、この設計が「連番リビジョン」を自然に導くのか。

あなたが日常的に使っている `git log` のコミットハッシュ。それが「連番」ではなく「ハッシュ値」である理由を、Subversionの内部から逆照射して考えてみよう。

---

## 2. FSFSリポジトリの解剖——リビジョンファイルの中身

### リポジトリの物理構造

前回、FSFSバックエンドの概要に触れた。ここではその内部に深く踏み込む。

FSFSは "Filesystem on top of Filesystem" の略であり、その名のとおり、バージョン管理されたファイルシステムをOSのファイルシステム上に直接構築する。`svnadmin create` で作成されたリポジトリのディレクトリ構造は以下のようになる。

```
myrepo/
├── conf/                  # 設定ファイル
│   ├── svnserve.conf
│   ├── passwd
│   └── authz
├── db/                    # データストア（FSFS）
│   ├── current            # 最新リビジョン番号
│   ├── fs-type            # "fsfs" と記載
│   ├── format             # FSFSフォーマットバージョン
│   ├── fsfs.conf          # FSFS設定
│   ├── min-unpacked-rev   # パッキング済みでない最小リビジョン
│   ├── revs/              # リビジョンファイル
│   │   └── 0/             # シャード0（リビジョン0〜999）
│   │       ├── 0          # リビジョン0のデータ
│   │       ├── 1          # リビジョン1のデータ
│   │       └── ...
│   ├── revprops/          # リビジョンプロパティ
│   │   └── 0/
│   │       ├── 0          # リビジョン0のプロパティ
│   │       ├── 1          # リビジョン1のプロパティ
│   │       └── ...
│   ├── txn-protorevs/     # 進行中トランザクションのプロトリビジョン
│   ├── txn-current        # 現在のトランザクションID
│   └── uuid               # リポジトリUUID
├── format                 # リポジトリフォーマットバージョン
├── hooks/                 # フックスクリプト
└── locks/                 # ロックファイル
```

注目すべきは `db/revs/` 配下の構造だ。Subversion 1.5（2008年）以降、FSFSはシャード構造を採用している。デフォルトでは1シャードあたり1000個のリビジョンファイルを格納する。リビジョン0から999は `db/revs/0/` に、リビジョン1000から1999は `db/revs/1/` に配置される。

シャード導入以前は、すべてのリビジョンファイルが `db/revs/` の直下にフラットに並んでいた。リビジョン数が数万、数十万に達すると、一つのディレクトリに膨大な数のファイルが存在することになり、ファイルシステムの性能が著しく劣化した。シャード構造はこの問題への直接的な回答だった。

`db/current` ファイルには最新のリビジョン番号がテキストで記録されている。コミットが行われるたびに、この数字が1つ増える。極めてシンプルだが、このファイルこそが「連番リビジョン」の物理的な実体だ。中央サーバ上の一つのファイルが、リポジトリのバージョン番号を管理している。

### リビジョンファイルの内部構造

FSFSの核心は、各リビジョンファイルの内部構造にある。リビジョンファイルは三つのセクションで構成される。

**（1）Node-revision と Representation**

リビジョンファイルの大部分を占めるのが、そのリビジョンで新規作成または変更されたnode-revisionと、それに対応するrepresentation（ファイル内容やディレクトリエントリの実データ）だ。

node-revisionとは、ある時点におけるノード（ファイルまたはディレクトリ）の状態を記述するメタデータレコードである。UNIXファイルシステムのinodeに相当する概念だ。各node-revisionは以下のようなフォーマットで記録される。

```
id: <node-revision-id>
type: file              # "file" または "dir"
pred: <predecessor-id>  # 前身ノードのID（初回はなし）
count: 5                # ベースからのリビジョン数
text: 3 172 56 56 8cf...  # テキスト表現の参照（rev offset length size digest）
props: 3 45 18 18 d41...  # プロパティ表現の参照
cpath: /trunk/main.c    # 作成時のパス
copyroot: 0 /           # コピールート
```

`text` フィールドの値 `3 172 56 56 8cf...` は「リビジョン3のファイル中、オフセット172バイト目から始まる56バイトのデータで、展開後のサイズが56バイト、MD5ダイジェストが8cf...」という意味だ。つまり、node-revisionはファイル内容そのものを保持するのではなく、それが格納されている場所を指し示す。

representation（表現）は、ファイル内容またはディレクトリエントリの実データを保持するセクションだ。representationは以下の形式で始まる。

```
PLAIN
（非圧縮の生データ）
ENDREP
```

または

```
DELTA <base-rev> <base-offset> <base-length>
（svndiff形式のデルタデータ）
ENDREP
```

`PLAIN` はデータがそのまま格納されていることを示す。`DELTA` はある既存のrepresentationに対する差分として格納されていることを示す。デルタの基準となるrepresentationの場所が `<base-rev> <base-offset> <base-length>` で指定される。

ディレクトリのrepresentationは、エントリ名から `<type> <id>` ペアへのマッピングをハッシュダンプ形式で保持する。

```
K 6
main.c
V 14
file 3-1.0.r3/42
K 8
config.h
V 14
file 3-2.0.r3/98
END
```

これは「main.c はファイルでありnode-revision ID が 3-1.0.r3/42、config.h はファイルでありnode-revision ID が 3-2.0.r3/98」という意味だ。

**（2）Changed-paths（変更パス一覧）**

リビジョンファイルの末尾近くには、そのリビジョンで変更されたパスの一覧が記録される。各エントリは以下の形式だ。

```
<node-rev-id> <action> <text-mod> <prop-mod> <path>
<copyfrom-rev> <copyfrom-path>
```

`<action>` は `add`、`delete`、`modify`、`replace` のいずれか。`<text-mod>` と `<prop-mod>` はそれぞれテキストとプロパティに変更があったかを示す真偽値だ。この一覧があるため、`svn log -v -r N` で特定リビジョンの変更ファイル一覧を高速に取得できる。

**（3）ルートノードへの参照**

リビジョンファイルの末尾には、そのリビジョンのルートディレクトリのnode-revisionへのオフセットと、changed-pathsセクションへのオフセットが記録される。これにより、リビジョンファイルの末尾から逆引きで、ツリー全体にアクセスできる。

```
リビジョンファイルの構造:

  +----------------------------------+
  | representation (ファイル内容)     |  ← オフセット 0
  +----------------------------------+
  | node-revision (ファイルA)         |
  +----------------------------------+
  | representation (ディレクトリ)     |
  +----------------------------------+
  | node-revision (ディレクトリX)     |
  +----------------------------------+
  | ...                              |
  +----------------------------------+
  | node-revision (ルートディレクトリ)|
  +----------------------------------+
  | changed-paths                    |
  +----------------------------------+
  | root-offset changed-paths-offset |  ← ファイル末尾
  +----------------------------------+
```

### リビジョンプロパティの分離

リビジョンプロパティ（`svn:date`、`svn:author`、`svn:log`）は、リビジョンファイルとは別のファイルに保存される。`db/revprops/0/1` のようなファイルに、ハッシュダンプ形式で記録される。

```
K 10
svn:author
V 7
sussman
K 8
svn:date
V 27
2004-02-23T18:45:12.345678Z
K 7
svn:log
V 29
Initial project structure.
END
```

この分離には設計上の理由がある。リビジョンファイル（ツリーデータ）は不変（immutable）だが、リビジョンプロパティは変更可能である。コミット後にログメッセージを修正する `svn propset --revprop -r 1234 svn:log "修正後のメッセージ"` という操作が可能であり、これは実務的に重要な機能だ。不変のリビジョンデータと可変のリビジョンプロパティを分離することで、リビジョンファイルの不変性を保証しつつ、メタデータの修正を可能にしている。

---

## 3. Bubble-upとskip-delta——効率の追求

### Bubble-up方式：変更の伝播

Subversionのコミットは「bubble-up」と呼ばれる方式で動作する。Subversionの公式設計文書で解説されているこの仕組みは、リポジトリのストレージ効率の根幹を成すものだ。

具体例で説明しよう。以下のようなディレクトリ構造のリポジトリがリビジョン100の状態にあるとする。

```
/  (root)
├── trunk/
│   ├── src/
│   │   ├── main.c
│   │   └── util.c
│   └── doc/
│       └── README
└── branches/
```

ここで `trunk/src/main.c` だけを変更してコミットする場合、何が起きるか。

```
リビジョン100（変更前）         リビジョン101（変更後）

     [root-100]                   [root-101] ← 新規作成
     /        \                   /        \
 [trunk-100]  [branches-100] [trunk-101]  [branches-100]
  /      \                    /      \         ↑ 共有
[src-100] [doc-100]      [src-101] [doc-100]
 /    \      \            /    \      ↑ 共有
main.c util.c README  [main.c] util.c
 100    100    100      101     ↑ 共有
                         ↑
                      新規作成
```

リビジョン101で新規に作成されるnode-revisionは、以下の4つだけだ。

1. `main.c` の新しいnode-revision（変更されたファイル）
2. `src/` の新しいnode-revision（子要素が変わったため）
3. `trunk/` の新しいnode-revision（子要素が変わったため）
4. `/`（ルート）の新しいnode-revision（子要素が変わったため）

変更されていない `util.c`、`README`、`doc/`、`branches/` は、リビジョン100のnode-revisionがそのまま参照される。新しいnode-revisionは作成されない。

これが「bubble-up」だ。変更は葉ノード（ファイル）から始まり、ルートに向かって「泡のように」浮かび上がる。変更されたノードの祖先ディレクトリだけが新しいnode-revisionを必要とし、それ以外のサブツリーは前のリビジョンとノードを共有する。

Subversionの設計文書はこのメカニズムを明確に記述している。リポジトリのディレクトリ構造はツリーではなくDAG（有向非巡回グラフ）として表現される。なぜDAGなのか。異なるリビジョンのディレクトリノードが、同一の子ノードを指し示すことがあるからだ。上の例で言えば、リビジョン101の `trunk-101` ディレクトリは `doc-100`（リビジョン100のディレクトリノード）を子として参照している。一つのノードが複数の親を持ちうる——これはツリーではなくDAGだ。

この設計がcheap copy（安価なコピー）を可能にする。ブランチやタグを作成する `svn copy` は、ルートノードに新しいエントリを一つ追加するだけだ。コピー先のディレクトリは、コピー元のツリー全体をそのまま参照する。100MBのディレクトリツリーをコピーしても、物理的なデータ複製は発生しない。リポジトリサイズの増加はほぼゼロだ。

### Skip-delta：ストレージと性能のバランス

FSFSでは、ファイルの各リビジョンは以前のリビジョンに対するデルタ（差分）として格納される。だが、リビジョン100のファイルを復元するために、リビジョン1からの100個のデルタを順番に適用しなければならないとしたら、性能は壊滅的だ。

この問題を解決するのがskip-deltaアルゴリズムである。

skip-deltaのアイデアはスキップリストからヒントを得ている。リビジョンNのデルタベース（差分の基準となるリビジョン）を選ぶ規則は以下のとおりだ。

**Nを二進数で表し、最も右の値が1であるビットを反転する。**

具体例を見よう。

```
リビジョン  二進数    最右の1ビットを反転  デルタベース
  1        0001      0000                0
  2        0010      0000                0
  3        0011      0010                2
  4        0100      0000                0
  5        0101      0100                4
  6        0110      0100                4
  7        0111      0110                6
  8        1000      0000                0
  9        1001      1000                8
 10        1010      1000                8
```

リビジョン0から9までのデルタチェーンを図示すると、以下のようになる。

```
0 ← 1    2 ← 3    4 ← 5    6 ← 7    8 ← 9
0 ←────── 2        4 ←────── 6
0 ←──────────────── 4
0 ←──────────────────────────────────── 8
```

リビジョン7を復元するには、7→6→4→0 の3回のデルタ適用で済む。リビジョン9なら、9→8→0 の2回だ。一般にリビジョンNの復元に必要なデルタ適用回数は最大 lg(N) 回——つまり対数的な計算量で済む。リビジョンが10万に達しても、約17回のデルタ合成で任意のリビジョンを復元できる。

skip-deltaは「ストレージ効率」と「読み取り性能」のトレードオフを巧みにバランスしている。すべてのリビジョンを完全なスナップショットとして保存すれば読み取りは最速だが、ストレージ消費は膨大になる。逆に、すべてを直前リビジョンとのデルタで保存すればストレージは最小だが、古いリビジョンの復元がリニアにコストを増す。skip-deltaは O(lg(N)) の読み取りコストと O(N/lg(N)) のストレージ効率を両立する。

### ツリーのスナップショットとデルタの共存

ここで重要なのは、Subversionのリポジトリが「スナップショット」と「デルタ」の両方の概念を内包していることだ。

論理的には、各リビジョンはリポジトリのツリー全体のスナップショットである。リビジョン100は、リポジトリの全ファイル・全ディレクトリの、リビジョン100時点の完全な状態を表現する。

物理的には、各リビジョンファイルはそのリビジョンで変更されたノードのnode-revisionだけを含む。変更されていないノードは前のリビジョンのものが参照される（bubble-up方式）。さらに、ファイル内容はskip-deltaにより以前のリビジョンとの差分として格納される。

この「論理スナップショット・物理デルタ」の二重構造が、Subversionのストレージ効率の鍵だ。ユーザーから見れば、各リビジョンは完全なスナップショットとして振る舞う。内部では、ストレージ効率のための最適化が透過的に行われている。

---

## 4. 連番 vs ハッシュ——二つの識別子が映す設計思想

### 連番リビジョンの前提条件

Subversionの連番リビジョンが成立するには、以下の前提が不可欠である。

第一に、単一の権威あるサーバの存在。すべてのコミットは中央サーバを経由し、サーバが一元的にリビジョン番号を割り振る。`db/current` ファイルの数値をインクリメントするだけだ。複数のサーバが独立に番号を振ることはないため、番号の衝突は原理的に発生しない。

第二に、全順序の保証。リビジョンNはリビジョンN-1の後、リビジョンN+1の前に確定している。すべてのコミットは一列に並ぶ。「リビジョン200はリビジョン100より新しい」と断言できる。

第三に、コミットの逐次処理。二人の開発者が同時にコミットしようとしても、サーバはそれらを逐次的に処理する。一方がリビジョン234を獲得し、もう一方はリビジョン235を獲得する。同時に同じリビジョン番号が割り当てられることはない。

これら三つの前提は、すべて「集中型アーキテクチャ」の帰結だ。中央サーバが存在するからこそ、連番リビジョンは成立する。

### 分散型で連番が不可能な理由

gitのような分散型VCSでは、これらの前提がすべて崩れる。

開発者Aは自分のローカルリポジトリでコミットする。開発者Bも自分のローカルリポジトリでコミットする。この二つのコミットは独立に行われ、互いの存在を知らない。「次のリビジョン番号」を決める権威あるサーバが存在しないため、連番を振ることができない。

AとBがそれぞれ「リビジョン5」をローカルで作成した場合、二つの「リビジョン5」は異なる内容を持つ。これらを統合しようとしたとき、どちらが「本当のリビジョン5」なのか。答えはない。分散型VCSにおいて「リビジョン5」という概念は存在しえないのだ。

```
集中型（Subversion）:
  全コミットが一列に並ぶ → 連番が可能

  Server: [r1] → [r2] → [r3] → [r4] → [r5] → ...
           ↑      ↑             ↑      ↑
          Alice  Bob           Bob   Alice


分散型（Git）:
  並行するコミットが独立に存在 → 連番は不可能

  Alice:  [a1] → [a2] → [a3]
                            \
                             → [merge]
                            /
  Bob:    [b1] → [b2] ----

  a2 と b1 に順序関係はない。どちらが "先" かは定義できない。
```

### Gitの解——コンテンツアドレッサブルストレージ

Gitはこの問題に対して、根本的に異なるアプローチを取った。

Gitのコミット識別子は、コミット内容のSHA-1ハッシュ値（40文字の16進数）だ。コミットに含まれる情報——ツリーのハッシュ、親コミットのハッシュ、著者、コミッター、メッセージ、タイムスタンプ——を連結し、SHA-1で処理した結果がコミットのIDになる。

この設計により、以下が保証される。

第一に、グローバルな一意性。同一の内容は同一のハッシュを生成する。異なる内容は（事実上）異なるハッシュを生成する。地球上のどのリポジトリで生成されたコミットであっても、内容が同じならIDは同じであり、内容が異なればIDも異なる。中央サーバによる番号管理は不要だ。

第二に、完全性の保証。ファイルが一ビットでも破損すれば、ハッシュが一致しなくなる。データの改ざんや破損を自動的に検出できる。Subversionの連番リビジョンにはこの性質はない。

第三に、重複排除の自動化。同一内容のファイルは、リポジトリ内のどこに何個存在しても、一つのオブジェクトとして保存される。内容のハッシュがそのまま格納先のアドレスとなるため、重複は原理的に発生しない。

Gitは「バージョン管理ツール」としてではなく、「コンテンツアドレッサブルファイルシステム」として設計された。Linus Torvaldsが2005年に作ったのは、ファイルの内容をそのハッシュ値で格納・取得するストレージシステムだった。バージョン管理はその上に構築されたアプリケーションに過ぎない。

### 設計思想の違い、優劣ではなく

連番リビジョンとハッシュ値。どちらが「正しい」のか。

この問いの立て方自体が間違っている。正しい問いは「どちらがどのアーキテクチャに適合するか」だ。

```
                  連番リビジョン        ハッシュ値
                  (Subversion)         (Git)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
前提            中央サーバ必須         サーバ不要
順序性          自明（N < N+1）        DAGを辿る必要あり
人間可読性      高い（4桁の数字）      低い（7〜40文字の16進数）
完全性保証      なし                   暗号学的ハッシュ
重複排除        なし                   自動
オフライン      コミット不可           コミット可能
グローバル一意  リポジトリ内のみ       全リポジトリで一意
```

Subversionの連番リビジョンは、集中型アーキテクチャの利点を最大限に活かした設計だ。人間にとっての可読性と操作性を重視し、チーム内のコミュニケーションを円滑にする。「リビジョン1234を見てくれ」——これ以上にシンプルな参照方法はない。

Gitのハッシュ値は、分散型アーキテクチャの要件から必然的に導かれた設計だ。グローバルな一意性とデータの完全性を保証し、中央サーバなしでの運用を可能にする。人間可読性は犠牲になったが、それは分散という価値を得るための対価だ。

2007年5月、Linus TorvaldsはGoogleでのTech Talkで、Subversionを「自分が知る中で最も無意味なプロジェクトだ」と評した。「CVS done rightというスローガンから始めたら、どこにも行けない」と。この発言はLinusの誇張的な修辞だが、その核心にある指摘は正確だ。Subversionは集中型というパラダイムの中で最適化を追求したが、パラダイム自体を問い直すことはしなかった。

だが、ここで公平を期して言えば、パラダイム内での最適化は「無意味」ではない。Subversionが集中型VCSとして達成した設計品質——アトミックコミット、bubble-upによるストレージ効率、skip-deltaによる検索性能、連番リビジョンによる人間工学——は、ソフトウェアエンジニアリングとして卓越している。

問われるべきは「Subversionの設計は良いか悪いか」ではなく、「集中型というパラダイムの前提条件は、2000年代後半以降も成立し続けたか」だ。この問いへの回答は、連載の後半で分散型VCSの歴史を辿る際に明らかになる。

---

## 5. svnadmin dump——リポジトリのポータビリティ

### ダンプフォーマットの設計

Subversionが提供する重要な機能の一つに、リポジトリのダンプ/ロード機能がある。`svnadmin dump` はリポジトリの内容をポータブルなテキスト形式に出力し、`svnadmin load` はそのテキストからリポジトリを再構築する。

ダンプフォーマットにはバージョン1、2、3の三つが存在する。バージョン2ではUUIDレコードが追加され、バージョン3ではデルタ圧縮がサポートされた。

ダンプファイルの構造を見てみよう。以下は実際のダンプファイルの冒頭部分を簡略化したものだ。

```
SVN-fs-dump-format-version: 3

UUID: 7bf7a5ef-cabf-0310-b7d4-93df341afa7e

Revision-number: 0
Prop-content-length: 56
Content-length: 56

K 8
svn:date
V 27
2004-02-23T18:30:00.000000Z
PROPS-END

Revision-number: 1
Prop-content-length: 112
Content-length: 112

K 10
svn:author
V 7
sussman
K 8
svn:date
V 27
2004-02-23T18:45:12.345678Z
K 7
svn:log
V 33
Create standard directory layout.
PROPS-END

Node-path: trunk
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END

Node-path: branches
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END
```

フォーマットはRFC822スタイルのヘッダ行で構成される。各レコードは「キー: 値」の行の連続であり、空行で区切られる。リビジョンレコードにはリビジョン番号とリビジョンプロパティが含まれ、ノードレコードにはパス、種別（file/dir）、アクション（add/delete/modify/replace）、コピー元の情報、そしてファイル内容が含まれる。

ダンプフォーマットのバージョン3では、`Text-delta: true` ヘッダを指定することで、ファイル内容をデルタ形式で出力できる。これにより、大規模リポジトリのダンプファイルサイズを大幅に削減できる。

### ダンプファイルの実用的な価値

ダンプ/ロード機能は、Subversionの運用において不可欠な役割を果たした。

第一に、バックアップとリストア。`svnadmin dump` でリポジトリの完全なスナップショットを取得し、`svnadmin load` で別の場所に復元できる。テキストベースのフォーマットであるため、圧縮が効きやすく、アーカイブに適している。

第二に、バックエンド間の移行。Berkeley DBからFSFSへの移行は、ダンプ/ロードで実現できた。`svnadmin dump` はバックエンドに依存しないポータブルな形式を出力するため、旧バックエンドでダンプし、新バックエンドのリポジトリにロードするだけでよい。

第三に、リポジトリの再構成。`svndumpfilter` コマンドと組み合わせることで、ダンプファイルから特定のパスだけを抽出し、新しいリポジトリとして再構築できた。大きなリポジトリを分割する、あるいは不要な履歴を削除する際に使用された。

この「ダンプファイルによるポータビリティ」は、連番リビジョンの設計と深く関係している。ダンプファイル内のリビジョンは0から連番で並んでおり、ロード先のリポジトリでは新しいリビジョン番号が順に割り当てられる。連番であるからこそ、リビジョンの順序関係は自明であり、ロード処理は単純な逐次処理で済む。分散型VCSのハッシュベースの識別子では、リビジョン間の依存関係（親コミットの参照）を解決する必要があり、処理はより複雑になる。

---

## 6. ハンズオン：Subversionリポジトリの内部を覗く

Subversionのリポジトリの内部構造を、実際に手を動かして確認しよう。前回のハンズオンではSubversionの基本操作を体験した。今回は `svnadmin` と `svnlook` を使い、リポジトリの「中身」を直接覗く。

### 環境の準備

```bash
# Docker環境（推奨）
docker run -it --rm ubuntu:24.04 bash
apt update && apt install -y subversion
```

### 演習1：リポジトリの物理構造を確認する

```bash
WORKDIR="${HOME}/vcs-handson-09"
mkdir -p "${WORKDIR}"

# リポジトリの作成
svnadmin create "${WORKDIR}/myrepo"

echo "=== FSFSバックエンドの確認 ==="
cat "${WORKDIR}/myrepo/db/fs-type"

echo ""
echo "=== FSFSフォーマットバージョン ==="
cat "${WORKDIR}/myrepo/db/format"

echo ""
echo "=== 現在のリビジョン番号 ==="
cat "${WORKDIR}/myrepo/db/current"

echo ""
echo "=== リビジョンファイルの配置 ==="
ls -la "${WORKDIR}/myrepo/db/revs/0/"
echo ""
echo "-> リビジョン0のファイルが1つだけ存在する"
echo "-> これがFSFSの最小単位：1リビジョン＝1ファイル"
```

`db/current` には「0」と記録されている。これがリポジトリの最新リビジョン番号だ。コミットのたびに、この値が1ずつ増えていく。

### 演習2：コミットしてリビジョンファイルの中身を読む

```bash
echo ""
echo "=== 演習2: コミットとリビジョンファイルの解剖 ==="

# 作業コピーの作成
svn checkout "file://${WORKDIR}/myrepo" "${WORKDIR}/wc" --quiet

# 標準ディレクトリ構造とファイルの追加
cd "${WORKDIR}/wc"
svn mkdir trunk --quiet
cat > trunk/hello.c << 'SRCEOF'
#include <stdio.h>
int main(void) {
    printf("Hello, Subversion internals!\n");
    return 0;
}
SRCEOF
svn add trunk/hello.c --quiet
svn commit -m "Add trunk and hello.c" --quiet

echo "--- 現在のリビジョン番号 ---"
cat "${WORKDIR}/myrepo/db/current"

echo ""
echo "--- リビジョン1のファイル内容（生データ） ---"
echo "(node-revision, representation, changed-paths が格納されている)"
echo ""
cat "${WORKDIR}/myrepo/db/revs/0/1"
```

リビジョン1のファイルの中身がテキストとして読める。これがFSFSの透過性だ。Berkeley DBでは不可能だったリポジトリの直接的な検査が、FSFSでは可能になる。

### 演習3：svnlookでリポジトリを検査する

```bash
echo ""
echo "=== 演習3: svnlookによるリポジトリ検査 ==="

echo "--- svnlook info（最新リビジョンの情報）---"
svnlook info "${WORKDIR}/myrepo"

echo ""
echo "--- svnlook tree（ツリー構造）---"
svnlook tree "${WORKDIR}/myrepo"

echo ""
echo "--- svnlook changed（変更されたパス）---"
svnlook changed "${WORKDIR}/myrepo"

echo ""
echo "--- svnlook cat（ファイル内容の取得）---"
svnlook cat "${WORKDIR}/myrepo" trunk/hello.c
```

`svnlook` はリポジトリを読み取り専用で検査するコマンドだ。作業コピーを介さず、リポジトリに直接アクセスする。リビジョンを指定しなければ最新リビジョンが対象になる。

### 演習4：複数コミットとskip-deltaの効果を観察する

```bash
echo ""
echo "=== 演習4: 複数コミットとリビジョンファイルの成長 ==="

cd "${WORKDIR}/wc"

# 複数回のコミットでファイルを変更
for i in $(seq 2 8); do
  cat > trunk/hello.c << SRCEOF
#include <stdio.h>
int main(void) {
    printf("Hello, Subversion internals! (version ${i})\n");
    return 0;
}
SRCEOF
  svn commit -m "Update hello.c to version ${i}" --quiet
done

echo "--- リビジョンファイルのサイズ比較 ---"
echo "(デルタ格納によりサイズが小さくなっているか確認)"
echo ""
for rev in $(seq 0 8); do
  size=$(wc -c < "${WORKDIR}/myrepo/db/revs/0/${rev}")
  printf "リビジョン %d: %5d bytes\n" "${rev}" "${size}"
done

echo ""
echo "--- 各リビジョンの内容をsvnlookで確認 ---"
for rev in 1 4 8; do
  echo ""
  echo "--- リビジョン ${rev} ---"
  svnlook log -r "${rev}" "${WORKDIR}/myrepo"
  svnlook changed -r "${rev}" "${WORKDIR}/myrepo"
done
```

### 演習5：svnadmin dumpでリポジトリの全貌を見る

```bash
echo ""
echo "=== 演習5: svnadmin dumpフォーマット ==="

echo "--- ダンプフォーマット（最初の2リビジョンのみ）---"
svnadmin dump "${WORKDIR}/myrepo" -r 0:2 2>/dev/null

echo ""
echo "--- デルタ形式ダンプとの比較 ---"
full_size=$(svnadmin dump "${WORKDIR}/myrepo" 2>/dev/null | wc -c)
delta_size=$(svnadmin dump "${WORKDIR}/myrepo" --deltas 2>/dev/null | wc -c)
printf "完全ダンプ:   %d bytes\n" "${full_size}"
printf "デルタダンプ: %d bytes\n" "${delta_size}"
echo ""
echo "-> デルタダンプはファイル内容を差分形式で出力するため"
echo "   リポジトリが大きいほどサイズ削減効果が高い"
```

### 演習6：ダンプ/ロードによるリポジトリ移行

```bash
echo ""
echo "=== 演習6: ダンプ/ロードによるリポジトリの複製 ==="

# ダンプの作成
svnadmin dump "${WORKDIR}/myrepo" > "${WORKDIR}/repo.dump" 2>/dev/null

# 新しいリポジトリにロード
svnadmin create "${WORKDIR}/newrepo"
svnadmin load "${WORKDIR}/newrepo" < "${WORKDIR}/repo.dump" > /dev/null 2>&1

echo "--- 元リポジトリの最新リビジョン ---"
svnlook youngest "${WORKDIR}/myrepo"

echo ""
echo "--- 複製先リポジトリの最新リビジョン ---"
svnlook youngest "${WORKDIR}/newrepo"

echo ""
echo "--- 複製先でリビジョン1の内容を確認 ---"
svnlook log -r 1 "${WORKDIR}/newrepo"
svnlook tree -r 1 "${WORKDIR}/newrepo"

echo ""
echo "-> ダンプ/ロードでリポジトリの完全な複製が可能"
echo "-> リビジョン番号、コミットメッセージ、タイムスタンプ全てが保持される"
echo "-> これはバックエンド間の移行（BDB→FSFS）にも使用された"
```

### 演習で見えたこと

六つの演習を通じて、Subversionリポジトリの内部構造を直接確認した。

FSFSの「1リビジョン＝1ファイル」という構造は、テキストエディタで中身を読めるほど透過的だ。node-revisionのヘッダ形式、representationのPLAIN/DELTA形式、changed-pathsの一覧——これらがすべて、通常のファイルとしてディスク上に存在する。

`svnlook` によるリポジトリの非破壊的な検査は、管理者にとって強力な道具だ。`svnadmin dump/load` によるポータビリティは、バックアップ、移行、再構成の基盤となる。

そしてこれらすべての背後に、連番リビジョンという設計が一貫して存在する。リビジョンファイルの名前は連番の数字。`db/current` は最新リビジョンの数字。ダンプファイルはリビジョン0から順番に並ぶ。連番リビジョンは単なるインターフェースの問題ではなく、Subversionの内部アーキテクチャ全体に浸透した設計判断なのだ。

---

## 7. まとめと次回予告

### この回の要点

第一に、FSFSリポジトリの各リビジョンは不変の単一ファイルとして保存される。ファイル内部にはnode-revision（ノードのメタデータ）、representation（ファイル内容やディレクトリエントリの実データ）、changed-paths（変更パス一覧）が格納される。Subversion 1.5以降はシャード構造（デフォルト1000ファイル/シャード）により大規模リポジトリでのファイルシステム性能を維持する。

第二に、コミットは「bubble-up」方式で処理される。変更されたファイルから親ディレクトリに向かって新しいnode-revisionが作成され、変更のないサブツリーは前リビジョンのノードをそのまま共有する。リポジトリのツリー構造はDAG（有向非巡回グラフ）として表現され、cheap copy（安価なコピー）によるブランチ・タグの作成を可能にする。

第三に、skip-deltaアルゴリズムは「二進数の最右1ビットを反転」という規則でデルタベースを選択する。任意のリビジョンの復元に必要なデルタ合成は最大 O(lg(N)) 回であり、ストレージ効率と読み取り性能を両立する。

第四に、連番リビジョンは集中型アーキテクチャの構造的帰結である。中央サーバがコミットを逐次処理し、一元的に番号を割り振ることで実現する。分散型VCSでは複数の開発者が独立にコミットするため、連番は原理的に不可能であり、Gitはコンテンツアドレッサブルストレージ（SHA-1ハッシュ）を採用した。これは優劣ではなく、アーキテクチャの異なる帰結だ。

第五に、svnadmin dumpフォーマットはリポジトリのポータブルなテキスト表現を提供する。バックアップ、バックエンド間の移行、リポジトリの再構成に使用され、連番リビジョンの設計が逐次的なダンプ/ロード処理を自然に可能にしている。

### 冒頭の問いへの暫定回答

Subversionの連番リビジョン vs Gitのハッシュ——どちらが「正しい」のか。

答えは、どちらも正しい。ただし、それぞれが依拠するアーキテクチャの前提が異なる。

連番リビジョンは集中型アーキテクチャに最適化された設計だ。人間にとっての可読性が高く、操作が直感的であり、全順序が保証される。その代償として、中央サーバへの依存が生じる。

ハッシュ値は分散型アーキテクチャの要件から導かれた設計だ。グローバルな一意性とデータの完全性が保証され、オフラインでのコミットが可能になる。その代償として、人間可読性が犠牲になる。

識別子の形式は、アーキテクチャの設計思想を映す鏡だ。連番リビジョンを見れば集中型の設計思想が見え、ハッシュ値を見れば分散型の設計思想が見える。どちらが「正しい」かは、あなたがどちらの前提を受け入れるかに依存する。

### 次回予告

次回は、Subversionの「黄金時代」とその陰りを追う。

**第10回「Subversionの黄金時代と陰り」**

2005年から2010年頃、Subversionは企業の開発現場を席巻した。TortoiseSVNはWindows開発者の定番ツールとなり、EclipseやVisual StudioはSubversion統合プラグインを標準装備した。だが、その全盛期の裏側で、Subversionは構造的な弱点を露呈し始めていた。ブランチとマージの性能問題、オフライン作業の制約、大規模リポジトリでの性能劣化。「CVSを正しくやり直した」Subversionが、なぜ最終的に「勝てなかった」のか。その技術的な理由を検証する。

あなたの現場で、Subversionを使った経験はあるだろうか。あるとしたら、「gitに移行した理由」は何だったか。それは技術的な理由だったか、それとも——。

---

_佐藤裕介——Engineers Hub株式会社 CEO / Technical Lead。1990年代後半からLinux/UNIXの世界に身を置き、24年以上の開発経験を持つ。「Enable——自走できる状態を作ること」を哲学に、技術と人の関係を問い続けている。_

---

### 参考文献

- Apache Subversion Project, "FSFS structure." <https://svn.apache.org/repos/asf/subversion/trunk/subversion/libsvn_fs_fs/structure>
- Apache Subversion Project, "Skip-Deltas in Subversion." <https://svn.apache.org/repos/asf/subversion/trunk/notes/skip-deltas>
- Apache Subversion Project, "Subversion Design." <https://svn.apache.org/repos/asf/subversion/trunk/notes/subversion-design.html>
- Apache Subversion Project, "Subversion dumpfile format." <https://svn.apache.org/repos/asf/subversion/trunk/notes/dump-load-format.txt>
- Collins-Sussman, B., Fitzpatrick, B.W. & Pilato, C.M., "Version Control with Subversion (SVN Book)." <https://svnbook.red-bean.com/>
- SVN Book, "svnlook Reference — Subversion Repository Examination." <https://svnbook.red-bean.com/en/1.8/svn.ref.svnlook.html>
- SVN Book, "Repository Maintenance." <https://svnbook.red-bean.com/en/1.8/svn.reposadmin.maint.html>
- Subversion 1.5 Release Notes. <https://subversion.apache.org/docs/release-notes/1.5.html>
- Git Documentation, "Git Objects." <https://git-scm.com/book/en/v2/Git-Internals-Git-Objects>
- Git Documentation, "hash-function-transition." <https://git-scm.com/docs/hash-function-transition>
- LinusTalk200705Transcript, Git SCM Wiki. <https://git.wiki.kernel.org/index.php/LinusTalk200705Transcript>
