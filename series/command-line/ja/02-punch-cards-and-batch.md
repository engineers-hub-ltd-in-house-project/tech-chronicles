# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第2回：コマンドライン以前の世界――パンチカードとバッチ処理

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 「対話的にコンピュータを使う」という概念がいかに革新的だったか
- Herman Hollerithのパンチカード（1890年）からIBM System/360（1964年）に至るバッチ処理の進化
- パンチカードプログラミングの具体的なワークフロー――コーディングシート、キーパンチ、提出、待機
- 「コンピュータの時間＞人間の時間」という経済合理性がインターフェース設計に与えた影響
- JCL風のジョブスクリプトでバッチ処理を疑似体験するハンズオン

---

## 1. 即座に返事が返る「贅沢」

ターミナルを開いて `ls` と打つ。Enterキーを押した瞬間、ファイル一覧が画面に表示される。

この「即座に返事が返る」という体験を、私たちは空気のように当然のものとして受け止めている。コマンドを打てば結果が返る。エラーが出れば修正してもう一度打つ。この繰り返しが、対話的コンピューティングの本質だ。

だが、この「当然」は、コンピュータの歴史においてはごく最近の発明である。

私が大学で情報工学を学んでいた1990年代半ば、計算機室の片隅に古い段ボール箱が置かれていた。中にはFortranのパンチカードが束になって入っていた。厚紙に長方形の穴が規則正しく開けられたカードの束。助教が「昔の人はこれでプログラムを書いていた」と教えてくれた。

私はそのカードを手に取って、しばらく眺めた。1枚のカードが1行のコードに対応する。プログラムが100行なら100枚のカード。カードの順番を間違えればプログラムは動かない。デッキを落としたら？　順番がわからなくなったら？

「これでプログラムを書く」という言葉の意味が、最初はまるで理解できなかった。私が知っているプログラミングとは、画面にコードを打ち込み、コンパイルし、エラーが出たらその場で直すものだった。パンチカードの世界には「画面」すらない。コードを書いてから結果を見るまでに、数時間、ときには一晩かかる。

「対話的にコンピュータを使う」という概念は、いつ、なぜ生まれたのか。

この問いに答えるために、まず「対話がなかった時代」を知る必要がある。コマンドラインが生まれる以前の世界――パンチカードとバッチ処理の時代に踏み込もう。

あなたは、コマンドを打ってから結果が返るまでの「待ち時間」を意識したことがあるだろうか。1秒もかからないその応答が、60年前にはどれほどの贅沢だったか、想像できるだろうか。

---

## 2. パンチカードの起源――穴に情報を刻む

### Hollerithの発明：1890年国勢調査

コンピュータにデータを入力する手段としてのパンチカードの歴史は、コンピュータそのものの歴史より古い。

1880年のアメリカ国勢調査は、深刻な問題を抱えていた。人口の増加と調査項目の複雑化により、集計作業が完了するまでに8年以上を要した。次の国勢調査は1890年。このペースでは、1890年の調査結果が出る前に1900年の調査が始まってしまう。

国勢調査局は1888年、効率的な集計方法を競争形式で募集した。ここに名乗りを上げたのが、元国勢調査局職員のHerman Hollerith（1860-1929）である。Hollerithは電気機械式の集計機を開発した。穿孔カードにデータを記録し、ピンがカードの穴を通過して水銀に接触することで電気回路が完成し、計数ダイヤルを駆動する仕組みだ。

結果は圧倒的だった。Hollerithの機械は競争でデータ処理を72.5時間で完了し、他の候補を大きく引き離した。1890年の国勢調査に採用されたHollerithの集計機は、基本集計を6ヶ月で完了させた。1880年の8年以上と比較すれば、その差は明白である。国勢調査局は500万ドルと2年以上の労力を節約したと記録されている。

ここで注目すべきは、Hollerithがカードのサイズを当時のドル紙幣と同じに設計したという事実だ。既存の紙幣保管用の金庫やトレーをそのままカード保管に流用できるようにするための実用的な判断だった。技術設計が既存のインフラとの互換性を重視する、という原則は130年以上前から存在していたのである。

### 80列フォーマットの誕生

Hollerithのカードは当初22列×8パンチ位置だった。その後、24列×10位置を経て、カード容量の拡大が求められるようになる。

1927年、IBM（Hollerithの企業は1911年に他社と合併し、1924年にIBMとなっていた）のThomas J. Watson Sr.は、二人のエンジニアに独立して容量拡大の方法を開発するよう命じた。Clair D. Lakeは長方形の穴を提案した。丸い穴よりも密に配置でき、1枚のカードに80列を収められる。1928年、この80列フォーマットが導入された。

80列。この数字に見覚えはないだろうか。

ターミナルの横幅が80文字なのは、1928年のパンチカードに由来する。VT100端末が80桁を採用したのも、その前のテレタイプの時代から80列カードが「1行の長さ」の基準だったからだ。FORTRANがソースコードを72列に制限したのは、IBM 704のカードリーダーが80列中72列しか読めず、残りの8列をシーケンス番号に使っていたからだ。カードデッキを落として順番がわからなくなったとき、この8列の番号でカードソーターにかけて復元できた。

2026年の今、あなたがlintツールで「1行80文字を超えるな」と警告されるとき、その制約の根源は1928年のパンチカードにある。技術は消えても、制約は生き続ける。

### パンチカードの支配

Hollerithの発明からIBMの80列フォーマットを経て、パンチカードは20世紀のコンピューティングの基盤メディアとなった。データの入力、プログラムの記述、結果の出力――すべてがカードを介して行われた。

1951年6月14日、J. Presper EckertとJohn Mauchlyが設計したUNIVAC Iが米国国勢調査局に納入された。ENIACの設計者コンビが作った初の商用コンピュータだ。UNIVAC Iは磁気テープを主要な入出力メディアとして採用し、パンチカードからの移行を促した。1952年11月の大統領選挙でアイゼンハワーの地滑り的勝利を正確に予測し、コンピュータの可能性を広く知らしめた。

翌1952年5月21日、IBMは最初の商用科学計算コンピュータIBM 701を発表した。開発名は「Defense Calculator」。興味深いことに、IBMは「computer」という語を避け、「Electronic Data Processing Machine（電子データ処理機）」と名付けた。「computer」はUNIVACと結びつきすぎていたからだ。3年間で19台が研究所、航空会社、連邦政府に納入された。

しかし、真のゲームチェンジャーは1959年10月5日に発表されたIBM 1401だった。「コンピュータ産業のModel T」と呼ばれたこのマシンは、1960年代半ばには世界のコンピュータの半数以上を占めるまでに普及した。10,000台以上が設置され、それまでで最も売れたコンピュータとなった。付属のIBM 1402カードリーダーは毎分800枚のカードを読み取り、IBM 1403プリンターは毎分600行（後のモデル3は最大1,400行）を印刷した。1403は競合の4倍の速度を誇り、そのインパクトは大きかった。1960年代末には、世界の連続帳票の半分がIBM 1403プリンターで印刷されていたという。

この1403プリンターの132列フォーマットは、後にターミナルの「ワイドモード」やCSVデータの表示幅の基準として受け継がれる。パンチカードの80列、プリンターの132列――物理デバイスの制約が、ソフトウェアの慣習として化石化する。この現象は、コンピューティングの歴史に繰り返し現れるパターンである。

---

## 3. バッチ処理の世界――「人間がコンピュータを待つ」時代

### なぜ「対話」は不可能だったのか

パンチカードの時代、コンピュータは「対話」するものではなかった。「仕事を依頼し、結果を待つ」ものだった。

なぜか。答えは単純だ。コンピュータが高価すぎたのである。

IBM 7090——1960年代の代表的なメインフレーム——のレンタル料は月額63,500ドルだった。現在の貨幣価値に換算すると約50万ドル、日本円にして7,500万円前後だ。電気代は別途かかる。購入するなら290万ドル。

一方、プログラマの年俸はいくらだったか。1960年代のアメリカでプログラマの平均年収は1万ドル前後だった。つまり、コンピュータの月額レンタル料はプログラマ6人分の年俸に相当する。

この経済的現実が、インターフェースの設計を決定的に規定した。コンピュータの時間は、人間の時間よりも桁違いに高い。したがって、最適化すべきは「コンピュータの稼働率」であって「人間の待ち時間」ではない。人間がコンピュータの前に座って考え込む時間は、コンピュータの遊休時間であり、許容できないコストだった。

ここから必然的に導かれたのがバッチ処理モデルだ。人間は事前にプログラムとデータを準備し、まとめて（バッチで）コンピュータに投入する。コンピュータは休むことなくジョブを処理し続ける。結果は後から受け取る。コンピュータが「人間を待つ」のではなく、人間がコンピュータを待つ。

この設計判断は、2026年の視点からは不自然に見えるかもしれない。だが当時の経済合理性を理解すれば、バッチ処理は最適解だった。1秒あたり数ドルのコストがかかるマシンを、プログラマが「うーん、次のコマンドは何にしよう」と考えている間に遊ばせておく余裕はなかったのだ。

### バッチ処理のワークフロー

では、バッチ処理の時代にプログラムを書いて実行するとは、具体的にどのような作業だったのか。

1960年代のプログラマの典型的な一日を再構成してみよう。

**ステップ1：コーディングシートへの手書き**

プログラマは、専用の「コーディングシート」と呼ばれる用紙にプログラムを手書きする。1枚のシートが1枚のパンチカード（つまり1行のコード）に対応する。数字のゼロと英字のO、数字の1と英字のI、8とBを明確に区別するため、現場ごとに「スラッシュ付きゼロ」などの記法が定められていた。この手書きのコードがすべての起点だ。画面はない。カーソルもない。バックスペースキーもない。

**ステップ2：キーパンチオペレータによる穿孔**

手書きされたコーディングシートは、キーパンチオペレータに渡される。オペレータはIBM 026（後にIBM 029）キーパンチ機を操作し、シートの内容をパンチカードに穿孔する。タイプライターに似た機械だが、紙に文字を打つ代わりにカードに穴を開ける。

注意すべきは、プログラマ自身がカードを穿孔するわけではない場合が多かったことだ。キーパンチは専門の職種だった。プログラマは「書く人」、キーパンチオペレータは「穿孔する人」。役割が分離していた。

**ステップ3：検証**

穿孔されたカードデッキは、別のオペレータがIBM 059検証機で検証する。コーディングシートの内容と穿孔結果が一致しているかを確認する工程だ。二重チェックの思想は、1960年代のパンチカード工場にすでに存在していた。

**ステップ4：ジョブの提出**

検証済みのカードデッキは、コンピュータ室のカウンターに提出される。繁忙時には、提出の順番を待つ行列ができた。文字通り、プログラムを「提出」するのである。

カードデッキの構成は、おおよそ次のようなものだった。

```
┌─────────────────────────────────────────┐
│  JCLカード（ジョブ制御）                  │  ← コンピュータへの指示
├─────────────────────────────────────────┤
│  プログラムカード（ソースコード）           │  ← プログラム本体
│  （FORTRANなら72列にコードを記述）         │
│  （残り8列はシーケンス番号）               │
├─────────────────────────────────────────┤
│  データカード（入力データ）                │  ← プログラムが処理するデータ
├─────────────────────────────────────────┤
│  終了カード                              │  ← ジョブの終端
└─────────────────────────────────────────┘
```

**ステップ5：待機**

ここからが長い。ジョブは先着順にキューに入り、順番を待つ。軽負荷のシステムなら1時間以内に結果が返ることもあったが、繁忙時には数時間、あるいは翌日になることもあった。「プログラムを提出して帰宅し、翌朝結果を見る」のが日常だった計算機室も珍しくない。

**ステップ6：結果の回収**

処理が完了すると、結果はラインプリンターで印刷され、キュビーホール（仕切り付きの棚）に置かれる。プログラマはキュビーホールを確認し、自分の出力を受け取る。

出力用紙には、プログラムの実行結果が印刷されている。うまくいっていれば結果が得られる。失敗していれば、エラーメッセージが一枚の紙に淡々と印刷されている。「Syntax error on card 47」。47枚目のカードにタイプミスがある。修正するには、ステップ1に戻り、該当するカードだけを穿孔し直し、デッキに挿入し、再度提出する。

このサイクルの一巡にかかる時間が「ターンアラウンドタイム」と呼ばれた。バッチ処理の時代、ターンアラウンドタイムは最短でも数十分、典型的には数時間だった。一つのバグを直すのに一日がかりということも珍しくなかった。

あなたがターミナルでコンパイルエラーを見て、即座にコードを修正し、再コンパイルする。その「即座に」は、60年前のプログラマにとっては夢のような話だったのだ。

### JCL――コンピュータへの指示言語

バッチ処理の世界で、プログラマとコンピュータの間を仲介したのがJCL（Job Control Language）だ。

1964年4月7日、IBMはSystem/360を発表した。商用と科学計算の両方に対応した初の汎用コンピュータファミリーである。そのOS/360向けに1965年に導入されたJCLは、「このプログラムを実行せよ」「入力データはここにある」「出力はここに書け」「メモリはこれだけ使え」といった指示をコンピュータに伝えるための言語だった。

JCLの記述は次のような形式だった。

```jcl
//MYJOB   JOB  (ACCT),'SATO',CLASS=A,MSGCLASS=X
//STEP1   EXEC PGM=FORTRANC
//SYSIN   DD   *
      PROGRAM HELLO
      WRITE(6,100)
  100 FORMAT(' HELLO, WORLD')
      STOP
      END
/*
//SYSPRINT DD  SYSOUT=A
//SYSLIN   DD  DSN=&&OBJMOD,DISP=(NEW,PASS),
//         UNIT=SYSDA,SPACE=(CYL,(1,1))
//STEP2   EXEC PGM=IEWL
//SYSLIB   DD  DSN=SYS1.FORTLIB,DISP=SHR
//SYSLIN   DD  DSN=&&OBJMOD,DISP=(OLD,DELETE)
//SYSLMOD  DD  DSN=&&LOADMOD,DISP=(NEW,PASS),
//         UNIT=SYSDA,SPACE=(CYL,(1,1),RLSE)
//STEP3   EXEC PGM=*.STEP2.SYSLMOD
//SYSPRINT DD  SYSOUT=A
```

「HELLO, WORLD」を表示するだけのプログラムに、これだけのJCLが必要だった。カラム1-2の `//` はJCLの識別子、`JOB` カードはジョブの開始、`EXEC` はプログラムの実行指示、`DD`（Data Definition）はデータセットの定義だ。コンパイル、リンク、実行を3つのステップ（STEP1, STEP2, STEP3）に分けて記述する。

Fred Brooksは「The Design of Design」（2010年）でJCLを「誰かがどこかで作った最悪のプログラミング言語」と呼んだ。OS/360のプロジェクトマネージャーだった当人が、自分たちが作った言語をそう評したのだ。

だが、JCLの複雑さには理由がある。System/360のローエンドモデル（360/30）の処理能力は毎秒1,800～34,500命令にすぎなかった。1980年代のPCよりも低い能力しかなかった。JCLは「コンピュータにとって処理しやすい」ことが最優先で設計された。人間にとっての可読性は二の次だった。プログラマの時間よりコンピュータの時間の方が高価だったからだ。

この優先順位は、現代のインターフェース設計とは正反対である。2026年の私たちは、コンピュータの計算資源が安価で、人間の時間が貴重な世界に暮らしている。コマンドの構文が人間にとって読みやすいかどうかが重視され、パースの効率はコンパイラ作者に任される。だが1960年代は違った。最も高価なリソースはコンピュータの時間であり、最適化すべき対象はコンピュータの処理効率だった。

JCLの不親切さは「設計の失敗」ではない。異なる制約下での合理的な設計判断だったのだ。

### バッチ処理モデルの設計思想

バッチ処理の本質を、もう少し抽象的に整理しよう。

```
バッチ処理モデル:

  [プログラマ]                    [コンピュータ]
       |                              |
       |  コーディングシート手書き       |
       |  キーパンチ穿孔              |
       |  カードデッキ提出            |
       |  ─────────────────→         |
       |                              |  ジョブ読み込み
       |                              |  コンパイル
       |       （待機）               |  リンク
       |       数時間〜翌日            |  実行
       |                              |  出力印刷
       |  ←─────────────────         |
       |  結果回収                    |
       |  エラー確認・修正            |
       |  ─────────────────→         |
       |         ...（繰り返し）        |


対話的処理モデル（対比）:

  [プログラマ]                    [コンピュータ]
       |                              |
       |  コマンド入力                 |
       |  ─────────────────→         |
       |                              |  処理（ミリ秒〜秒）
       |  ←─────────────────         |
       |  結果確認                    |
       |  次のコマンド入力             |
       |  ─────────────────→         |
       |                              |  処理（ミリ秒〜秒）
       |  ←─────────────────         |
       |         ...（繰り返し）        |
```

バッチ処理モデルの核心は、**入力と出力の時間的分離**にある。プログラマがデータを投入してから結果を受け取るまでに、長い時間的ギャップが存在する。このギャップの間、コンピュータは他のジョブを処理し続けている。コンピュータの稼働率は高い。だが人間のフィードバックループは致命的に遅い。

対話的処理モデルでは、入力と出力がほぼリアルタイムで交互に行われる。フィードバックループが短い。人間はすぐに結果を確認し、次の行動を決められる。しかしこれは、コンピュータが「人間の入力を待つ」時間を許容することを意味する。コンピュータの稼働率は、バッチ処理に比べて低くなる。

バッチ処理から対話的処理への移行は、単なる技術的進歩ではない。「誰の時間が最も貴重か」という**経済的価値判断の逆転**だったのである。

---

## 4. ハンズオン：バッチ処理を疑似体験する

バッチ処理の世界を理屈だけでなく手で触って理解するために、シェルスクリプトで「バッチ処理風」のワークフローを構築する。JCLそのものを再現するのではなく、バッチ処理の本質――「入力ファイルを事前に準備し、処理を投入し、結果を後から回収する」――を体験する。

### 環境準備

Docker環境で作業する。

```bash
docker run -it --rm ubuntu:24.04 bash
```

コンテナ内で必要なパッケージをインストールする。

```bash
apt-get update && apt-get install -y coreutils gawk bc
```

### 演習1：非対話的パイプライン――「入力デッキ」から「印刷出力」へ

バッチ処理の核心は「入力→処理→出力」の非対話的パイプラインだ。まず、これを体験する。

```bash
# 作業ディレクトリを作成
mkdir -p /workspace/batch-sim
cd /workspace/batch-sim

# === 入力デッキの準備（パンチカードに相当） ===
# 売上データを「入力カード」として作成する
cat > input_deck.dat << 'EOF'
SALES 2025-01-15 TOKYO     150000
SALES 2025-01-20 OSAKA     98000
SALES 2025-02-03 TOKYO     210000
SALES 2025-02-14 NAGOYA    75000
SALES 2025-03-01 OSAKA     180000
SALES 2025-03-10 TOKYO     320000
SALES 2025-03-22 NAGOYA    60000
SALES 2025-04-05 TOKYO     195000
SALES 2025-04-18 OSAKA     145000
SALES 2025-04-30 NAGOYA    88000
EOF

echo "=== 入力デッキ（10枚のデータカード） ==="
cat -n input_deck.dat
```

次に、「ジョブスクリプト」を書く。これがJCLに相当する。

```bash
# === ジョブスクリプトの作成（JCLに相当） ===
cat > job_sales_report.sh << 'ENDJOB'
#!/bin/bash
# JOB: SALES_REPORT
# CLASS: A
# PROGRAMMER: SATO
# DATE: 2025-04-30
set -euo pipefail

INPUT_FILE="${1:?入力ファイルが指定されていません}"
OUTPUT_DIR="${2:?出力ディレクトリが指定されていません}"
mkdir -p "$OUTPUT_DIR"

echo "*** JOB SALES_REPORT STARTED ***"
echo "*** INPUT: $INPUT_FILE ***"
echo ""

# STEP1: データ検証（入力カードの読み取り）
echo "--- STEP1: DATA VALIDATION ---"
TOTAL_CARDS=$(wc -l < "$INPUT_FILE")
VALID_CARDS=$(grep -c '^SALES' "$INPUT_FILE" || true)
echo "TOTAL CARDS READ: $TOTAL_CARDS"
echo "VALID CARDS: $VALID_CARDS"
if [ "$TOTAL_CARDS" -ne "$VALID_CARDS" ]; then
    echo "*** WARNING: INVALID CARDS DETECTED ***"
fi
echo ""

# STEP2: 地域別集計
echo "--- STEP2: REGIONAL SUMMARY ---"
awk '{region[$3]+=$4; count[$3]++}
     END{
       printf "%-12s %8s %6s %10s\n", "REGION", "TOTAL", "COUNT", "AVERAGE"
       printf "%-12s %8s %6s %10s\n", "--------", "------", "-----", "-------"
       for(r in region){
         printf "%-12s %8d %6d %10d\n", r, region[r], count[r], region[r]/count[r]
       }
     }' "$INPUT_FILE" > "$OUTPUT_DIR/regional_summary.txt"
cat "$OUTPUT_DIR/regional_summary.txt"
echo ""

# STEP3: 月別集計
echo "--- STEP3: MONTHLY SUMMARY ---"
awk '{
       split($2, d, "-")
       month=d[1]"-"d[2]
       monthly[month]+=$4
       mcount[month]++
     }
     END{
       n=asorti(monthly, sorted)
       printf "%-10s %10s %6s\n", "MONTH", "TOTAL", "COUNT"
       printf "%-10s %10s %6s\n", "-------", "------", "-----"
       for(i=1;i<=n;i++){
         printf "%-10s %10d %6d\n", sorted[i], monthly[sorted[i]], mcount[sorted[i]]
       }
     }' "$INPUT_FILE" > "$OUTPUT_DIR/monthly_summary.txt"
cat "$OUTPUT_DIR/monthly_summary.txt"
echo ""

# STEP4: 総合計
echo "--- STEP4: GRAND TOTAL ---"
GRAND_TOTAL=$(awk '{sum+=$4} END{print sum}' "$INPUT_FILE")
echo "GRAND TOTAL: $GRAND_TOTAL"
echo "$GRAND_TOTAL" > "$OUTPUT_DIR/grand_total.txt"
echo ""

echo "*** JOB SALES_REPORT COMPLETED ***"
echo "*** OUTPUT FILES IN: $OUTPUT_DIR ***"
ENDJOB
chmod +x job_sales_report.sh
echo "=== ジョブスクリプト作成完了 ==="
```

ジョブを「提出」する。

```bash
# === ジョブの提出と実行 ===
# バッチ処理では、提出後は結果を「待つ」だけ
echo "=== SUBMITTING JOB... ==="
echo ""
bash job_sales_report.sh input_deck.dat /workspace/batch-sim/output
echo ""
echo "=== 出力ファイル一覧 ==="
ls -la /workspace/batch-sim/output/
```

ここで注目してほしいのは、一度ジョブを提出したら、途中で「やっぱりNAGOYAだけ見たい」と方針を変えることはできない点だ。入力データとジョブスクリプトは事前にすべて確定させておく必要がある。途中結果を見て次の処理を決める――つまり「対話」は、このモデルでは構造的に不可能だ。

### 演習2：ターンアラウンドタイムの疑似体験

バッチ処理の最大の苦痛は「待ち時間」だった。これを疑似的に体験する。

```bash
# === バッチ処理シミュレーター ===
# わざと待ち時間を入れて、バッチ処理のリズムを体験する

cat > batch_simulator.sh << 'ENDSIM'
#!/bin/bash
set -euo pipefail

echo "================================================"
echo "  BATCH PROCESSING SIMULATOR"
echo "  Simulating 1960s turnaround time (compressed)"
echo "================================================"
echo ""

# ジョブ提出
echo "[$(date +%H:%M:%S)] JOB SUBMITTED TO QUEUE"
echo "  Waiting for available resources..."
sleep 3

# カード読み取り
echo "[$(date +%H:%M:%S)] CARD READER: READING INPUT DECK"
for i in $(seq 1 5); do
    echo "  Reading card $i of 5..."
    sleep 1
done

# コンパイル
echo "[$(date +%H:%M:%S)] COMPILER: FORTRAN IV"
echo "  Compiling source..."
sleep 2

# ここでエラーを発生させる
echo "[$(date +%H:%M:%S)] *** COMPILATION ERROR ***"
echo "  ERROR ON CARD 3: UNDEFINED VARIABLE 'TOTL'"
echo "  (Did you mean 'TOTAL'?)"
echo ""
echo "[$(date +%H:%M:%S)] JOB TERMINATED WITH ERRORS"
echo ""
echo "================================================"
echo "  To fix this error in 1965, you would:"
echo "  1. Walk to cubbyhole to pick up printout"
echo "  2. Read the error message"
echo "  3. Find card 3 in your deck"
echo "  4. Retype the corrected card on a keypunch"
echo "  5. Resubmit the entire deck"
echo "  6. Wait again..."
echo ""
echo "  Estimated turnaround: 2-4 hours"
echo "  In your terminal today: ~2 seconds"
echo "================================================"
ENDSIM
chmod +x batch_simulator.sh
bash batch_simulator.sh
```

たった1つの変数名のタイプミス。2026年のターミナルなら、コンパイルエラーを見て即座に修正し、2秒で再コンパイルできる。1965年のバッチ処理では、同じバグの修正に数時間を要した。

この体験が、なぜ1960年代のプログラマたちが「対話的コンピューティング」を切望したかを理解する手がかりになる。

### 演習3：対話的処理との比較

最後に、同じタスクを「対話的に」実行し、バッチ処理との違いを実感する。

```bash
# === 対話的処理：同じデータを段階的に探索する ===
cd /workspace/batch-sim

echo "=== 対話的処理の利点：段階的な探索 ==="
echo ""

# まず全体を見る
echo "--- Step 1: データの概観 ---"
cat input_deck.dat
echo ""

# TOKYOだけ見たい（バッチ処理では事前に決めておく必要がある）
echo "--- Step 2: TOKYOのデータだけ見る（対話的判断） ---"
grep "TOKYO" input_deck.dat
echo ""

# TOKYOの合計を知りたい（前のステップの結果を見て決めた）
echo "--- Step 3: TOKYOの売上合計（前の結果を見て判断） ---"
grep "TOKYO" input_deck.dat | awk '{sum+=$4} END{printf "TOKYO TOTAL: %d\n", sum}'
echo ""

# 最大値は？（さらに深掘り）
echo "--- Step 4: TOKYOの最高売上月（さらに深掘り） ---"
grep "TOKYO" input_deck.dat | sort -k4 -rn | head -1
echo ""

echo "=== 比較 ==="
echo "バッチ処理: 全ての分析を事前に設計し、一括実行して結果を待つ"
echo "対話的処理: 結果を見ながら次の分析を決める。探索的な作業が可能"
```

対話的処理の本質は「フィードバックループの短さ」にある。結果を見て、次の行動を決められる。「TOKYOのデータが多いな」と気づいてからTOKYOだけを抽出する――この「気づきからの即座のアクション」は、バッチ処理では構造的に不可能だった。

---

## 5. まとめと次回予告

### この回の要点

第一に、パンチカードの歴史はコンピュータの歴史より古い。Herman Hollerithが1890年の国勢調査のために発明した穿孔カードシステムが、IBMの80列フォーマット（1928年）を経て、20世紀のコンピューティングの基盤メディアとなった。80列という数字は、ターミナルの横幅として2026年の今も私たちの環境に刻まれている。

第二に、バッチ処理は「対話がない」世界だった。プログラマはコーディングシートにコードを手書きし、キーパンチオペレータに穿孔を依頼し、カードデッキをコンピュータ室に提出し、結果を待った。ターンアラウンドタイムは数時間から翌日。一つのバグの修正に一日を費やすこともあった。

第三に、バッチ処理の設計は経済合理性に基づいていた。IBM 7090のレンタル料が月額63,500ドルの世界では、コンピュータの稼働率を最大化することが最優先であり、人間の待ち時間は最適化の対象ではなかった。JCLの「人間に不親切な」設計も、コンピュータの処理効率を優先した合理的な判断だった。

第四に、バッチ処理と対話的処理の本質的な違いは「フィードバックループの長さ」にある。バッチ処理では入力と出力が時間的に分離している。対話的処理ではそれらがほぼリアルタイムで交互に行われる。この差は、単なる利便性の問題ではなく、思考のプロセスそのものに影響を与える。

### 冒頭の問いへの暫定回答

「対話的にコンピュータを使う」という概念は、いつ、なぜ生まれたのか。

暫定的な答えはこうだ。**対話的コンピューティングは「自然な姿」ではなく、技術的ブレークスルーの結果として可能になった贅沢だった。** バッチ処理の時代には、コンピュータの計算資源が高価すぎて、人間が対話的に使う余裕がなかった。コンピュータの価格が下がり、タイムシェアリングという技術が発明されて初めて、「コマンドを打てば即座に結果が返る」世界が実現した。

あなたがターミナルに `ls` と打って即座にファイル一覧が返る。その瞬間、あなたは1960年代のプログラマが夢見た「贅沢」を享受している。

### 次回予告

バッチ処理の非効率に苦しんだ人々は、やがて「コンピュータと対話する」方法を模索し始める。

1960年、J.C.R. Lickliderは「Man-Computer Symbiosis（人間とコンピュータの共生）」という論文で、人間とコンピュータがリアルタイムで協調する未来を構想した。そして1961年、MITのFernando Corbatoは、一台のコンピュータを複数の人間が同時に対話的に使う「タイムシェアリング」の実証実験に成功する。CTSS（Compatible Time-Sharing System）と名付けられたそのシステムは、バッチ処理の時代に終わりを告げる最初の一撃となった。

次回、第3回「対話の始まり――CTSSとタイムシェアリングの革命」では、この対話的コンピューティングの誕生を追う。「コンピュータと会話する」という概念を最初に実現した人々は、何と戦い、何を勝ち取ったのか。

あなたが毎日使っているターミナルの「対話性」は、どこから来たのだろうか。

---

## 参考文献

- U.S. Census Bureau, "The Hollerith Machine", <https://www.census.gov/history/www/innovations/technology/the_hollerith_tabulator.html>
- IBM, "The punched card", <https://www.ibm.com/history/punched-card>
- National Museum of American History, "From Herman Hollerith to IBM", <https://americanhistory.si.edu/collections/object-groups/tabulating-equipment/from-herman-hollerith-to-ibm>
- U.S. Census Bureau, "UNIVAC I", <https://www.census.gov/about/history/bureau-history/census-innovations/technology/univac-i.html>
- IBM, "IBM 700 Series", <https://www.ibm.com/history/700>
- Wikipedia, "IBM 701", <https://en.wikipedia.org/wiki/IBM_701>
- IBM, "The IBM 1401", <https://www.ibm.com/history/1401>
- Computer History Museum, "IBM 1401 Demo Lab", <https://computerhistory.org/exhibits/ibm1401/>
- IEEE Spectrum, "How the IBM 1403 Printer Hammered Out 1,100 Lines Per Minute", <https://spectrum.ieee.org/how-the-ibm-1403-printer-hammered-out-1100-lines-per-minute>
- Wikipedia, "IBM System/360", <https://en.wikipedia.org/wiki/IBM_System/360>
- Wikipedia, "Job Control Language", <https://en.wikipedia.org/wiki/Job_Control_Language>
- Wikipedia, "IBM 7090", <https://en.wikipedia.org/wiki/IBM_7090>
- Wikipedia, "Computer programming in the punched card era", <https://en.wikipedia.org/wiki/Computer_programming_in_the_punched_card_era>
- Wikipedia, "The Mythical Man-Month", <https://en.wikipedia.org/wiki/The_Mythical_Man-Month>
- J.C.R. Licklider, "Man-Computer Symbiosis", IRE Transactions on Human Factors in Electronics, 1960, <https://groups.csail.mit.edu/medg/people/psz/Licklider.html>
- Multicians.org, "Compatible Time-Sharing System (1961-1973) Fiftieth Anniversary", <https://multicians.org/thvv/compatible-time-sharing-system.pdf>

---

**次回：** 第3回「対話の始まり――CTSSとタイムシェアリングの革命」

---

_本記事は「ターミナルは遺物か――コマンドラインの本質を問い直す」連載の第2回です。_
_ライセンス：CC BY-SA 4.0_
