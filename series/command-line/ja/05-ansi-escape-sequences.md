# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第5回：ANSIエスケープシーケンス――端末の表現力の拡張

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- エスケープシーケンスの基本構造――ESC [ で始まるCSI（Control Sequence Introducer）のプロトコル設計
- ECMA-48（1976年）からANSI X3.64（1979年）への標準化の経緯と、VT100がその普及を決定づけた背景
- SGR（Select Graphic Rendition）パラメータによる文字装飾と色制御の仕組み
- 8色→16色→256色→24ビットTrue Colorへの段階的な色空間拡張の歴史
- termcap（Bill Joy, 1977年）からterminfo、curses、ncursesへと続く端末抽象化レイヤーの系譜
- 端末間の非互換性という「地獄」と、それを解決しようとしたソフトウェアの知恵
- tputコマンドによる端末非依存のスクリプティング手法

---

## 1. `\033[32m`という呪文

あるとき、私は`.bashrc`をいじっていた。

プロンプトに色を付けたかった。ただそれだけの目的で、インターネット上のコード断片をコピーした。

```bash
PS1='\[\033[32m\]\u@\h\[\033[0m\]:\[\033[34m\]\w\[\033[0m\]\$ '
```

コピーして、ペーストして、ターミナルを再起動した。プロンプトが緑色になった。ディレクトリパスが青色になった。それだけ見れば成功だ。だが私は、自分が何をしたのかまったく理解していなかった。

`\033`とは何か。`[32m`とは何を意味するのか。なぜ`\[`と`\]`で囲む必要があるのか。そして、この呪文のような文字列が、なぜ「色」という視覚的な効果を生むのか。

この疑問は長い間放置されていた。プロンプトは緑色に光り続け、私はその仕組みを知らないまま毎日ターミナルを使い続けた。

転機は、ncursesベースのアプリケーションに出会ったときだった。`htop`の色鮮やかなプロセスモニタ。`mc`（Midnight Commander、1994年にMiguel de Icazaが開発を開始したNorton Commanderクローン）の二画面ファイルマネージャ。テキストしか表示できないはずの端末に、なぜこれほどの表現力があるのか。罫線が引かれ、色が塗られ、カーソルが自在に動き回る。GUIではない。だがプレーンテキストでもない。

その答えは、すべて`\033[`の先にあった。

テキストしか表示できないはずの端末に、なぜ色やカーソル移動があるのか。この問いに答えるには、1976年にヨーロッパの標準化団体が策定した規格書まで遡る必要がある。

---

## 2. 標準化以前の混沌――端末バベルの塔

### なぜ統一規格が必要だったのか

前回、DEC VT52のエスケープシーケンスを紹介した。`ESC A`でカーソルを上に移動し、`ESC B`で下に移動する、あのシンプルな体系だ。VT52のエスケープシーケンスはDECの独自仕様だった。そして1970年代後半、端末メーカーは各社がそれぞれ独自の制御シーケンスを実装していた。

問題の規模を具体的に示そう。1970年代後半から1980年代初頭にかけて、端末市場にはDEC、Lear-Siegler、Hazeltine、Heath/Zenith、Hewlett-Packard、IBM、Televideo、Wyseなど、少なくとも十数社のメーカーが存在した。各社の端末は、同じ操作――たとえば「カーソルを画面の左上に移動する」――に対して、まったく異なるバイト列を要求した。

```
同じ操作「カーソルを指定位置に移動」の端末ごとの差異:

DEC VT52:      ESC Y row col
  （ESC + Y + 行座標 + 列座標、座標は値+32のASCII文字）

Hazeltine 1500: ~ DC1 col row
  （~（チルダ）+ DC1(0x11) + 列 + 行、ESCではなく~を使用）

ADM-3A:        ESC = row col
  （ESC + = + 行座標 + 列座標）

Televideo 950:  ESC = row col
  （ADM-3Aと同じ方式を採用）

HP 2645:       ESC & a col c row Y
  （ESC + &a + 列番号 + c + 行番号 + Y）
```

Hazeltine 1500は、エスケープ文字として`ESC`（ASCII 27）ではなく`~`（チルダ、ASCII 126）を使用していた。この設計判断は、当時のソフトウェア開発者にとって悪夢だった。`~`は通常の印字可能文字であり、テキスト中に出現しうる。制御文字と通常文字の区別が曖昧になるのだ。

この非互換性が引き起こす実害は深刻だった。端末Aで動作するプログラムが端末Bでは画面が崩れる。大学や企業の計算機室には複数メーカーの端末が混在しており（UCバークレーではLear-Siegler ADM-3Aと他の端末が共存していた）、管理者はプログラムごとに端末の種類を指定するか、端末ごとにプログラムを書き分ける必要があった。

この「端末バベルの塔」を解決するために、二つのまったく異なるアプローチが生まれた。一つは標準規格の策定。もう一つは、ソフトウェアによる抽象化だ。

### ECMA-48：1976年の標準化

最初のアプローチは、ヨーロッパから始まった。

1976年9月、ECMA（European Computer Manufacturers Association、現Ecma International）はECMA-48の初版を発行した。正式名称は「Control Functions for Coded Character Sets」。文字コード体系における制御機能を標準化する規格であり、端末の制御シーケンスの統一的な構文を定義するものだった。

ECMA-48は、1965年のECMA-6（7ビット文字コード規格、ISO 646の前身）から続く文字コード標準化の系譜に位置する。ASCIIのESC文字（ASCII 27）を起点として、端末の制御シーケンスを体系的に分類し、構文規則を定めた。

この規格の核心は、**CSI（Control Sequence Introducer）**の定義にある。CSIは`ESC [`（ESC文字に続く左角括弧）という2バイトの導入子で始まり、数値パラメータと終端文字で構成されるシーケンスを導く。前回紹介したVT52の`ESC A`（カーソル上移動）のような「ESC + 1文字」の単純な方式から、パラメータ付きの柔軟な体系への進化だった。

1979年、ANSI（American National Standards Institute）がECMA-48とほぼ同一の内容をANSI X3.64として採択した。ECMA委員会TC 1とANSI委員会X3L2が協調して策定した結果であり、両規格はほぼ同一の内容を持つ。1983年にはISO 6429として国際標準化された。

```
標準化の系譜:

ECMA-48 初版 (1976年9月)
  ↓
ANSI X3.64 (1979年)
  ↓ ← ECMA委員会TC 1とANSI委員会X3L2の協調
ISO 6429 (1983年)
  ↓
ECMA-48 第5版 (1991年) ← 現行版
  ↓
ANSI X3.64 撤回 (1994年) → 国際標準ISO 6429に一本化
```

ここで注目すべき時系列がある。ECMA-48の初版は1976年。DEC VT100の発表は1978年8月。ANSI X3.64の採択は1979年。つまり、VT100はECMA-48の初版が既に存在する状態で設計され、その規格に準拠した端末として市場に投入された。VT100が「ANSI準拠」と呼ばれるのは、厳密にはECMA-48準拠であり、ANSI X3.64はVT100発表の翌年に策定されたのだ。

だが、標準が存在することと、標準が普及することは別の問題である。VT100の圧倒的な市場シェア（VTシリーズ累計600万台以上）が、ECMA-48/ANSI X3.64の事実上の普及を推進した。規格が製品を導いたのか、製品が規格を普及させたのか。その答えはおそらく「両方」だ。

### termcap：ソフトウェアによる抽象化

もう一つのアプローチは、ソフトウェアの側から来た。

1977年9月、UCバークレーの大学院生だったBill Joyは「ttycap」と呼ばれるデータベースの開発を始めた。動機は明快だった。Joyが開発したviエディタを、異なる種類の端末で動作させたかったのだ。

当時のバークレーの計算機環境には、Lear-Siegler ADM-3Aをはじめとする複数メーカーの端末が混在していた。viをADM-3Aで動かすためのエスケープシーケンスをハードコードすれば、他の端末では動かない。端末が変わるたびにソースコードを書き換えるのは非現実的だ。

Joyの解決策は、端末の能力（capability）をデータベースとして外部化し、プログラムが実行時に端末の種類に応じたエスケープシーケンスを取得する仕組みだった。このアイデアは、MIT ITS（Incompatible Timesharing System）の端末データストアに影響を受けたものだった。

ttycapは1978年3月の1BSDで初めてリリースされ、1979年12月の3BSDでtermcapとして標準的な形に整えられた。

```
termcapエントリの例（VT100）:

vt100|vt100-am|dec vt100 (w/advanced video):\
    :co#80:li#24:cl=50\E[;H\E[2J:bs:am:cm=5\E[%i%d;%dH:\
    :nd=2\E[C:up=2\E[A:ce=3\E[K:cd=50\E[J:so=2\E[7m:\
    :se=2\E[m:us=2\E[4m:ue=2\E[m:md=2\E[1m:mr=2\E[7m:\
    :mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
    :rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:\
    :ke=\E[?1l\E>:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:\
    :kb=^H:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
    :pt:sr=5\E[M:vt#3:xn:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:
```

この暗号のような文字列が、VT100端末の能力を記述している。`co#80`は列数80、`li#24`は行数24、`cl=50\E[;H\E[2J`は画面クリアのシーケンス（50ミリ秒のパディング付き）、`cm=5\E[%i%d;%dH`はカーソル移動のシーケンスだ。

termcapの設計思想は明快だった。プログラムは`cm`（cursor move）や`cl`（clear screen）といった抽象的な能力名を使ってコードを書く。実行時にtermcapデータベースから、現在の端末に対応するエスケープシーケンスを取得する。端末が変わっても、プログラムのコードを変更する必要はない。`TERM`環境変数が指す端末名に応じて、データベースの参照先が切り替わるだけだ。

```
termcapによる抽象化:

┌──────────────────────────────────────────────┐
│  アプリケーション（vi, more, ...）           │
│  「カーソルを10行5列に移動」                 │
│    → termcapの "cm" 能力を要求               │
└──────────────────────────────────────────────┘
          │
          │ TERM環境変数を参照
          ▼
┌──────────────────────────────────────────────┐
│  termcapデータベース                         │
│                                              │
│  TERM=vt100 の場合:                          │
│    cm = \E[%i%d;%dH  → ESC[10;5H             │
│                                              │
│  TERM=adm3a の場合:                          │
│    cm = \E=%+ %+    → ESC = * %              │
│                                              │
│  TERM=hz1500 の場合:                         │
│    cm = ~\021%+!%+! → ~(DC1)(col)(row)       │
└──────────────────────────────────────────────┘
          │
          │ 端末に応じたバイト列を出力
          ▼
┌──────────────────────────────────────────────┐
│  端末（VT100, ADM-3A, Hazeltine 1500 ...）   │
│  → 各端末が理解するシーケンスでカーソル移動   │
└──────────────────────────────────────────────┘
```

この仕組みが、「端末バベルの塔」に対するソフトウェア側の回答だった。端末ハードウェアの非互換性を、データベースと間接参照で吸収する。

### curses：端末抽象化のAPI

termcapがデータベースだとすれば、そのデータベースを利用するためのAPIが必要だった。

1978年、同じくUCバークレーのKen ArnoldがcursesライブラリをBSD UNIX向けに開発した。名前は「cursor optimization」の駄洒落である。cursesはtermcapデータベースを内部で参照し、端末の種類を意識せずに画面操作を行うためのC言語ライブラリだった。

```c
/* cursesを使った画面操作の例 */
#include <curses.h>

int main(void) {
    initscr();           /* cursesの初期化 */
    cbreak();            /* 行バッファリングを無効化 */
    noecho();            /* 入力エコーを抑制 */

    move(10, 5);         /* カーソルを10行5列に移動 */
    addstr("Hello");     /* 文字列を出力 */
    refresh();           /* 画面を更新 */

    getch();             /* キー入力を待つ */
    endwin();            /* cursesを終了 */
    return 0;
}
```

このコードは、VT100でもADM-3AでもHazeltine 1500でも（termcapにエントリがある限り）同じように動作する。`move(10, 5)`がどのようなバイト列に変換されるかは、cursesライブラリがtermcapデータベースを参照して決定する。プログラマは端末の種類を気にする必要がない。

cursesの設計には、通信速度への配慮も組み込まれていた。「カーソル最適化」という名前の通り、画面の更新を最小限のバイト列で実現するアルゴリズムを内蔵している。たとえば、画面の一部だけが変更された場合、変更箇所だけにカーソルを移動して書き換える。300ボーの回線で画面全体を再描画すると1分以上かかるが、差分だけを更新すれば数秒で済む。

### terminfoとncurses：抽象化の継承

termcapには限界があった。エントリのサイズに1024バイトの制限があり、複雑な端末の能力を完全に記述するには不十分だった。また、テキストファイル全体を線形に検索するため、端末の種類が増えるとパフォーマンスが低下した。

AT&TのUNIX System V Release 2（1984年頃）では、termcapの後継としてterminfoが導入された。terminfoはバイナリ形式でデータを格納し、端末名の先頭文字をディレクトリ名として使うファイルシステム構造を採用することで、検索を高速化した。能力名もtermcapの短い2文字略称（`cm`、`cl`など）から、より長く読みやすい名前（`cup`、`clear`など）に改められた。

BSD系はtermcapを使い続け、System V系はterminfoを採用した。UNIX文化の二つの系統が、端末データベースの形式においても分裂したのだ。

この分裂を統合する役割を果たしたのが、ncurses（new curses）だった。元はPavel Curtisが1982年頃にpcursesとして作成し、Zeyd Ben-Halimが引き継いで1993年にncurses 1.8.1としてリリースした。Eric S. Raymondがフォームやメニューのライブラリを追加し、1996年以降はThomas Dickeyがメンテナを担当している。ncursesはterminfoデータベースを使用しつつ、cursesのAPIを維持することで、BSD由来のプログラムとSystem V由来のプログラムの両方をサポートした。

2026年の今、`htop`、`tmux`、`vim`、その他多くのTUIアプリケーションはncursesを使用している。50年近く前にBill Joyが始めた端末抽象化の系譜は、形を変えながらも現役で動き続けている。

---

## 3. CSIシーケンスの解剖学

### プロトコル構造

端末の非互換性問題と、その解決策としての標準規格・抽象化レイヤーの歴史を辿った。ここからは、ECMA-48/ANSI X3.64が定めたエスケープシーケンスの技術的構造を詳しく見ていく。

CSI（Control Sequence Introducer）シーケンスは、ECMA-48が定義する制御シーケンスの中で最も広く使われる形式だ。その構造は厳密に規定されている。

```
CSIシーケンスの構造:

ESC [  パラメータ  中間文字  終端文字
0x1B 0x5B  0x30-0x3F  0x20-0x2F  0x40-0x7E

具体例:

ESC [ 3 1 m
│   │ │ │ │
│   │ │ │ └─ 終端文字 'm' (0x6D) → SGR（Select Graphic Rendition）
│   │ │ └─── パラメータ '1' (0x31) → 赤色の '1'
│   │ └───── パラメータ '3' (0x30) → 前景色の '3'
│   └─────── '[' (0x5B) → CSIの一部
└─────────── ESC (0x1B) → エスケープ文字

つまり ESC[31m は「前景色を赤に設定」
```

終端文字がシーケンスの種類を決定する。主要な終端文字とその意味は以下の通りだ。

```
主要なCSIシーケンスの終端文字:

  m  - SGR（Select Graphic Rendition）
       文字の装飾、色、太字、下線などを設定

  A  - CUU（Cursor Up）
       カーソルを上にn行移動

  B  - CUD（Cursor Down）
       カーソルを下にn行移動

  C  - CUF（Cursor Forward）
       カーソルを右にn列移動

  D  - CUB（Cursor Back）
       カーソルを左にn列移動

  H  - CUP（Cursor Position）
       カーソルをn行m列に移動

  J  - ED（Erase in Display）
       画面の消去（0:カーソル以降, 1:カーソル以前, 2:全画面）

  K  - EL（Erase in Line）
       行の消去（0:カーソル以降, 1:カーソル以前, 2:全行）

  h  - SM（Set Mode）
       端末モードの設定

  l  - RM（Reset Mode）
       端末モードのリセット
```

パラメータはセミコロンで区切って複数指定できる。たとえば `ESC[10;5H` は「カーソルを10行5列に移動」、`ESC[1;31m` は「太字かつ赤色」を意味する。パラメータが省略された場合のデフォルト値も規定されている（多くの場合は0または1）。

この構造の設計が優れている点は、拡張性にある。終端文字のアルファベットは26文字（大文字小文字で52文字）使えるため、パラメータとの組み合わせで膨大な数の制御命令を定義できる。VT52の「ESC + 1文字」方式では26種類の命令しか定義できなかったが、CSIシーケンスでは事実上無限の拡張が可能だ。

### SGR：文字に色を与える

CSIシーケンスの中で、日常的に最も多く使われるのがSGR（Select Graphic Rendition）だ。終端文字`m`で識別される。

冒頭の`\033[32m`を解読しよう。`\033`はESCのオクタル表記（8進数の27）、`[`はCSIの開始、`32`はSGRパラメータ、`m`は終端文字。SGRパラメータ32は「前景色を緑に設定」を意味する。

```
SGRパラメータ（基本属性）:

  0   - リセット（すべての属性を解除）
  1   - 太字（Bold）
  2   - 暗い色（Dim / Faint）
  3   - イタリック
  4   - 下線（Underline）
  5   - 点滅（Blink）
  7   - 反転（Reverse Video）
  8   - 非表示（Hidden）
  9   - 取り消し線（Strikethrough）

SGRパラメータ（前景色 / 背景色）:

  前景色      背景色      色
  ────────    ────────    ──────
  30          40          黒
  31          41          赤
  32          42          緑
  33          43          黄（ダークイエロー）
  34          44          青
  35          45          マゼンタ
  36          46          シアン
  37          47          白

  39          49          デフォルト色に戻す
```

この色番号の割り当てには、歴史的な経緯がある。30-37の8色は、ECMA-48が定義したオリジナルの色セットだ。黒・赤・緑・黄・青・マゼンタ・シアン・白という組み合わせは、CGA（Color Graphics Adapter、IBMが1981年に発表したPCグラフィックスカード）の色パレットとも類似している。

興味深いのは、太字（SGRパラメータ1）と色の関係だ。多くの端末は、「太字」を「より明るい色」として実装した。つまり、`ESC[1;31m`は「太字の赤」ではなく「明るい赤（ライトレッド）」として表示された。この実装上の慣習により、8色の基本パレットが事実上16色に拡張された。後にSGRパラメータ90-97（明るい前景色）と100-107（明るい背景色）が正式に定義されたが、「太字=明るい色」という慣習はそれ以前から広く浸透していた。

```
太字による色の拡張（事実上の16色）:

通常色（30-37）:         太字 or 明るい色（90-97）:
  30: 黒                    90: 暗い灰色
  31: 赤                    91: 明るい赤
  32: 緑                    92: 明るい緑
  33: 黄（暗い）            93: 明るい黄
  34: 青                    94: 明るい青
  35: マゼンタ              95: 明るいマゼンタ
  36: シアン                96: 明るいシアン
  37: 白（灰色）            97: 明るい白
```

複数のSGRパラメータをセミコロンで連結できる。`ESC[1;4;31m`は「太字 + 下線 + 赤色」だ。リセットする際は`ESC[0m`（すべての属性を解除）を使う。これを忘れると、以降のすべてのテキストが装飾されたまま表示される。シェルスクリプトでの色付き出力が「尾を引いて」後続の出力を汚染する現象は、たいていリセットの忘れが原因だ。

### 256色拡張：1999年のxterm

8色（事実上16色）のパレットは、長い間ターミナルの限界だった。GUIアプリケーションが数百万色を使う時代に、ターミナルは16色で表現しなければならなかった。

この限界を打ち破ったのは、1999年にTodd Larasonがxtermに提供したパッチだった。256色のカラーパレットを新しいエスケープシーケンスで指定できるようにしたのだ。

```
256色パレットの構造:

  0-7:     標準8色（SGR 30-37と同じ）
  8-15:    高輝度8色（SGR 90-97と同じ）
  16-231:  6x6x6 RGBカラーキューブ（216色）
  232-255: グレースケール（24段階）

エスケープシーケンス:
  前景色: ESC[38;5;{n}m   （nは0-255）
  背景色: ESC[48;5;{n}m   （nは0-255）

RGBカラーキューブの計算:
  インデックス = 16 + 36*r + 6*g + b
  （r, g, b はそれぞれ 0-5 の6段階）

例:
  ESC[38;5;196m  → 明るい赤（カラーキューブ内）
  ESC[48;5;240m  → 中間グレーの背景
```

6x6x6のRGBカラーキューブという選択は、巧みな妥協だった。各色成分を6段階に量子化することで、216色のカラーバリエーションを得る。これに標準16色とグレースケール24段階を加えて、合計256色。256という数は8ビットで表現できる最大値であり、パレットインデックスを1バイトで指定できる。

ここに一つ興味深い逸話がある。256色のエスケープシーケンスでセミコロン（`;`）がパラメータの区切りに使われている理由だ。ECMA-48の正式な構文規則によれば、SGRパラメータの拡張にはコロン（`:`）が区切り文字として使われるべきだった。だが、Todd Larasonがパッチを書いた1999年当時、正式な仕様書であるITU T.416（ISO 8613-6）は高価で入手困難だった。Thomas Dickey（xtermのメンテナ）によれば、仕様書が手に入らなかったため、既存のSGRパラメータと同じセミコロン区切りが採用されたのだという。仕様書の入手困難さが、事実上の標準を形成してしまった例だ。

### 24ビットTrue Color：1677万色の世界

256色でも表現力は劇的に向上したが、各色成分が6段階という量子化はグラデーションの滑らかさに限界があった。WebデザインやGUI開発で24ビットカラー（各色8ビット、約1677万色）が当たり前になった2010年代、ターミナルにもTrue Colorを求める声が高まった。

24ビットTrue Colorのエスケープシーケンスは、256色拡張のさらなる拡張として定義された。

```
24ビットTrue Colorのエスケープシーケンス:

  前景色: ESC[38;2;{r};{g};{b}m   （r, g, b は 0-255）
  背景色: ESC[48;2;{r};{g};{b}m   （r, g, b は 0-255）

例:
  ESC[38;2;255;165;0m    → オレンジ色の前景
  ESC[48;2;30;30;30m     → ダークグレーの背景
```

2012年、Thomas Dickeyはxtermで規格準拠の24ビットカラー構文を修正した。これ以降、主要なターミナルエミュレータが次々とTrue Colorをサポートしていった。

```
色空間拡張の歴史:

1978年 VT100      : 属性のみ（太字、下線、反転）色なし
1981年 CGA        : 16色（PC側）
       ECMA-48    : SGR 30-37 / 40-47（8色）
1990年代           : 太字=明るい色の慣習 → 事実上16色
1999年 xterm      : 256色（Todd Larasonのパッチ）
2012年 xterm      : 24ビットTrue Color（Thomas Dickeyの修正）
2016年 Windows 10 : コンソールがANSIエスケープコード対応
2020年代           : 主要ターミナルエミュレータの大半がTrue Color対応
```

VT100の時代から約35年をかけて、ターミナルの色空間は「色なし」から1677万色に拡張された。だが、この拡張はすべてテキストストリームの中に埋め込まれたエスケープシーケンスとして実現されている。画像プロトコルの追加ではない。ピクセル単位の描画APIでもない。あくまで「ESC [」で始まるバイト列が、テキストの流れの中に挿入されているだけだ。テキストストリームという制約の中で、表現力を最大限に引き出す。これがANSIエスケープシーケンスの本質だ。

---

## 4. tputとTERM：端末非依存スクリプティング

### TERM環境変数の役割

ここまで見てきたように、端末の制御シーケンスは標準化が進んだとはいえ、100%の互換性が保証されているわけではない。ANSI準拠端末の間でも、ファンクションキーの送信コードや対応する文字属性には差異が残る。

この差異を吸収するのが`TERM`環境変数だ。

```bash
$ echo $TERM
xterm-256color
```

`TERM`環境変数は、現在の端末の種類をシステムに通知する。ncursesやその他のライブラリは、この値をキーとしてterminfoデータベースを検索し、端末に適したエスケープシーケンスを取得する。

`TERM=xterm-256color`は「xterm互換で256色対応の端末」を意味する。`TERM=vt100`は「VT100互換端末」を意味し、色制御は使えないがカーソル移動や画面クリアは可能だ。SSH接続時に画面表示が崩れる問題の多くは、この`TERM`変数の不一致が原因だ。ローカル端末が`xterm-256color`なのに、リモートサーバのterminfoデータベースにそのエントリがなければ、ライブラリは端末の能力を正しく把握できない。

### tput：シェルスクリプトからの端末制御

termcap/terminfoデータベースを直接参照するC言語のAPIは、コンパイルされたプログラムには有用だ。だが、シェルスクリプトからはどうやって端末の能力を利用するのか。

その答えが`tput`コマンドだ。Bill Joyが1980年10月に4BSDの開発中に最初のtputを作成し、AT&TのUNIX System Vでも1980年代初頭に提供された。

`tput`は、terminfo（またはtermcap）データベースを参照し、指定された端末能力に対応するエスケープシーケンスを出力する。エスケープシーケンスの「ハードコード」を避け、端末非依存のスクリプティングを実現するためのツールだ。

```bash
# tputを使った端末非依存のスクリプティング

# 画面をクリア（端末の種類に応じた正しいシーケンスが出力される）
tput clear

# カーソルを10行5列に移動
tput cup 10 5

# 色の設定
tput setaf 1    # 前景色を赤に
tput setab 4    # 背景色を青に

# 文字属性
tput bold       # 太字
tput smul       # 下線開始
tput rmul       # 下線終了
tput sgr0       # 全属性リセット

# 端末の能力を数値で取得
tput cols       # 列数
tput lines      # 行数
tput colors     # 対応色数
```

`tput setaf 1`と`printf '\033[31m'`は、多くの場合同じ結果を出力する。だが、`tput`を使う利点は移植性にある。もし端末が非ANSI互換のエスケープシーケンスを使う場合でも、terminfoにエントリがあれば`tput`は正しいシーケンスを出力する。`\033[31m`をハードコードした場合、その端末では色が表示されないか、画面が崩れる。

実際のスクリプトでは、以下のように`tput`の出力を変数に格納して使うのが効率的だ。

```bash
# 色定義を変数に格納
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
BOLD=$(tput bold)
RESET=$(tput sgr0)

# 使用例
echo "${RED}ERROR:${RESET} ファイルが見つかりません"
echo "${GREEN}OK:${RESET} 処理が完了しました"
echo "${BOLD}${YELLOW}WARNING:${RESET} ディスク容量が残りわずかです"
```

このパターンは、エスケープシーケンスのハードコードを避けつつ、読みやすいスクリプトを書くための実践的な手法だ。`tput colors`が返す値を確認すれば、端末が何色に対応しているかを動的に判定できる。

```bash
# 端末の色対応を確認して表示を切り替える
NCOLORS=$(tput colors 2>/dev/null || echo 0)

if [ "$NCOLORS" -ge 256 ]; then
    # 256色対応端末
    INFO=$(tput setaf 39)   # 明るいシアン
elif [ "$NCOLORS" -ge 8 ]; then
    # 8色以上対応端末
    INFO=$(tput setaf 6)    # シアン
else
    # 色非対応端末
    INFO=""
fi
```

標準規格（ECMA-48/ANSI X3.64）がプロトコルを統一し、端末データベース（termcap/terminfo）が差異を吸収し、tputがシェルスクリプトからのアクセスを提供する。この三層構造が、テキスト端末の表現力を「呪文」ではなく「設計されたシステム」として機能させている。

---

## 5. ハンズオン：エスケープシーケンスを手で打つ

理論の確認は終わった。実際にエスケープシーケンスを手で入力し、テキスト端末の表現力を体感しよう。

### 演習1：SGRパラメータの基本操作

文字装飾と色制御の基本を体験する。

```bash
# Docker環境で実行
docker run --rm -it ubuntu:24.04 bash -c '
echo "=============================================="
echo "[演習1] SGRパラメータの基本操作"
echo "=============================================="
echo ""

echo "--- 文字属性 ---"
echo ""
printf "  \033[1m太字(Bold)\033[0m\n"
printf "  \033[2m暗い(Dim)\033[0m\n"
printf "  \033[3mイタリック(Italic)\033[0m\n"
printf "  \033[4m下線(Underline)\033[0m\n"
printf "  \033[7m反転(Reverse)\033[0m\n"
printf "  \033[9m取り消し線(Strikethrough)\033[0m\n"
printf "  \033[1;4m太字+下線\033[0m\n"
printf "  \033[1;3;4m太字+イタリック+下線\033[0m\n"
echo ""

echo "--- 基本8色（前景色 SGR 30-37）---"
echo ""
for i in $(seq 30 37); do
    printf "  \033[${i}m SGR ${i} \033[0m"
done
echo ""
echo ""

echo "--- 基本8色（背景色 SGR 40-47）---"
echo ""
for i in $(seq 40 47); do
    printf "  \033[${i}m SGR ${i} \033[0m"
done
echo ""
echo ""

echo "--- 明るい色（前景色 SGR 90-97）---"
echo ""
for i in $(seq 90 97); do
    printf "  \033[${i}m SGR ${i} \033[0m"
done
echo ""
echo ""

echo "--- 太字(1) + 通常色 → 明るい色になるか確認 ---"
echo ""
for i in $(seq 30 37); do
    printf "  通常:\033[${i}m##\033[0m  太字:\033[1;${i}m##\033[0m"
    bright=$((i + 60))
    printf "  明るい色:\033[${bright}m##\033[0m"
    echo ""
done
echo ""
echo "  → 多くの端末で、太字(SGR 1)は明るい色として描画される"
echo "    これが8色を事実上16色に拡張した歴史的慣習"
echo ""

echo "--- リセット忘れの影響 ---"
echo ""
printf "  \033[31m赤色のテキスト..."
echo "リセットを忘れると..."
echo "  この行も赤のまま..."
printf "  \033[0mリセットした。ここから通常色。\n"
echo ""
echo "  → ESC[0m でリセットしないと後続テキストに影響する"
echo ""
echo "=============================================="
'
```

### 演習2：カーソル制御とプログレスバーの実装

エスケープシーケンスを使って、カーソルを自在に操りプログレスバーを実装する。

```bash
docker run --rm -it ubuntu:24.04 bash -c '
echo "=============================================="
echo "[演習2] カーソル制御とプログレスバー"
echo "=============================================="
echo ""

echo "--- カーソル移動の基本 ---"
echo ""
echo "  ESC[nA : カーソルをn行上に移動"
echo "  ESC[nB : カーソルをn行下に移動"
echo "  ESC[nC : カーソルをn列右に移動"
echo "  ESC[nD : カーソルをn列左に移動"
echo "  ESC[n;mH : カーソルをn行m列に移動"
echo "  ESC[2J : 画面全体をクリア"
echo "  ESC[K  : カーソルから行末までクリア"
echo ""

echo "--- デモ: カーソル位置制御 ---"
echo ""
# 3行分のスペースを確保
echo ""
echo ""
echo ""
# カーソルを3行上に戻す
printf "\033[3A"
# 5列目に移動して書き込み
printf "\033[5C\033[32m[1,5]\033[0m"
# 1行下、15列目に移動
printf "\033[1B\033[15G\033[33m[2,15]\033[0m"
# 1行下、25列目に移動
printf "\033[1B\033[25G\033[34m[3,25]\033[0m"
echo ""
echo ""

echo "--- デモ: 簡易プログレスバー ---"
echo ""
echo "  エスケープシーケンスだけで実装:"
echo ""
WIDTH=40
printf "  ["
for i in $(seq 1 $WIDTH); do
    printf "#"
    sleep 0.02
done
printf "] Done!\n"
echo ""

echo "--- デモ: 上書き型プログレスバー ---"
echo ""
echo "  \\\\r（キャリッジリターン）で行頭に戻り上書き:"
echo ""
for i in $(seq 0 100); do
    FILLED=$((i * WIDTH / 100))
    EMPTY=$((WIDTH - FILLED))
    printf "\r  [%s%s] %3d%%" \
        "$(printf "%0.s#" $(seq 1 $FILLED 2>/dev/null))" \
        "$(printf "%0.s-" $(seq 1 $EMPTY 2>/dev/null))" \
        "$i"
    sleep 0.02
done
echo ""
echo ""

echo "--- デモ: 複数行の動的更新 ---"
echo ""
echo "  ESC[nA（カーソルを上に移動）で複数行を動的に更新:"
echo ""
# 初期表示
echo "  CPU:    [--------------------]   0%"
echo "  Memory: [--------------------]   0%"
echo "  Disk:   [--------------------]   0%"

for step in $(seq 1 20); do
    sleep 0.1
    # 3行上に移動
    printf "\033[3A"

    CPU=$((step * 5))
    MEM=$((step * 3))
    DISK=$((step * 2))

    CPU_FILL=$((CPU * 20 / 100))
    MEM_FILL=$((MEM * 20 / 100))
    DISK_FILL=$((DISK * 20 / 100))

    printf "  CPU:    [\033[32m%-20s\033[0m] %3d%%\n" \
        "$(printf "%0.s#" $(seq 1 $CPU_FILL 2>/dev/null))" "$CPU"
    printf "  Memory: [\033[33m%-20s\033[0m] %3d%%\n" \
        "$(printf "%0.s#" $(seq 1 $MEM_FILL 2>/dev/null))" "$MEM"
    printf "  Disk:   [\033[34m%-20s\033[0m] %3d%%\n" \
        "$(printf "%0.s#" $(seq 1 $DISK_FILL 2>/dev/null))" "$DISK"
done
echo ""

echo "  → テキストストリームの上書きだけで"
echo "    リアルタイムダッシュボードが実現できる"
echo ""
echo "=============================================="
'
```

### 演習3：256色とTrue Colorの確認

端末の色対応を確認し、256色とTrue Colorの表現力を体験する。

```bash
docker run --rm -it ubuntu:24.04 bash -c '
apt-get update -qq && apt-get install -y -qq ncurses-bin > /dev/null 2>&1

echo "=============================================="
echo "[演習3] 256色とTrue Colorの確認"
echo "=============================================="
echo ""

echo "--- 端末の色対応確認 ---"
echo ""
echo "  TERM=$TERM"
echo "  対応色数: $(tput colors)"
echo ""

echo "--- tput vs ハードコード ---"
echo ""
echo "  tput による色設定:"
printf "  $(tput setaf 1)赤$(tput sgr0) "
printf "$(tput setaf 2)緑$(tput sgr0) "
printf "$(tput setaf 3)黄$(tput sgr0) "
printf "$(tput setaf 4)青$(tput sgr0)\n"
echo ""
echo "  ハードコードによる同じ操作:"
printf "  \033[31m赤\033[0m \033[32m緑\033[0m \033[33m黄\033[0m \033[34m青\033[0m\n"
echo ""
echo "  → 結果は同じだが、tputは端末非依存で移植性が高い"
echo ""

echo "--- 256色パレット ---"
echo ""
echo "  標準16色 (0-15):"
for i in $(seq 0 15); do
    printf "\033[48;5;${i}m %3d \033[0m" "$i"
    if [ $((($i + 1) % 8)) -eq 0 ]; then
        echo ""
    fi
done
echo ""

echo "  6x6x6 RGBカラーキューブ (16-231):"
for g in 0 1 2 3 4 5; do
    printf "  "
    for r in 0 1 2 3 4 5; do
        for b in 0 1 2 3 4 5; do
            idx=$((16 + 36*r + 6*g + b))
            printf "\033[48;5;${idx}m  \033[0m"
        done
        printf " "
    done
    echo ""
done
echo ""

echo "  グレースケール (232-255):"
printf "  "
for i in $(seq 232 255); do
    printf "\033[48;5;${i}m  \033[0m"
done
echo ""
echo ""

echo "--- 24ビット True Color グラデーション ---"
echo ""
echo "  赤のグラデーション:"
printf "  "
for i in $(seq 0 8 255); do
    printf "\033[48;2;${i};0;0m \033[0m"
done
echo ""

echo "  緑のグラデーション:"
printf "  "
for i in $(seq 0 8 255); do
    printf "\033[48;2;0;${i};0m \033[0m"
done
echo ""

echo "  青のグラデーション:"
printf "  "
for i in $(seq 0 8 255); do
    printf "\033[48;2;0;0;${i}m \033[0m"
done
echo ""

echo "  虹のグラデーション:"
printf "  "
for i in $(seq 0 5 255); do
    if [ "$i" -le 42 ]; then
        r=255; g=$((i * 6)); b=0
    elif [ "$i" -le 85 ]; then
        r=$(( (85 - i) * 6 )); g=255; b=0
    elif [ "$i" -le 127 ]; then
        r=0; g=255; b=$(( (i - 85) * 6 ))
    elif [ "$i" -le 170 ]; then
        r=0; g=$(( (170 - i) * 6 )); b=255
    elif [ "$i" -le 212 ]; then
        r=$(( (i - 170) * 6 )); g=0; b=255
    else
        r=255; g=0; b=$(( (255 - i) * 6 ))
    fi
    # 値を0-255に制限
    r=$((r > 255 ? 255 : (r < 0 ? 0 : r)))
    g=$((g > 255 ? 255 : (g < 0 ? 0 : g)))
    b=$((b > 255 ? 255 : (b < 0 ? 0 : b)))
    printf "\033[48;2;${r};${g};${b}m \033[0m"
done
echo ""
echo ""

echo "--- True Color 対応の確認方法 ---"
echo ""
echo "  以下のバーが滑らかなグラデーションに見えれば"
echo "  あなたの端末は24ビットTrue Colorに対応している。"
echo "  色の境界が段階的に見える場合は256色モードに"
echo "  フォールバックしている可能性がある。"
echo ""
echo "=============================================="
'
```

これらの演習で見たように、エスケープシーケンスは「テキストストリームの中に埋め込まれた制御命令」に過ぎない。画像を転送しているわけでも、GPUに描画命令を送っているわけでもない。`ESC[38;2;255;165;0m`という18バイトの文字列が、端末に「以降のテキストをオレンジ色で表示せよ」と命じているだけだ。この仕組みの簡素さと汎用性が、テキスト端末が60年間生き残ってきた理由の一つである。

---

## 6. まとめと次回予告

### この回の要点

第一に、1970年代後半の端末市場は非互換性の混沌だった。DEC、Hazeltine、Lear-Siegler、Televideo、Wyseなど各社が独自のエスケープシーケンスを実装し、同じ操作が端末ごとに異なるバイト列を要求した。

第二に、この問題に対して二つのアプローチが生まれた。一つはECMA-48（1976年9月初版）からANSI X3.64（1979年）に至る標準規格の策定。もう一つはBill Joyのtermcap（1977年開発開始、1978年リリース）、Ken Arnoldのcurses（1978年）に始まるソフトウェアによる抽象化だ。

第三に、CSI（Control Sequence Introducer）シーケンスは`ESC [`で始まり、数値パラメータと終端文字で構成される拡張性の高い構文を持つ。SGR（Select Graphic Rendition、終端文字`m`）が文字装飾と色制御を担い、30-37が前景色、40-47が背景色、0がリセットという体系が今日まで使われている。

第四に、色空間は歴史的に段階的に拡張された。ECMA-48の8色から、太字=明るい色の慣習による事実上の16色、1999年のTodd Larasonによるxterm 256色パッチ、2012年のThomas Dickeyによる24ビットTrue Color対応へと進化した。すべてテキストストリーム内のエスケープシーケンスとして実現されている。

第五に、termcap→terminfo→ncursesという端末抽象化レイヤーの系譜が、端末間の差異を吸収し続けている。`tput`コマンドはこの抽象化レイヤーへのシェルスクリプトからのアクセスを提供し、端末非依存のスクリプティングを可能にする。

### 冒頭の問いへの暫定回答

テキストしか表示できないはずの端末に、なぜ色やカーソル移動があるのか。

暫定的な答えはこうだ。**テキストストリームの中に制御命令を埋め込む「インバンドシグナリング」という設計が、1976年のECMA-48で標準化され、VT100の市場支配によって普及したからである。** `ESC [`という2バイトの導入子が、通常の文字列と制御命令の境界を示す。この仕組みは、テキストという制約を「壊す」のではなく、テキストの中に「もう一つの言語」を埋め込むことで拡張した。

この設計は、50年近く経った今も有効だ。24ビットTrue Colorのグラデーションも、cursesを使ったTUIアプリケーションも、すべて`ESC [`から始まるバイト列がテキストの流れの中に混在しているだけである。テキストストリームの上に構築された「疑似グラフィック」プロトコル。これが端末の表現力の正体だ。

だが、この「疑似グラフィック」は、テキストベースの世界に閉じている限りにおいて有効な仕組みだった。UNIXの世界がコマンドラインだけで動いていた時代、そのモデルに異議を唱える勢力が別の大陸で育っていた。

### 次回予告

次回、第6回「MS-DOSとCOMMAND.COM――もうひとつのCLI系譜」では、UNIX一辺倒ではないCLIの歴史を辿る。CP/Mから始まりMS-DOS、cmd.exe、そしてPowerShellに至るWindowsのCLI系譜は、UNIXとはまったく異なる設計判断の積み重ねだった。

パスの区切りが`/`ではなく`\`である理由。ワイルドカード展開の責任がシェルではなくアプリケーションにある理由。パイプが一時ファイルを経由していた理由。UNIXの世界だけを見ていると「なぜ？」と思う設計判断の一つ一つに、合理的な背景がある。

あなたは、DOSのパイプがなぜ「本物の」パイプではなかったか、知っているだろうか。

---

## 参考文献

- Ecma International, "ECMA-48 - Control functions for coded character sets", <https://ecma-international.org/publications-and-standards/standards/ecma-48/>
- Wikipedia, "ANSI escape code", <https://en.wikipedia.org/wiki/ANSI_escape_code>
- Wikipedia, "Termcap", <https://en.wikipedia.org/wiki/Termcap>
- Wikipedia, "Terminfo", <https://en.wikipedia.org/wiki/Terminfo>
- Wikipedia, "curses (programming library)", <https://en.wikipedia.org/wiki/Curses_(programming_library)>
- Wikipedia, "ncurses", <https://en.wikipedia.org/wiki/Ncurses>
- Wikipedia, "tput", <https://en.wikipedia.org/wiki/Tput>
- vt100.net, "SGR - Select Graphic Rendition", <https://vt100.net/docs/vt510-rm/SGR.html>
- vt100.net, "ANSI Control Functions Summary", <https://vt100.net/docs/vt510-rm/chapter4.html>
- Thomas Dickey, "NCURSES - New Curses", <https://invisible-island.net/ncurses/>
- Thomas Dickey, "NCURSES - Frequently Asked Questions", <https://invisible-island.net/ncurses/ncurses.faq.html>
- Thomas Dickey, "XTerm Control Sequences", <https://invisible-island.net/xterm/ctlseqs/ctlseqs.html>
- Chad Austin, "I Just Wanted Emacs to Look Nice - Using 24-Bit Color in Terminals", 2024, <https://chadaustin.me/2024/01/truecolor-terminal-emacs/>
- GitHub, "termstandard/colors - Color standards for terminal emulators", <https://github.com/termstandard/colors>
- Wikipedia, "Midnight Commander", <https://en.wikipedia.org/wiki/Midnight_Commander>

---

**次回：** 第6回「MS-DOSとCOMMAND.COM――もうひとつのCLI系譜」

---

_本記事は「ターミナルは遺物か――コマンドラインの本質を問い直す」連載の第5回です。_
_ライセンス：CC BY-SA 4.0_
