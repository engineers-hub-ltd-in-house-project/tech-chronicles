# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第24回：ターミナルは遺物か、改めて問う――あなたのインターフェースを選べ

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 60年にわたるインターフェースの歴史を俯瞰し、CLI・GUI・TUI・自然言語インターフェースの本質的な違いを理解する
- Ben Shneidermanの「直接操作」（1983年）、Jakob Nielsenの「再認 vs 想起」（1994年）など、インターフェース設計の理論的基盤
- タスクの性質に応じたインターフェース選定フレームワーク――反復性・探索性・構造性・曖昧性の四軸
- 「インターフェースを選ぶ」とは何か――歴史を知った上で自分の道具を選ぶ意味
- 24回の連載を貫く問い「ターミナルは遺物か」に対する最終回答

---

## 1. 24回の旅の終わりに

第1回を書き始めたとき、私は「なぜ今、コマンドラインを語るのか」という問いを読者に投げかけた。GUIが「標準」になった世界で、なぜコマンドラインは死なないのか。22歳年下の若手エンジニアが「ターミナルって、あのレトロな黒い画面ですか」と聞いてきた日のことを、私は今でも覚えている。

あれから23回を書いた。テレタイプからCRT端末へ、パンチカードからタイムシェアリングへ、UNIXパイプからPowerShellのオブジェクトパイプラインへ、GNU coreutilsからRust製CLIツールへ、TUIの復権からAIエージェントまで。60年分のコマンドライン史を辿り直す作業は、率直に言って、私自身の24年間のエンジニアとしての棚卸しだった。

前回、第23回で私はコマンドラインの本質を三つの原則に蒸留した。テキストストリーム（普遍性）、組み合わせ（合成可能性）、自動化（再現性）。1961年のCTSSから2025年のAI+CLIに至るまで、この三つは形を変えながら一貫して存在し続けている。

だが、最終回で語りたいのは、CLIの本質ではない。

この連載を通じて得た知識を、明日からどう活かすのか。そして、「ターミナルは遺物か」という連載タイトルの問いに、最終的な回答を出すことだ。

答えを先に言おう。ターミナルは遺物ではない。だが、ターミナルが常に最適な選択でもない。重要なのは、ターミナルを「知った上で選ぶ」ことだ。選ぶためには、選択肢を知らなければならない。選択肢を正しく評価するためには、各選択肢が「なぜそうなったか」という歴史を知らなければならない。

この最終回は、その「選ぶ」ための枠組みを提示する。あなたは、自分の仕事にとって最適なインターフェースを、意識的に選んでいるだろうか。

---

## 2. インターフェースの四つの時代

### テキストの時代：CLIの成立（1961年-1983年）

この連載で辿ってきた歴史を、インターフェースの進化という観点で再構成してみたい。

最初の時代は、テキストの時代だ。1961年、MITのFernando CorbatóがCTSS（Compatible Time-Sharing System）を稼働させた。人間がキーボードでテキストを入力し、コンピュータがテキストで応答する。第3回で語ったこの「対話」の成立が、CLIの起源だ。

1973年1月15日、Ken Thompsonが一晩でUNIXにパイプを実装した。第7回で詳しく語ったこの出来事は、テキストストリームという「普遍的インターフェース」を確立した。Doug McIlroyが1978年のBell System Technical Journalで表現した「Expect the output of every program to become the input to another, as yet unknown, program（すべてのプログラムの出力が、まだ知らない別のプログラムの入力になることを想定せよ）」という原則は、CLIの設計思想を定義した。

この時代のインターフェースは、テキスト入力・テキスト出力という一貫した原則に基づいている。第4回で語ったテレタイプ（Teletype Model 33、1963年）から第5回のANSIエスケープシーケンス（1979年）に至るまで、端末の物理形態は変わったが、テキストストリームという抽象は変わらなかった。

CLIの強みは、第23回で整理した三つの本質――テキスト・組み合わせ・自動化――に根ざしている。だが同時に、CLIには本質的な弱点がある。**発見可能性（discoverability）の欠如**だ。`ls`というコマンドがあることを、ユーザーはどうやって知るのか。`grep`に`-E`オプションがあることを、どうやって発見するのか。CLIは、使い方を「すでに知っている」人間にとって強力だが、「まだ知らない」人間にとって壁が高い。

Don Normanは1988年の『The Design of Everyday Things』で、アフォーダンス――物の使い方を示唆する性質――の重要性を論じた。ドアの取っ手は「引く」ことを示唆し、平らなプレートは「押す」ことを示唆する。CLIには、このアフォーダンスがほとんどない。黒い画面とプロンプトは、何も示唆しない。何ができるのか、何を入力すればいいのか、ユーザーは自力で知識を持っているか、調べるしかない。

### 視覚の時代：GUIの衝撃（1973年-2006年）

第二の時代は、視覚の時代だ。

1973年3月1日、Xerox PARCでAltoが稼働した。Alan Kay、Butler Lampson、Chuck Thackerらが開発したこのマシンは、ビットマップディスプレイ、マウス、WYSIWYG編集、ウィンドウシステムを備えていた。GUI（Graphical User Interface）の原型だ。

1983年、Ben Shneidermanが「Direct Manipulation: A Step Beyond Programming Languages」をIEEE Computer誌に発表した。直接操作（Direct Manipulation）の三原則――対象物の視覚的表現、迅速で可逆的な操作、複雑な構文の代わりに物理的操作――は、GUIの認知的基盤を理論化した。Shneidermanの論文が出た翌年の1984年1月24日、Steve JobsがMacintoshを発表した。理論と製品が、わずか1年の間隔で噛み合った。

1994年、Jakob Nielsenが249のユーザビリティ問題の因子分析に基づいて10のユーザビリティヒューリスティクスを確立した。その第6のヒューリスティクスが「Recognition rather than recall（想起よりも再認を）」だ。GUIのメニューバーは、利用可能なコマンドを一覧表示する。ユーザーは覚える（recall）必要がなく、見て認識する（recognize）だけでいい。ファイルのアイコンをドラッグ&ドロップすれば移動できる。`mv source dest`という構文を覚える必要はない。

GUIが解決した問題は明確だ。CLIの「発見可能性の欠如」を、視覚的な手がかりで補った。だが、GUIには構造的な弱点がある。第12回で詳しく語ったように、GUIは**組み合わせが困難**だ。Photoshopの出力をExcelの入力に直接パイプすることはできない。GUIの操作は**スクリプト化が困難**だ。マウスの座標、ウィンドウの状態、メニューの階層――これらをテキストとして記録し再現するには、Selenium や Playwright のような専用ツールが必要になる。

1995年8月24日のWindows 95は、スタートメニューとタスクバーでGUIデスクトップの標準を確立した。発売後4日間で100万本を出荷したこのOSは、「CLIの時代は終わった」という予言を強化した。だが、第12回で語ったように、CLIは死ななかった。同じ1995年、Tatu YlönenがSSHを開発し、リモートサーバ管理におけるCLIの不可欠性を決定づけた。GUIの勝利は、デスクトップ上のものだった。サーバの世界では、CLIが揺るがなかった。

### 触覚の時代：NUIの出現（2007年-2021年）

第三の時代は、触覚の時代だ。

2007年1月9日、Steve JobsがiPhoneを発表した。マルチタッチインターフェースは、NUI（Natural User Interface）を大衆に届けた。指でピンチしてズーム、スワイプしてスクロール。ボタンもメニューバーも不要だ。身体の動きが直接操作になる。

NUIは、GUIよりもさらに直感的だ。GUIはマウスという間接的なポインティングデバイスを介するが、NUIは指で画面を直接触る。Fittsの法則（1954年、Paul Fitts）によれば、ポインティングの時間はターゲットまでの距離とターゲットの幅に依存する。タッチインターフェースはこの距離をゼロに近づけた。

だが、NUIの強みは同時に弱みでもある。タッチインターフェースは「精密なテキスト操作」に向かない。iPhoneでシェルスクリプトを書く人はほとんどいない。ソフトウェアキーボードはハードウェアキーボードの入力速度に遠く及ばない。NUIは「消費」に最適化されたインターフェースであり、「生産」には必ずしも最適ではない。

音声インターフェースもNUIの一形態だ。Amazon Alexa、Apple Siri、Google Assistant――2024年時点で米国だけでも約1億5,000万人が音声アシスタントを利用している。だが、音声インターフェースは「曖昧な指示」には適しても、「精密な操作」には向かない。「リビングの照明を暖色にして」は音声で十分だが、「このディレクトリ以下の.logファイルのうち30日以上前のものを削除」は音声では苦しい。

### 言語の時代：自然言語インターフェースの台頭（2022年-）

第四の時代は、言語の時代だ。ただし、CLIのテキスト入力とは根本的に異なる。

2022年11月30日、OpenAIがChatGPTを公開した。5日間で100万ユーザー、2ヶ月で1億ユーザーという爆発的な普及は、自然言語がコンピュータとの対話の主要なインターフェースになりうることを証明した。ChatGPTの革新は、技術（LLM）よりもインターフェース（シンプルなチャットウィンドウ）にあった。

2025年2月、AnthropicがClaude Codeをリリースした。第22回で詳しく語ったように、これはターミナル上で動作するエージェント型ツールだ。自然言語で「このリポジトリのテストを実行して、失敗したテストの原因を調べて」と指示すれば、AIがCLIコマンドを組み立て、実行し、結果を解釈し、次のステップを決定する。

自然言語インターフェースがCLIと決定的に異なるのは、**曖昧さの許容**だ。CLIは厳密な構文を要求する。`find . -name "*.log" -mtime +30`の`-mtime +30`が「30日より前」を意味するのか「ちょうど30日前」を意味するのか、構文を正確に知らなければ意図通りの結果は得られない。自然言語インターフェースは、「30日以上前のログファイルを探して」という曖昧な指示から適切なコマンドを推論する。

だが、第22回で指摘したように、自然言語インターフェースには重大な弱点がある。**再現性の不確実さ**だ。同じ自然言語の指示を二度与えても、LLMが同じコマンドを生成するとは限らない。CLIコマンドは決定論的だ。`grep -E "ERROR|WARN" access.log`は、何度実行しても同じ正規表現で同じファイルを検索する。自然言語指示は非決定論的だ。「エラーと警告を探して」が、ある時は`grep`になり、別の時は`rg`になり、また別の時はPythonスクリプトになるかもしれない。

四つの時代を俯瞰すると、インターフェースの進化は「抽象度の上昇」として捉えられる。

```
インターフェースの抽象度の進化:

低い                                                        高い
 │                                                           │
 ▼                                                           ▼
テキスト入力    視覚的操作    身体的操作    自然言語指示
 (CLI)          (GUI)         (NUI)        (LLM)
 1961-          1973-         2007-        2022-

│ 精密性      高い ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 低い │
│ 発見可能性  低い ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 高い │
│ 組み合わせ  高い ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 低い │
│ 再現性      高い ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 低い │
│ 学習曲線    急峻 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 緩やか│
```

この図が示すのは、どのインターフェースも万能ではないということだ。抽象度が上がれば学習曲線は緩やかになるが、精密性と再現性は下がる。抽象度が低ければ組み合わせと自動化が容易だが、発見可能性に欠ける。「最良のインターフェース」は存在しない。「タスクと文脈に最適なインターフェース」が存在するだけだ。

---

## 3. インターフェース選定のフレームワーク

では、タスクと文脈に応じてインターフェースを選ぶにはどうすればいいのか。この連載の23回分の知見を統合し、四つの軸からなるフレームワークを提示する。

### 軸1：タスクの反復性

タスクを一度だけ実行するのか、繰り返し実行するのか。

一度限りの操作であれば、GUIやNUI、あるいは自然言語インターフェースが適している。マウスでファイルをドラッグするだけでいい。AIに「このファイルを移動して」と言えばいい。

だが、同じ操作を100回繰り返すなら、CLIが圧倒的に有利だ。第23回で語った「操作とスクリプトの同型性」がここで効いてくる。ターミナルで手動実行したコマンドを、そのままシェルスクリプトにコピーすれば自動化が完成する。GUIの操作を100回記録し再現するには、RPA（Robotic Process Automation）やPlaywrightのような専用ツールが必要になる。

```
反復性とインターフェースの適合:

      低い(1回限り)                     高い(日常的に反復)
        │                                     │
        ▼                                     ▼
    GUI / NUI / 自然言語                CLI / スクリプト
    「見て触って完了」               「書いて記録して再利用」

例:
  1回限り → GUIでファイルを手動整理
  毎日反復 → cronジョブでログをローテーション
  毎回微妙に違う → 自然言語でAIに都度指示
```

### 軸2：操作の探索性

何をすべきかが明確なのか、それとも探しながら操作するのか。

目的が明確で、実行すべきコマンドが分かっている場合はCLIが最速だ。`kubectl get pods`と打てば、クラスタ内のPod一覧が即座に表示される。

だが、何ができるのかを探している場合はGUIが有利だ。初めてのアプリケーションをインストールし、その機能を把握するとき、メニューバーを開いて利用可能な機能を一覧することで全体像が掴める。Jakob Nielsenの「再認 vs 想起」が、ここで直接的に関わる。GUIのメニューは「再認（recognition）」を助け、CLIのコマンドは「想起（recall）」を要求する。

第13回で語ったコマンドパレット（VS CodeのCommand Palette、Sublime Text、Raycast）は、この二つを融合する試みだ。キーボードでテキストを入力しながら（CLIの想起）、候補がリアルタイムにフィルタリングされ表示される（GUIの再認）。fzfも同じ原理だ。入力しながら結果がインクリメンタルに絞り込まれる。

```
探索性とインターフェースの適合:

      低い(何をすべきか明確)              高い(何ができるか不明)
        │                                     │
        ▼                                     ▼
    CLI / TUI                          GUI / コマンドパレット
    「知っている → 直接打つ」         「見る → 認識する → 選ぶ」

例:
  明確 → git commit -m "fix: 修正" と直接打つ
  半探索 → fzfでファイルを絞り込む
  探索的 → GUIのファイラーでディレクトリを眺める
```

### 軸3：データの構造性

扱うデータがテキストとして自然に表現できるか、それとも視覚的・空間的な構造を持つか。

ログファイル、設定ファイル、ソースコード、CSVデータ――これらはテキストとして自然に表現できる。CLIのパイプラインで処理するのに最適だ。第7回で語ったパイプ、第8回のgrep/sed/awk、第17回のripgrep/fd――テキスト処理のツール群は、テキストデータに対して無類の生産性を発揮する。

だが、画像編集、3Dモデリング、地図データの操作、スプレッドシートのセル操作――これらは本質的に空間的・視覚的なデータであり、CLIで扱うのは不自然だ。Photoshopの代わりにImageMagickのCLIだけで画像編集を完結させることは技術的に可能だが、生産的とは言い難い。

第18回で語ったTUI（Terminal User Interface）は、この軸における中間地点だ。lazygitはgitの操作に空間的な構造（コミットグラフ、ステージング領域、差分表示）を与えつつ、テキストベースの環境に留まる。k9sはKubernetesクラスタの状態を表形式で可視化しつつ、キーボードだけで操作できる。TUIは「テキスト環境の制約内で、構造を可視化する」という設計上の妥協点であり、SSHセッション越しに使えるという実用上の利点がある。

### 軸4：コンテキストの曖昧性

タスクの指示がどの程度精密に定義できるか。

「/var/log/syslog から、過去24時間以内の行で、"error" を含むものを抽出し、送信元IPアドレスでグルーピングして件数の多い順に表示せよ」――この指示は十分に精密だ。CLIのパイプラインに直接変換できる。

「最近のログを見て、何か異常がないか調べてほしい」――この指示は曖昧だ。「最近」の定義、「異常」の定義、調査対象のログファイルの特定、すべてが不確定だ。こうした曖昧なタスクには、自然言語インターフェースが適している。AIエージェントは曖昧な指示を解釈し、段階的に明確化しながら作業を進められる。

だが、第22回で指摘したように、曖昧さの許容にはリスクが伴う。AIが「異常」を誤って解釈し、正常なログエントリを問題として報告するかもしれない。曖昧な指示は曖昧な結果を生む。最終的な判断には、人間のドメイン知識とCLIの知識が不可欠だ。

```
四軸フレームワーク 一覧:

┌──────────┬────────────────────┬────────────────────────┐
│ 軸       │ 低い方が適する     │ 高い方が適する         │
│          │ インターフェース   │ インターフェース       │
├──────────┼────────────────────┼────────────────────────┤
│ 反復性   │ GUI / NUI / AI     │ CLI / スクリプト       │
│ 探索性   │ CLI / TUI          │ GUI / コマンドパレット │
│ 構造性   │ CLI（テキスト）    │ GUI（視覚データ）     │
│ 曖昧性   │ CLI（精密な指示）  │ AI（曖昧な指示）      │
└──────────┴────────────────────┴────────────────────────┘

※「構造性」: データが視覚的・空間的構造を持つ度合い
  低い = テキスト中心 → CLI向き
  高い = 視覚・空間的 → GUI向き
```

四つの軸は独立ではない。日常のタスクは、四つの軸それぞれに異なるスコアを持つ。重要なのは、各軸を意識した上でインターフェースを選ぶことだ。

---

## 4. 「選ぶ」ことの意味

### 知らずに使うこと、知って選ぶこと

この連載の冒頭――第1回で、私はこう書いた。「CLIは『古い技術』ではなく『テキストという抽象を操作するパラダイム』である」。23回を経て、この命題をさらに一般化したい。

あらゆるインターフェースは「パラダイム」であり、それぞれに固有の前提・強み・弱みを持つ。CLIはテキストストリームという前提の上に合成可能性と自動化を構築した。GUIは視覚的表現という前提の上に発見可能性と直接操作を構築した。NUIは身体的操作という前提の上に直感性を構築した。自然言語インターフェースは曖昧さの許容という前提の上にアクセシビリティを構築した。

問題は、多くのエンジニアが「たまたま最初に覚えたもの」を使い続けていることだ。VS Codeのターミナルパネルが「CLI」のすべてだと思っている若手エンジニアがいる。逆に、何でもCLIで解決しようとするベテランもいる。画像の色調補正をImageMagickのワンライナーで実行し、後からその呪文のようなコマンドを誰も読めなくなる。

1999年、Neal Stephensonは『In the Beginning was the Command Line』で、OSとインターフェースの関係を鮮やかに描いた。四半世紀が経った今、Stephensonの問いかけは形を変えて続いている。GUIか、CLIか、という二項対立は、もはや意味をなさない。2026年の今、私たちの前には少なくとも四つのインターフェースパラダイムがある。そして、それぞれが適するタスクと文脈がある。

「選ぶ」とは、各パラダイムの歴史的背景と構造的特性を理解した上で、タスクに応じて適切なものを使い分けることだ。

### エンジニアのインターフェースポートフォリオ

私自身の日常を振り返ってみたい。2026年2月現在の、私のインターフェース使い分けはこうだ。

**CLI**を使う場面：gitの操作（`git log --oneline --graph`の出力は、GUIのいかなるグラフ表示よりも私にとって読みやすい）。ログ分析（`grep | awk | sort | uniq -c`のパイプラインは、25年間手に馴染んだ道具だ）。インフラ操作（`kubectl`、`terraform`、`docker`。これらにGUIの代替はあるが、スクリプト化と再現性でCLIに軍配が上がる）。ファイル操作の自動化（数百ファイルの一括処理は、CLIのワンライナーが最速だ）。

**GUI**を使う場面：Webブラウジング（テキストブラウザのw3mで仕事をする気にはならない）。画像・動画の確認と編集（視覚的なデータは視覚的に操作するのが自然だ）。初めて触るアプリケーションの探索（メニューを開いて何ができるかを把握する）。PRのコードレビュー（GitHub WebのUIで差分を見るのは、`git diff`をターミナルで見るより文脈を把握しやすい場面がある）。

**TUI**を使う場面：lazygitでのインタラクティブなgit操作（ステージング、チェリーピック、リベースなど、複数のステップを行き来する作業）。htopやbtopでのシステムモニタリング（リアルタイムの状態変化を視覚的に追跡する）。SSHセッション越しのサーバ管理（GUIは使えないが、視覚的なフィードバックが欲しい場面）。

**自然言語インターフェース**を使う場面：コードベースの調査（「このリポジトリでAPIエンドポイントを定義しているファイルを探して」）。定型的だが複雑なCLIコマンドの生成（正確な構文を思い出すよりAIに聞くほうが速い場面がある）。テストの実行と結果の解釈（「テストを走らせて、失敗の原因を調べて」）。

注目してほしいのは、同じ「git操作」というタスクでも、文脈によって使い分けていることだ。単純なコミットはCLI。複雑なリベースはlazygit（TUI）。PRのレビューはGitHub（GUI）。コミットメッセージの生成は自然言語（AI）。一つのツールに固執せず、タスクの性質に応じて最適なインターフェースを選ぶ。これが「選ぶ」ということだ。

### チームにおけるインターフェース選定

個人の使い分けだけでなく、チームとしてのインターフェース選定も重要だ。

CI/CDパイプラインはCLIコマンドのシーケンスで記述される。これは選択ではなく必然だ。ヘッドレス環境ではGUIが存在しない。Infrastructure as Codeの`.tf`ファイル、DockerfileのRUNコマンド、GitHub Actionsのワークフロー――これらはすべてCLIの自動化の延長線上にある。

一方、プロジェクトのダッシュボード、チームのタスク管理、デザインレビュー――これらはGUIが適している。JiraやLinearのボード表示は、タスクの状態を空間的に把握するのに最適化されている。Figmaのデザインレビューは、視覚的なデータを視覚的に操作する典型例だ。

重要なのは、チーム内で「なぜこのインターフェースを使うのか」を共有することだ。「デプロイはCLIスクリプトで行う。なぜなら再現性と監査可能性が必要だから」。「タスク管理はGUIで行う。なぜなら全体像の把握と探索性が必要だから」。理由を言語化できるチームは、ツール選定で迷わない。

---

## 5. ハンズオン：インターフェース選定マトリクスを作成する

### 環境構築

```bash
# Docker環境で実行（ubuntu:24.04ベース）
docker run -it --rm ubuntu:24.04 bash
```

### 演習1：四軸フレームワークの体験

この演習では、同じタスクを異なるインターフェースで実行し、四つの軸のスコアを体感する。

```bash
apt-get update && apt-get install -y coreutils findutils grep gawk curl jq procps

echo "=== 演習1: 同じタスクを異なる方法で実行する ==="
echo ""

# テスト用データ生成
mkdir -p /tmp/interface-lab/logs
for i in $(seq 1 5); do
  cat > "/tmp/interface-lab/logs/app-${i}.log" << LOGEOF
2025-02-01 10:00:01 [INFO] Service started on port 808${i}
2025-02-01 10:05:23 [ERROR] Connection refused to database server
2025-02-01 10:05:24 [WARN] Retrying connection in 5 seconds
2025-02-01 10:05:29 [INFO] Database connection restored
2025-02-01 10:15:00 [ERROR] Request timeout after 30s for /api/users
2025-02-01 10:30:00 [INFO] Health check passed
2025-02-01 11:00:00 [WARN] Memory usage at 85%
2025-02-01 11:30:45 [ERROR] Out of memory exception in worker thread
2025-02-01 12:00:00 [INFO] Service restarted by watchdog
LOGEOF
done

echo "--- タスク: 全ログファイルからERRORを抽出し、メッセージ別に集計する ---"
echo ""

echo "[方法1: CLIパイプライン（精密・再現可能・組み合わせ可能）]"
grep "ERROR" /tmp/interface-lab/logs/*.log \
  | sed 's/.*\[ERROR\] //' \
  | sort \
  | uniq -c \
  | sort -rn
echo ""

echo "→ 反復性: 高い（そのままスクリプト化できる）"
echo "→ 探索性: 低い（grepの構文を知っている必要がある）"
echo "→ 構造性: テキスト向き（ログはテキストデータ）"
echo "→ 曖昧性: 低い（完全に精密な指示）"
echo ""

echo "[方法2: 自然言語での指示（想定）]"
echo '指示例: "ログファイルからエラーを探して、どんなエラーが多いか教えて"'
echo ""
echo "→ 反復性: 低い（同じ結果が保証されない）"
echo "→ 探索性: 高い（構文を知らなくても指示できる）"
echo "→ 構造性: テキスト向き"
echo "→ 曖昧性: 高い（AIが解釈を補う）"
echo ""

echo "[方法3: GUIログビューアー（想定）]"
echo "操作例: ファイルを開く → フィルタに'ERROR'と入力 → 集計ビューに切替"
echo ""
echo "→ 反復性: 低い（手動操作を毎回再現する必要がある）"
echo "→ 探索性: 高い（メニューからフィルタ機能を発見できる）"
echo "→ 構造性: 視覚的な表示（色分け、ハイライト）"
echo "→ 曖昧性: 低い（操作は明確）"
```

### 演習2：反復性の軸を体験する

```bash
echo ""
echo "=== 演習2: 反復タスクのスクリプト化 ==="
echo ""

echo "--- 手動操作を記録し、スクリプトに変換する ---"
echo ""

# 手動で実行するコマンド群
echo "手動実行1: ログのエラー件数確認"
grep -c "ERROR" /tmp/interface-lab/logs/*.log
echo ""

echo "手動実行2: メモリ警告の確認"
grep "Memory" /tmp/interface-lab/logs/*.log
echo ""

echo "手動実行3: 最新のエラーを確認"
grep "ERROR" /tmp/interface-lab/logs/*.log | tail -5
echo ""

# 上記をスクリプト化する
cat > /tmp/interface-lab/daily-check.sh << 'SCRIPT'
#!/bin/bash
set -euo pipefail

LOG_DIR="${1:-/tmp/interface-lab/logs}"
echo "=== 日次ログチェックレポート ==="
echo "実行日時: $(date)"
echo "対象: ${LOG_DIR}"
echo ""

echo "--- エラー件数（ファイル別） ---"
grep -c "ERROR" "${LOG_DIR}"/*.log 2>/dev/null || echo "  エラーなし"
echo ""

echo "--- メモリ警告 ---"
grep "Memory" "${LOG_DIR}"/*.log 2>/dev/null || echo "  警告なし"
echo ""

echo "--- 直近のエラー（最新5件） ---"
grep "ERROR" "${LOG_DIR}"/*.log 2>/dev/null | tail -5 || echo "  エラーなし"
echo ""

echo "=== レポート終了 ==="
SCRIPT

chmod +x /tmp/interface-lab/daily-check.sh

echo "--- スクリプトを実行 ---"
echo ""
bash /tmp/interface-lab/daily-check.sh

echo ""
echo "→ 手動で3回実行したコマンドが、スクリプト1本になった。"
echo "  明日も明後日も同じチェックを実行できる。"
echo "  これがCLIの『反復性に対する適合』の実体だ。"
echo "  GUIでこの日次チェックを自動化するには、"
echo "  Selenium等の追加ツールが必要になる。"
```

### 演習3：探索性の軸を体験する

```bash
echo ""
echo "=== 演習3: 探索性 ― 知っている vs 知らない ==="
echo ""

echo "--- シナリオ: あなたは初めてこのログ群を見る ---"
echo ""

echo "[CLIの場合: 想起(recall)が必要]"
echo "知っていなければならないこと:"
echo "  - ls でファイル一覧を見る"
echo "  - cat でファイルの内容を見る"
echo "  - grep でパターンを検索する"
echo "  - less でページングする"
echo ""

echo "実際にやってみる:"
echo ""
echo "Step 1: ファイル一覧を見る"
ls -la /tmp/interface-lab/logs/
echo ""

echo "Step 2: 1つ目のファイルの内容を確認"
head -5 /tmp/interface-lab/logs/app-1.log
echo ""

echo "Step 3: ログレベルの種類を把握する"
grep -oP '\[\K[A-Z]+' /tmp/interface-lab/logs/*.log | sort -u
echo ""

echo "→ この探索には、ls, head, grep -oP の知識が必要だった。"
echo "  GUIのファイラーなら、フォルダをクリックして開き、"
echo "  ファイルをダブルクリックすれば内容が見える。"
echo "  『何があるか分からない』状態では、GUIの発見可能性が活きる。"
echo ""

echo "[補完: CLIの探索性を補う方法]"
echo ""
echo "方法1: --help フラグ"
grep --help 2>&1 | head -10
echo ""
echo "方法2: Tab補完（対話的シェルで利用可能）"
echo "  grep --<TAB><TAB> で利用可能なオプションを表示"
echo ""
echo "方法3: 自然言語で質問（AI活用）"
echo '  "このディレクトリのログで、何が起きているか概要を教えて"'
echo ""
echo "→ CLIの探索性の弱点を補う手段は存在する。"
echo "  だが、GUIの直感的な発見可能性には及ばない。"
echo "  第21回で語った --help や manページは、"
echo "  CLIが自らの発見可能性を補う50年来の工夫だ。"
```

### 演習4：自分のワークフローの棚卸し

```bash
echo ""
echo "=== 演習4: インターフェース選定マトリクスを作成する ==="
echo ""

cat << 'MATRIX'
以下のマトリクスを、自分の日常タスクで埋めてみよう。
各タスクの四軸スコアを評価し、最適なインターフェースを判定する。

┌────────────────────┬──────┬──────┬──────┬──────┬──────────┐
│ タスク              │反復性│探索性│構造性│曖昧性│最適な IF  │
├────────────────────┼──────┼──────┼──────┼──────┼──────────┤
│ 例: ログ分析        │ 高   │ 低   │ 低   │ 低   │ CLI      │
│ 例: UIデザイン      │ 低   │ 高   │ 高   │ 中   │ GUI      │
│ 例: コードレビュー  │ 中   │ 高   │ 中   │ 中   │ GUI+CLI  │
│ 例: 障害調査        │ 低   │ 高   │ 低   │ 高   │ AI+CLI   │
│ 例: デプロイ        │ 高   │ 低   │ 低   │ 低   │ CLI/CI   │
│ 例: サーバ監視      │ 高   │ 中   │ 中   │ 低   │ TUI      │
├────────────────────┼──────┼──────┼──────┼──────┼──────────┤
│ あなたのタスク1:     │      │      │      │      │          │
│ あなたのタスク2:     │      │      │      │      │          │
│ あなたのタスク3:     │      │      │      │      │          │
│ あなたのタスク4:     │      │      │      │      │          │
│ あなたのタスク5:     │      │      │      │      │          │
└────────────────────┴──────┴──────┴──────┴──────┴──────────┘

評価基準:
  反復性: 低=1回限り / 中=週数回 / 高=毎日
  探索性: 低=何をすべきか明確 / 中=ある程度探索が必要 / 高=手探り
  構造性: 低=テキスト中心 / 中=表形式 / 高=視覚的・空間的
  曖昧性: 低=指示が精密 / 中=ある程度曖昧 / 高=何を探すか不明

判定基準:
  反復性が高い → CLI/スクリプト向き
  探索性が高い → GUI向き
  構造性が高い → GUI向き
  曖昧性が高い → AI(自然言語)向き
  複数の軸が中程度 → TUIやハイブリッド(コマンドパレット等)

MATRIX

echo ""
echo "→ このマトリクスの目的は、意識的にインターフェースを選ぶことだ。"
echo "  『いつも使っているから』ではなく、"
echo "  『このタスクにはこのインターフェースが最適だから』と"
echo "  言語化できるようになることが、この演習のゴールだ。"

# クリーンアップ
rm -rf /tmp/interface-lab
```

ハンズオンの自動セットアップスクリプトは `handson/command-line/24-choose-your-interface/setup.sh` を参照してほしい。

---

## 6. まとめ――ターミナルは遺物か

### この回の要点

第一に、インターフェースの歴史は四つの時代に整理できる。テキストの時代（CLI、1961年-）、視覚の時代（GUI、1973年-）、触覚の時代（NUI、2007年-）、言語の時代（自然言語、2022年-）。各時代のインターフェースは消滅するのではなく、累積している。CLIはGUIの登場後も消えず、GUIはNUIの登場後も消えず、すべてが共存している。

第二に、インターフェースの選択は四つの軸で評価できる。タスクの反復性、操作の探索性、データの構造性、コンテキストの曖昧性。反復性が高いタスクにはCLIが適し、探索性が高いタスクにはGUIが適し、曖昧性が高いタスクには自然言語インターフェースが適する。最適なインターフェースはタスクと文脈で決まる。

第三に、CLIの本質的な強さ――テキストストリーム、組み合わせ、自動化（第23回の三つの本質）――は、他のインターフェースで代替できない。GUIは組み合わせが困難であり、自然言語インターフェースは再現性が不確実だ。CLIが60年生き残った理由は、この三つの構造的優位が今なお有効だからだ。

第四に、CLIの本質的な弱さ――発見可能性の欠如、想起への依存、学習曲線の急峻さ――も、歴史を通じて一貫している。コマンドパレット、TUI、AI支援はこの弱さを補いつつあるが、完全には解消していない。

第五に、「選ぶ」ことこそが、この連載の結論だ。ターミナルを使うな、とは言わない。ターミナルだけを使え、とも言わない。タスクの性質を分析し、インターフェースの特性を理解し、最適な組み合わせを設計せよ。そのために、歴史を知れ。

### 冒頭の問いへの最終回答

ターミナルは遺物か。

24回にわたってこの問いと向き合ってきた。テレタイプの物理的な打鍵からAIエージェントの自然言語指示まで、60年のインターフェース史を辿った。その末に、私の答えはこうだ。

ターミナルは遺物ではない。テキストストリームという普遍的インターフェース、小さなツールの組み合わせによる合成可能性、操作のスクリプト化による再現性――この三つの原則が有効である限り、CLIは死なない。そしてこの三つの原則は、AIの時代にあってなお、むしろ強化されている。AIエージェントはテキストストリームを解析し、CLIコマンドを組み合わせ、スクリプトを生成する。CLIの三つの本質は、AIにとっても最適なインターフェースなのだ。

だが、ターミナルが「常に最適な選択」であるとも言わない。

GUIの発見可能性は、CLIにはない。NUIの直感性は、CLIにはない。自然言語インターフェースの曖昧さの許容は、CLIにはない。それぞれのインターフェースには、それぞれの強みがある。

最終回に言いたいことは、結局これだけだ。

**あなたのインターフェースを選べ。**

選ぶためには、選択肢を知らなければならない。選択肢を正しく評価するためには、各選択肢が「なぜそうなったか」という歴史を知らなければならない。この連載が、その「知る」ための一助となったなら、書いた甲斐があった。

1998年、私はSlackwareの黒い画面の前でCLIの世界に足を踏み入れた。あの日から27年が経った。ツールは変わった。ハードウェアは何世代も入れ替わった。だが、テキストストリーム、組み合わせ、自動化――この三つの原則は変わらない。そして、それらの原則を「知った上で選ぶ」ことの重要性も、変わらない。

あなたが明日ターミナルを開くとき――あるいは、GUIアプリケーションを起動するとき、AIに自然言語で話しかけるとき――その選択が意識的なものであることを願う。

24回のお付き合いに感謝する。

---

## 参考文献

- Ben Shneiderman, "Direct Manipulation: A Step Beyond Programming Languages", IEEE Computer, vol. 16, pp. 57-69, 1983, <https://www.cs.umd.edu/~ben/papers/Shneiderman1983Direct.pdf>
- Jakob Nielsen, "10 Usability Heuristics for User Interface Design", 1994, <https://www.nngroup.com/articles/ten-usability-heuristics/>
- Don Norman, "The Design of Everyday Things", Basic Books, 1988 (revised 2013), <https://en.wikipedia.org/wiki/The_Design_of_Everyday_Things>
- Neal Stephenson, "In the Beginning was the Command Line", 1999, <https://www.nealstephenson.com/in-the-beginning-was-the-command-line.html>
- Doug McIlroy, "UNIX Time-Sharing System: Foreword", Bell System Technical Journal, 1978
- Peter H. Salus, "A Quarter Century of UNIX", Addison-Wesley, 1994
- Paul Fitts, "The Information Capacity of the Human Motor System in Controlling the Amplitude of Movement", Journal of Experimental Psychology, 1954, <https://en.wikipedia.org/wiki/Fitts's_law>
- Computer History Museum, "Xerox Alto", <https://www.computerhistory.org/revolution/input-output/14/347>
- Wikipedia, "Windows 95", <https://en.wikipedia.org/wiki/Windows_95>
- AppleInsider, "Steve Jobs' first iPhone announcement", <https://appleinsider.com/articles/13/10/04/behind-the-scenes-details-reveal-steve-jobs-first-iphone-announcement>
- OpenAI, "Introducing ChatGPT", 2022, <https://openai.com/index/chatgpt/>
- Anthropic, Claude Code, <https://github.com/anthropics/claude-code>
- Command Line Interface Guidelines, <https://clig.dev/>
- Wikipedia, "Natural user interface", <https://en.wikipedia.org/wiki/Natural_user_interface>
