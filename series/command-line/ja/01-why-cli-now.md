# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第1回：なぜ今、コマンドラインを語るのか――GUI時代の盲点

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- GUIが「標準」になった世界で、なぜコマンドラインは死なないのか
- 「CLIは死ぬ」と予言され続けた40年史――Macintosh、Windows 95、iPhone
- 人間とコンピュータの接点としてのインターフェースの三分類（CLI / GUI / NUI）
- テキストストリームという抽象が持つ構造的な強さ
- GUI vs CLI で同一タスクを実行し、再現性と自動化容易性を体感する

---

## 1. 黒い画面の中の日常

私はVS Codeのターミナルパネルの中で、一日の大半を過ごしている。

朝、PCを開いてまず起動するのはVS Codeだ。だが、コードを書き始める前に指が向かうのはエディタ領域ではない。画面下部のターミナルパネルだ。`git pull` で最新のコードを引き、`docker compose up -d` でローカル環境を立ち上げ、`npm run dev` で開発サーバを起動する。コードを書き、テストを回し、`git diff` で差分を確認し、`git commit` する。デプロイは `terraform plan` を実行して差分を確認し、問題がなければ `terraform apply` する。一日の終わりに `git log --oneline -20` で今日の成果を振り返る。

この一連の作業のうち、私がGUIのボタンをクリックする場面はほとんどない。VS Codeのファイルエクスプローラーを使うことはあるが、ファイルの中身を見るだけなら `cat` や `bat` で済むし、探すなら `ripgrep` の方が速い。

2026年現在、Stack Overflow Developer Surveyによれば、VS Codeは開発者の73.6%に使われている。そしてそのVS Codeの画面には、必ずターミナルが埋め込まれている。世界中の開発者が、GUIの中にCLIを抱えて仕事をしているのだ。

先日、実務経験2年ほどの若いエンジニアと一緒に仕事をしていたときのことだ。私がターミナルで一連の作業を進めているのを横で見ていた彼が、こう聞いてきた。

「ターミナルって、あのレトロな黒い画面ですか？　映画のハッカーみたいな」

悪気はなかったのだと思う。彼にとってターミナルとは、映画やドラマで見る「黒い背景に緑の文字が流れるあの画面」だった。自分が毎日VS Codeの下半分で使っているものが「ターミナル」だという自覚が希薄だった。

その夜、私は考え込んだ。

ターミナルは「レトロな黒い画面」なのだろうか。2020年代に毎日使っているものが「レトロ」であるとは、いったいどういう意味なのか。

GUIが「標準」になった世界で、なぜコマンドラインは死なないのか。これは単なるノスタルジーなのか。それとも、CLIにはGUIでは代替できない構造的な何かがあるのか。

この連載は、その問いに答えるための旅である。テレタイプからAIエージェントまで、60年にわたるコマンドラインの歴史を辿りながら、「テキストを打ち、テキストが返る」というインターフェースの本質を探る。

あなたは、自分がなぜターミナルを使っているのか、説明できるだろうか。

---

## 2. 「CLIは死ぬ」――40年間反復された予言

コマンドラインインターフェースは、少なくとも過去40年間、繰り返し「死んだ」と宣告されてきた。しかし、そのたびに生き延びた。この歴史をまず確認しよう。

### 第一の死亡宣告：1984年、Macintosh

1984年1月22日、スーパーボウルXVIIIの放映中に、リドリー・スコット監督によるテレビCMが流れた。ジョージ・オーウェルの小説「1984年」を模したディストピアの映像の中、一人の女性がスクリーンにハンマーを投げ込む。2日後の1月24日、Apple MacintoshがUS$2,495で発売された。

Macintoshは、マウスとデスクトップメタファーを備えた初の商業的に成功したパーソナルコンピュータだった。画面にはフォルダとファイルのアイコンが並び、ドラッグアンドドロップで操作できた。コマンドを一文字ずつ打ち込む必要はない。Steve Jobsは後年、コンピュータを「心の自転車（bicycle for the mind）」と呼んだが、Macintoshのメッセージは明快だった――コンピュータは、もう専門家のものではない。

当時の業界の反応を振り返ると、多くの人が「これでコマンドラインの時代は終わる」と確信した。Smithsonian Magazineが2024年の回顧記事で記しているように、Macintoshのユーザーフレンドリーなアプローチは「1990年代までIBM PCとその互換機が使っていた、習得の難しいコマンドラインインターフェースを置き換えていく」ものだった。

だが、1984年の時点で、CLIはまだ死ななかった。UNIXワークステーションの世界では、SunやSGIのエンジニアたちがxtermの中でコードを書き続けていた。Macintoshの128KB RAMでは、プロフェッショナルなソフトウェア開発はできなかった。

### 第二の死亡宣告：1995年、Windows 95

1995年8月24日、MicrosoftはWindows 95を発売した。3億ドルのプロモーションキャンペーンが展開され、ローリング・ストーンズの「Start Me Up」がテーマ曲に使われた。最初の4日間で100万本が出荷された。

Windows 95がもたらした変化は決定的だった。How-To Geekの回顧記事が指摘しているように、「PCを使う人の多くがDOSの存在をほぼ意識しなくなった」のだ。Windows 95は技術的にはMS-DOS上に構築されていたが、GUIがDOSを覆い隠した。コマンドプロンプトは「DOS窓」と呼ばれ、わざわざ開かなければ存在にすら気づかないものになった。1998年末にはWindows 95のデスクトップOSシェアは57.4%に達した。

私は当時、高校生だった。Windows 95をインストールした日のことは覚えている。「もうDOS窓なんか要らない」と思った。そして数ヶ月後、Slackware 3.5のインストールに四苦八苦しながら、bash のプロンプトの前に座っていた。GUIが使えなかったのではない。GUIでは「やりたいこと」に手が届かなかったのだ。

### 第三の死亡宣告：2007年、iPhone

2007年1月9日、Steve JobsはMacWorldのステージに立ち、iPhoneを発表した。ボタンは一つだけ。スタイラスもトラックボールもキーボードもない。指でタッチし、ピンチし、スワイプする。6月29日の発売以降、iPhoneはインターフェースの概念そのものを変えた。

iPhoneの登場により、「自然なユーザーインターフェース（Natural User Interface, NUI）」という概念が脚光を浴びた。CLIが消えるどころか、キーボードすら不要になる時代が来ると予測された。WikipediaのNUIの項目が整理しているように、インターフェースの歴史はCLI→GUI→NUIという三段階で語られるようになった。

だが、2026年の現在、何が起きているか。

Dockerの市場シェアは87.67%を超え、世界108,000社以上が利用している。Kubernetes本番導入率は80%に達し、560万人の開発者がkubectlを叩いている。Docker公式ブログによれば、Docker使用率は2024年から2025年にかけて17ポイント増加した。これらのツールの操作は、すべてコマンドラインで行われる。

ripgrepが2016年にリリースされて以降、fd、bat、eza、zoxide、fzf、starship、lazygitといったモダンCLIツールが次々と登場している。CLIは死ぬどころか、ルネサンスを迎えている。

### なぜCLIは死ななかったのか

40年間、3度の死亡宣告を受け、そのたびに生き延びた技術は珍しい。FORTRANやCOBOLのように「保守のためだけに生きている」のとは違う。CLIは積極的に使われ、新しいツールが生まれ続けている。

1999年、SF作家のNeal Stephensonは"In the Beginning was the Command Line"という38,000語のエッセイを発表し、CLI/GUI/OS戦争の本質を論じた。出版社のWebサイトがSlashdot効果でダウンするほどの反響を呼んだこのエッセイで、Stephensonはコマンドラインの持つ「抽象を直接操作する力」を指摘している。

25年以上前のStephensonの問いは、今なお有効である。なぜCLIは死なないのか。答えを急ぐ前に、まず「インターフェース」とは何かを定義しよう。

---

## 3. インターフェースの三分類――CLI / GUI / NUI

### 「インターフェース」とは何か

「インターフェース」という言葉は広く使われているが、ここでは厳密に定義する。ユーザーインターフェース（UI）とは、**人間とコンピュータの間で情報を交換するための接点**である。

人間が意図を伝え、コンピュータが結果を返す。この双方向のやり取りが「インタラクション」であり、そのやり取りの方法を規定するのが「インターフェース」だ。

歴史的に、ユーザーインターフェースは三つのパラダイムに分類できる。

```
┌─────────────────────────────────────────────────────────┐
│                インターフェースの三分類                    │
├──────────┬──────────────┬───────────────────────────────┤
│   CLI    │     GUI      │            NUI              │
│ (1960s-) │   (1970s-)   │          (2000s-)           │
├──────────┼──────────────┼───────────────────────────────┤
│ テキスト │ ウィンドウ   │ タッチ/ジェスチャー/音声     │
│ 入力     │ アイコン     │                             │
│          │ メニュー     │                             │
│          │ ポインタ     │                             │
├──────────┼──────────────┼───────────────────────────────┤
│ 想起     │ 再認         │ 直感                         │
│ (recall) │(recognition) │ (intuition)                 │
├──────────┼──────────────┼───────────────────────────────┤
│ キーボード│マウス/       │ 指/体/声                     │
│          │トラックパッド│                             │
├──────────┼──────────────┼───────────────────────────────┤
│ 組み合わせ│発見しやすい  │ 学習コストが低い             │
│ やすい   │              │                             │
└──────────┴──────────────┴───────────────────────────────┘
```

### CLI：テキストによる対話

CLIは最も古いインタラクティブなインターフェースである。1960年代のタイムシェアリングシステムで生まれ、ユーザーはテキストコマンドを入力し、テキストの応答を受け取る。

CLIの本質的な特徴は**テキストストリーム**だ。入力もテキスト、出力もテキスト。この単純さが、後に述べる「組み合わせ可能性」の源泉となる。

1964年、Bell LabsのDoug McIlroyは「プログラムをガーデンホースのように接続できるべきだ」というメモを書いた。1973年1月15日、Ken ThompsonがUnix V3にパイプを実装したとき、McIlroyの構想は現実になった。McIlroyはこう記している。

> Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.

「テキストストリームを扱え。それがユニバーサルインターフェースだからだ」――この一文が、CLIの本質を50年前に正確に言い当てている。

### GUI：直接操作の世界

1973年3月1日、Xerox PARCでAltoが稼働を始めた。ビットマップディスプレイ、マウス、WYSIWYGエディタ――後にGUIと呼ばれるインターフェースの原型がここに生まれた。Alan Kay率いる研究チームは、コンピュータを「子供でも使えるもの」にしようとしていた。

GUIの理論的基盤を提供したのが、Ben Shneidermanの「直接操作（direct manipulation）」概念である。1983年にComputer誌で発表された論文"Direct Manipulation: A Step Beyond Programming Languages"で、Shneidermanは三つの原則を示した。

1. **オブジェクトとアクションの連続的な視覚表現**
2. **迅速で、漸進的で、可逆的なアクション**
3. **物理的アクションとジェスチャーによるコマンド入力の置換**

ここで重要なのは、CLIとGUIの違いが**認知モデル**の違いであるという点だ。

CLIは**想起（recall）** を要求する。ユーザーは、コマンド名、オプション、引数の構文を記憶から引き出さなければならない。`find . -name "*.log" -mtime +30 -exec rm {} \;` を正確に打つには、findコマンドの文法を記憶している必要がある。

GUIは**再認（recognition）** を提供する。ユーザーは画面に表示されたメニューやアイコンの中から「見覚えのあるもの」を選ぶだけでよい。記憶の負荷が劇的に下がる。

この認知的な差は大きい。だからこそGUIは広く普及した。コンピュータを「専門家でなくても使えるもの」に変えたのは、間違いなくGUIの功績である。

### NUI：身体による対話

2007年のiPhoneが象徴するNUIは、キーボードもマウスも必要としない。指でタッチし、声で命令する。「自然な」インターフェースという名称が示すように、人間の身体的な動作を入力として使う。

NUIは学習コストが最も低い。2歳の子供がiPadを操作できるのは、タップとスワイプが人間の「指で触れる」という本能的動作に直結しているからだ。

### 三者の関係：代替ではなく共存

ここで重要な指摘をしたい。これら三つのパラダイムは、**後から来たものが前のものを置き換える**という関係にはない。

GUIが登場してもCLIは死ななかった。NUIが登場してもGUIは死ななかった。そしてCLIも死ななかった。

なぜか。それぞれが異なるタスクに最適化されているからだ。

| 特性               | CLI        | GUI        | NUI        |
| ------------------ | ---------- | ---------- | ---------- |
| 学習コスト         | 高い       | 中程度     | 低い       |
| 操作の発見しやすさ | 低い       | 高い       | 高い       |
| 組み合わせ可能性   | 非常に高い | 低い       | 非常に低い |
| 自動化容易性       | 非常に高い | 低い       | 非常に低い |
| 再現性             | 非常に高い | 低い       | 非常に低い |
| リモート操作       | 容易       | 帯域を消費 | 困難       |
| 精密な制御         | 高い       | 中程度     | 低い       |

CLIの強みは「組み合わせ可能性」「自動化容易性」「再現性」の三つに集約される。これらはすべて、入出力がテキストストリームであることから生まれる構造的な性質だ。

### テキストストリームの普遍性

ここで、McIlroyの言葉に立ち返ろう。「テキストストリームはユニバーサルインターフェースだ」。

テキストの何が「ユニバーサル」なのか。

第一に、テキストは**人間にも機械にも読める**。JSONファイルをcatで表示すれば人間が読めるし、jqに渡せば機械が処理できる。バイナリ形式にはこの柔軟性がない。

第二に、テキストは**構造に依存しない**。CSVでもJSONでもYAMLでも、あるいは単なるプレーンテキストでも、テキストストリームとしてパイプの中を流れることができる。

第三に、テキストは**帯域に優しい**。SSHで遠隔サーバに接続し、コマンドを打ち、結果を受け取る。やり取りされるのは数バイトから数キロバイトのテキストだ。GUIのリモートデスクトップが何メガバイトもの画面データを転送するのとは対照的である。

第四に、テキストは**バージョン管理と親和する**。コマンドの履歴はdiffが取れる。シェルスクリプトはgitで管理できる。GUIの操作手順書は「スクリーンショット10枚」で表現するしかないが、CLIの操作手順は10行のテキストで完結する。

この四つの特性が、CLIが40年間死ななかった構造的理由である。GUIはコンピュータを「使いやすく」した。だが、CLIはコンピュータを「組み合わせやすく」「自動化しやすく」「再現しやすく」した。この価値は、GUIでは代替できない。

---

## 4. ハンズオン：GUI vs CLI――同じタスクで比べてみる

理屈だけでは実感が湧かない。実際に手を動かして、CLIとGUIの違いを体感しよう。

### 環境準備

Docker環境で作業する。以下のコマンドでUbuntu 24.04のコンテナを起動する。

```bash
docker run -it --rm ubuntu:24.04 bash
```

コンテナ内でテスト用のファイルを作成する。

```bash
# 必要なパッケージをインストール
apt-get update && apt-get install -y findutils coreutils gawk

# テスト用ディレクトリとファイルを作成
mkdir -p /workspace/logs /workspace/data /workspace/reports
cd /workspace

# 100個のログファイルを生成（日付・重要度・メッセージ入り）
for i in $(seq 1 100); do
  date_str=$(date -d "2025-01-01 + $((RANDOM % 365)) days" +%Y-%m-%d 2>/dev/null || echo "2025-$(printf '%02d' $((RANDOM % 12 + 1)))-$(printf '%02d' $((RANDOM % 28 + 1)))")
  severity=$(echo -e "INFO\nWARN\nERROR" | shuf -n 1)
  echo "${date_str} ${severity} server-$((RANDOM % 10)) Process completed with status $((RANDOM % 256))" >> logs/app.log
done

# 50個のデータファイルを作成（一括リネーム対象）
for i in $(seq 1 50); do
  echo "data content $i" > "data/report $(printf '%03d' $i) final.txt"
done

echo "=== 環境構築完了 ==="
ls -la logs/ data/
```

### 演習1：ファイル検索――「ERRORを含むログ行を見つける」

**CLIの場合：**

```bash
grep "ERROR" logs/app.log
```

一行で完了する。結果はテキストとして標準出力に流れ、さらにパイプで別のコマンドに渡すことができる。

```bash
# ERRORの件数を数える
grep "ERROR" logs/app.log | wc -l

# ERRORが最も多いサーバを特定する
grep "ERROR" logs/app.log | awk '{print $3}' | sort | uniq -c | sort -rn | head -5
```

3行のコマンドで、「ERRORログの抽出」「件数集計」「サーバ別ランキング」が完了した。

**GUIの場合：**

同じことをGUIで行うなら、テキストエディタでapp.logを開き、「検索」ダイアログで"ERROR"を検索し、ヒットした行を一つずつ確認することになる。件数は手動でカウントするか、「すべて置換」の件数表示を流用するしかない。サーバ別の集計に至っては、スプレッドシートにコピーペーストしてピボットテーブルを作る必要がある。

**差分：** CLIは3行のコマンドで完結する。GUIは複数のアプリケーションをまたぐ手作業が必要であり、手順を他人に伝えるにはスクリーンショット付きの手順書が必要になる。

### 演習2：一括リネーム――「スペースを含むファイル名をアンダースコアに置換する」

**CLIの場合：**

```bash
cd /workspace/data
for f in *.txt; do
  mv "$f" "$(echo "$f" | tr ' ' '_')"
done
```

あるいは、もっと簡潔に書くなら:

```bash
rename 's/ /_/g' /workspace/data/*.txt
```

**GUIの場合：**

ファイルマネージャでdata/ディレクトリを開き、50個のファイルを一つずつ右クリック→「名前の変更」で手動リネームする。50回繰り返す。ミスが混入する確率は高い。

**差分：** CLIは2行で50ファイルを正確にリネームする。GUIは50回の手作業を要し、再現性がない。

### 演習3：再現性の検証――「同じ操作をもう一度実行する」

これが最も本質的な演習である。

演習1と演習2のCLI操作は、すべてテキストとして記録されている。シェルの履歴（`history`コマンド）からそのまま取り出せるし、スクリプトファイルにコピーすればいつでも再実行できる。

```bash
#!/bin/bash
# log-analysis.sh -- ログ分析スクリプト
set -euo pipefail

LOG_FILE="${1:-logs/app.log}"

echo "=== ERROR件数 ==="
grep "ERROR" "$LOG_FILE" | wc -l

echo ""
echo "=== サーバ別ERRORランキング ==="
grep "ERROR" "$LOG_FILE" | awk '{print $3}' | sort | uniq -c | sort -rn | head -5
```

このスクリプトは、明日実行しても同じ結果を返す。新しいメンバーに渡しても、`bash log-analysis.sh` と打つだけで同じ分析ができる。gitで管理すれば、分析方法の変更履歴まで追跡できる。

GUIで行った操作を「もう一度同じように実行する」ためには何が必要か。手順書を書くしかない。しかも、その手順書は自然言語で書かれるため、「ここをクリック」「この画面が出たら」という曖昧さが避けられない。OSのバージョンが変わればスクリーンショットが古くなり、手順書はメンテナンスが必要になる。

**結論：** CLIの操作は「テキスト」であるがゆえに、自動化・再現・共有・バージョン管理が可能である。GUIの操作は「画面上の動作」であるがゆえに、これらが困難である。

これはGUIが劣っているという意味ではない。GUIには「発見しやすさ」「直感的な操作」「視覚的なフィードバック」という別の強みがある。重要なのは、タスクの性質に応じて適切なインターフェースを**選べる**ことだ。

---

## 5. まとめと次回予告

### この回の要点

第一に、コマンドラインは「古い技術」ではない。1984年のMacintosh、1995年のWindows 95、2007年のiPhone――三度の「CLIは死ぬ」という予言を生き延び、2020年代にはDocker、kubectl、Terraformといったインフラツール群の中核としてむしろ存在感を増している。

第二に、CLI/GUI/NUIは「進化の段階」ではなく、異なるタスクに最適化された**三つの並行するパラダイム**である。どれかが他を置き換えるという関係にはない。

第三に、CLIの構造的な強みは「テキストストリーム」という入出力形式に由来する。テキストは人間にも機械にも読め、構造に依存せず、帯域に優しく、バージョン管理と親和する。Doug McIlroyが1973年に「ユニバーサルインターフェース」と呼んだこの特性が、CLIを40年間生き延びさせた根本理由である。

第四に、CLIの真の価値は「組み合わせ可能性（composability）」「自動化容易性」「再現性（reproducibility）」の三つに集約される。これらはすべてテキストストリームから派生する性質であり、GUIでは構造的に代替が困難である。

### 冒頭の問いへの暫定回答

「GUIが標準になった世界で、なぜコマンドラインは死なないのか？」

暫定的な答えはこうだ。**CLIは古いから生き残っているのではない。テキストという最も普遍的なインターフェースが、あらゆる時代の計算モデルに適応し続けているからだ。**

GUIはコンピュータを「使いやすく」した。NUIはコンピュータを「触りやすく」した。だが、CLIはコンピュータを「組み合わせやすく」した。この三つは競合関係ではなく、相補関係にある。

### 次回予告

だが、ここまでの議論はまだ表層に過ぎない。「コマンドラインが便利だ」という結論だけでは、本質には辿り着けない。

次回、第2回では「コマンドライン以前の世界」に踏み込む。パンチカードとバッチ処理の時代――「対話的にコンピュータを使う」という概念すら存在しなかった時代だ。Herman Hollerithのパンチカード（1890年）からIBM 701（1952年）のバッチ処理まで、「人間がコンピュータを待つ」時代を知ることで、対話的コンピューティングがいかに贅沢な発明だったかが見えてくる。

あなたが毎日ターミナルに打ち込んでいるコマンドの一つ一つに、即座に応答が返る。これは「当然」ではない。技術的ブレークスルーの結果である。その歴史を知ることが、ターミナルの本質を理解する第二歩になる。

---

## 参考文献

- Stack Overflow, "2024 Developer Survey" / "2025 Developer Survey", <https://survey.stackoverflow.co/2024/>, <https://survey.stackoverflow.co/2025/>
- Smithsonian Magazine, "Forty Years Ago, the Mac Triggered a Revolution in User Experience", 2024, <https://www.smithsonianmag.com/innovation/forty-years-ago-the-mac-triggered-a-revolution-in-user-experience-180983623/>
- Wikipedia, "Macintosh 128K", <https://en.wikipedia.org/wiki/Macintosh_128K>
- How-To Geek, "Windows 95 Turns 25: When Windows Went Mainstream", <https://www.howtogeek.com/685668/windows-95-turns-25-heres-how-it-transformed-pcs/>
- Wikipedia, "Natural user interface", <https://en.wikipedia.org/wiki/Natural_user_interface>
- Ben Shneiderman, "Direct Manipulation: A Step Beyond Programming Languages", Computer, Vol.16, pp.57-69, 1983, <https://www.cs.umd.edu/~ben/papers/Shneiderman1983Direct.pdf>
- Docker Blog, "2025 Docker State of App Dev", <https://www.docker.com/blog/2025-docker-state-of-app-dev/>
- Octopus, "40 Kubernetes Statistics In 2025", <https://octopus.com/devops/ci-cd-kubernetes/kubernetes-statistics/>
- Unix Heritage Wiki, "features:pipes", <https://wiki.tuhs.org/doku.php?id=features:pipes>
- The New Stack, "Pipe: How the System Call That Ties Unix Together Came About", <https://thenewstack.io/pipe-how-the-system-call-that-ties-unix-together-came-about/>
- Computer History Museum, "Xerox Alto", <https://www.computerhistory.org/revolution/input-output/14/347>
- The Marginalian, "Steve Jobs on Why Computers Are Like a Bicycle for the Mind (1990)", <https://www.themarginalian.org/2011/12/21/steve-jobs-bicycle-for-the-mind-1990/>
- Neal Stephenson, "In the Beginning was the Command Line", 1999, <https://www.nealstephenson.com/in-the-beginning-was-the-command-line.html>
- KDAB, "CLI++: Upgrade Your Command Line", <https://www.kdab.com/cli-upgrade-your-command-line-with-a-new-generation-of-everyday-tools/>

---

**次回：** 第2回「コマンドライン以前の世界――パンチカードとバッチ処理」

---

_本記事は「ターミナルは遺物か――コマンドラインの本質を問い直す」連載の第1回です。_
_ライセンス：CC BY-SA 4.0_
