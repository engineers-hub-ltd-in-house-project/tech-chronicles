# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第19回：モダンターミナルエミュレータの競争――GPU描画とプロトコル拡張

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- xterm（1984年）からGhostty（2024年）まで、ターミナルエミュレータ40年の進化史と、各世代が解決しようとした課題
- Alacritty（2017年）が切り拓いたGPU描画の技術的根拠――CPUレンダリングの限界とGPUオフロードの設計判断
- kitty（2017年）によるプロトコル拡張の試み――グラフィックスプロトコル、キーボードプロトコル、そして断片化問題
- Sixel、kittyグラフィックスプロトコル、iTerm2インライン画像プロトコルの三つの画像表示方式の比較と設計思想の違い
- Windows Terminal（2019年）の歴史的意義――Microsoftがオープンソースでターミナルを作る意味
- Ghostty（2024年）の設計哲学――プラットフォームネイティブUI、標準準拠、Zig言語による実装
- ターミナルプロトコルの技術的負債と、その解消を目指す競争の構造

---

## 1. ターミナルエミュレータを渡り歩く

私のターミナルエミュレータ遍歴は、そのままLinuxデスクトップの歴史と重なる。

1990年代後半、Slackware 3.5でLinuxに入門したとき、ターミナルエミュレータの選択肢はxtermしかなかった。正確には、他にもあったのだろう。だが、当時の私にとって「ターミナルエミュレータを選ぶ」という発想自体が存在しなかった。xtermはX Window Systemの一部であり、`startx`で起動するGUI環境にはxtermが最初から存在した。黒い背景に白い文字。フォントはbitmapのfixed。カスタマイズは`.Xresources`に呪文のような設定を書くこと。それがターミナルの「全て」だった。

2000年代前半、urxvt（rxvt-unicode）に出会った。2003年にMarc Lehmannがrxvtからフォークしたこのターミナルエミュレータは、xtermより軽量で、Unicode対応が堅牢で、Perl拡張が書けた。何よりメモリ消費が少なかった。当時のLinuxマシンはRAMが256MBか512MBだ。xtermのインスタンスを10個開くのとurxvtのデーモンモード（`urxvtd`）で10個のクライアントを開くのとでは、メモリ消費が桁違いだった。

2010年代、macOSを主環境にしてからはiTerm2に移行した。George Nachmanが2010年頃から開発しているこのターミナルは、macOS標準のTerminal.appとは別世界だった。分割ペイン、Instant Replay（過去の端末出力を巻き戻せる機能）、トリガーによる自動処理。そして何より、プロファイルによる環境の切り替え。本番サーバに接続したときは背景が赤くなる設定にしていた。これだけで事故が減った。

2017年、Alacrittyの存在を知った。Joe Wilmのブログ記事のタイトルは「Announcing Alacritty, a GPU-accelerated terminal emulator」。GPU描画のターミナルエミュレータ。最初は「ターミナルにGPUが必要なのか」と懐疑的だった。テキストを表示するだけのアプリケーションに、なぜグラフィックスプロセッサが必要なのか。

だが、実際に使ってみると理解した。大量のログを`cat`で流したとき、Alacrittyは滑らかにスクロールした。iTerm2では一瞬固まるような出力が、Alacrittyでは引っかかりなく流れた。ターミナルエミュレータの描画性能は、日常の体験に直結するのだ。

その後、kittyに移行した。2017年にKovid Goyalが公開したkittyは、GPU描画に加えて独自のプロトコル拡張を積極的に策定していた。ターミナル内での画像表示、キーボード入力の正確な報告、ウィンドウ管理。kittyは「ターミナルプロトコルそのものを進化させる」という野心を持っていた。

そして2024年12月、Ghosttyが登場した。HashiCorpの共同創設者Mitchell Hashimotoが3年以上をかけて開発したこのターミナルエミュレータは、「プラットフォームネイティブなUIと、最高水準の標準準拠を両立する」という哲学を掲げた。

xterm、urxvt、iTerm2、Alacritty、kitty、Ghostty。ターミナルエミュレータを渡り歩くたびに、「表示するもの」は変わらなかった。テキストだ。だが、「表示する方法」は劇的に変わった。

あなたは、自分が使っているターミナルエミュレータが「なぜそのターミナルなのか」を、説明できるだろうか。

---

## 2. ターミナルエミュレータの40年史

### xtermの長い支配――1984年から2010年代まで

ターミナルエミュレータの歴史は、xtermから始まる。

1984年の夏、Jim Gettyの学生であるMark Vandevoordが、VAXStation 100（VS100）用のスタンドアロン端末エミュレータとしてxtermを開発した。興味深いことに、xtermはX Window Systemより先に誕生している。やがて、スタンドアロンよりもXの一部として動作させる方が有用であることが明らかになり、xtermはX Window Systemの標準ターミナルエミュレータとして統合された。

xtermが模倣するのは、第4回で語ったDEC VT102/VT220端末だ。物理的な端末が姿を消した後も、そのプロトコル――エスケープシーケンスによるカーソル移動、文字装飾、画面制御――は、xtermを通じてソフトウェアの世界に生き続けた。

xtermの長寿を支えたのは、Thomas E. Dickeyの存在だ。1990年代からxtermのメンテナンスを引き継いだDickeyは、以来30年以上にわたってxtermの拡張と保守を続けている。第5回で語ったncursesのメンテナもDickeyである。ターミナルの世界は、この一人の開発者に多くを負っている。

xtermは長く「十分」だった。テキストを表示し、キー入力を受け付け、エスケープシーケンスを解釈する。端末エミュレータに求められる基本機能は、1980年代の設計で事足りた。

だが、「十分」は「最適」を意味しない。

### 軽量化の時代――rxvt、urxvtの系譜

xtermの最初の不満は「重さ」だった。

xtermはDEC VT102/VT220に加え、Tektronix 4014グラフィックス端末のエミュレーションも実装し、ツールキットベースの豊富な設定機能を持っていた。これらの機能は多くのユーザーにとって不要だった。1990年代のLinuxマシンのリソース制約を考えれば、不要な機能が占めるメモリは無視できない。

Rob Nationが開発したrxvtは、xtermの「軽量版」として設計された。Tektronix 4014エミュレーションやツールキット設定機能を省略し、VT102互換に絞ることで、メモリ消費を削減した。

2003年11月、Marc Lehmannがrxvtをフォークしてrxvt-unicode（urxvt）を公開した。名前が示すとおり、Unicode対応が主眼だ。元のrxvtはASCII時代の設計を引きずっており、国際化対応が不十分だった。urxvtはすべてのテキストを内部的にUnicodeで保持し、Xftフォントによるアンチエイリアス描画に対応した。クライアント-サーバアーキテクチャ（`urxvtd`デーモンと`urxvtc`クライアント）により、複数のターミナルウィンドウ間でメモリを共有する設計も特徴だった。

xterm→rxvt→urxvtの系譜は、「同じことを、より少ないリソースで」という最適化の歴史だ。ターミナルの機能そのものを変えるのではなく、実装の効率を改善する。この方向性は2010年代まで支配的だった。

### macOSの独自進化――iTerm2

2010年頃、macOSの世界ではiTerm2が独自の進化を遂げていた。

George Nachmanが開発したiTerm2は、iTerm（2006年）の後継として登場した。iTerm2が重要なのは、「ターミナルエミュレータのUXを改善する」という方向性を明確に打ち出したことだ。

分割ペインは、tmuxを使わずにターミナル内で画面を分割する機能だ。Instant Replayは、過去の端末出力をタイムスタンプ付きで巻き戻せる。プロファイルは、接続先や用途に応じて背景色、フォント、キーバインドを切り替える。これらの機能はターミナルの「プロトコル」には手を加えず、エミュレータの「アプリケーション」としての完成度を高めるものだった。

さらにiTerm2は、独自のインライン画像プロトコルを策定した。OSC 1337エスケープシーケンスを使い、Base64エンコードされた画像データをターミナル内に表示する。`imgcat`コマンドで画像をターミナルに表示できるこの機能は、「テキストしか表示できない」というターミナルの常識を静かに覆した。

iTerm2はmacOS専用であり、その恩恵はmacOSユーザーに限られた。だが、「ターミナルエミュレータはもっと良くなれる」という証明としての意義は、プラットフォームの壁を超えて波及した。

---

## 3. GPU描画革命とプロトコル拡張の競争

### Alacritty――GPUがターミナルを描く

2017年1月6日、Joe Wilmはブログ記事「Announcing Alacritty, a GPU-accelerated terminal emulator」を公開した。記事の冒頭で、Wilmはこう書いている。Alacrittyは「既存のターミナルエミュレータへの不満の結果」であると。vim inside tmuxの体験が、どのターミナルでも十分に速くなかった、と。

なぜターミナルエミュレータにGPUが必要なのか。この問いに答えるには、従来のターミナルの描画方式を理解する必要がある。

従来のターミナルエミュレータ――xterm、urxvt、あるいはGNOME Terminal――は、CPUでテキストをレンダリングする。フォントのグリフをCPU上でラスタライズし、ピクセルバッファに書き込み、それをウィンドウシステム経由で画面に転送する。この方式は長年うまく機能してきた。テキストの描画はグラフィックスの中では比較的軽い処理であり、CPUでも十分に速かったからだ。

だが、「十分に速い」の閾値は時代とともに変わる。

2010年代のターミナル利用は、1980年代のそれとは質的に異なっている。大量のログを流すCI/CDのビルド出力。Dockerの`docker build`が吐き出す数千行のテキスト。Webpackやesbuildのバンドル結果。catやlessで開く数万行のファイル。これらの場面で、CPUレンダリングは目に見えるボトルネックとなる。

Alacrittyは、この問題をGPUオフロードで解決した。

```
従来のターミナル描画（CPUレンダリング）:

  テキストデータ → CPU（グリフ描画）→ ピクセルバッファ → 画面
                    ↑ ボトルネック
  - フォントのラスタライズがCPUで行われる
  - 大量テキストの高速スクロールでCPU負荷が急上昇
  - メインスレッドがブロックされ、入力遅延が発生

GPU描画のターミナル（Alacritty方式）:

  テキストデータ → GPU（グリフをテクスチャとして描画）→ 画面
                    ↑ 並列処理に適した計算
  - グリフのキャッシュをビデオRAM（VRAM）に保持
  - OpenGL ES 2.0によるテクスチャレンダリング
  - CPUはパース処理に集中、描画はGPUに委任
  - 大画面のテキスト描画で約500FPS（Wilmの計測）
```

Alacrittyの設計は徹底的にミニマリストだ。タブもスプリットもない。設定はYAMLファイル（のちにTOML）を手動で編集する。GUIの設定画面もない。Rust言語で実装され、クロスプラットフォーム（Linux、macOS、Windows、BSD）で動作する。

このミニマリズムは意図的な設計判断だ。タブやスプリットはtmuxやウィンドウマネージャに任せる。ターミナルエミュレータは「テキストを速く正確に描画する」ことに集中する。第10回で語ったUNIX哲学の「一つのことをうまくやれ」を、ターミナルエミュレータ自身に適用した設計と言える。

Alacrittyの登場は、ターミナルエミュレータの競争に新しい軸を導入した。それまでの競争軸は「機能の多さ」か「リソースの少なさ」だった。Alacrittyは「描画性能」という第三の軸を提示した。

### kitty――プロトコルを進化させる

Alacrittyと同じ2017年に登場したkittyは、GPU描画を採用した点では同じだが、哲学は正反対だった。

Alacrittyが「ターミナルエミュレータの機能を削る」方向に進んだのに対し、kittyは「ターミナルエミュレータの機能を拡張する」方向に進んだ。しかも、単にアプリケーション機能を追加するのではなく、ターミナルのプロトコルそのものを拡張しようとした。

kittyの作者Kovid Goyalは、Calibreという電子書籍管理ソフトウェアの作者としても知られている。大規模なソフトウェアプロジェクトを長期間にわたって維持してきた経験を持つ開発者だ。

kittyが策定したプロトコル拡張は、大きく二つの領域にわたる。

**第一に、グラフィックスプロトコル。** ターミナル内で任意のピクセル画像を表示するためのプロトコルだ。画像データを24bit RGB、32bit RGBA、またはPNG形式で送信し、ターミナルが画面上の指定位置に描画する。画像の部分更新、アニメーション、仮想プレースメント（テキストフローとの統合）もサポートする。

**第二に、キーボードプロトコル。** VT100時代から引き継がれたキーボード入力の報告方式は、根本的な問題を抱えている。

```
レガシーキーボードプロトコルの問題:

  Ctrl+I  →  0x09（TAB文字と同じバイト）
  Ctrl+M  →  0x0D（Enter/CRと同じバイト）
  Ctrl+[  →  0x1B（ESCと同じバイト）

  → アプリケーションは「Ctrl+Iが押されたのか、TABキーが押されたのか」を
    区別できない

  修飾キーの問題:
  Ctrl+Shift+A  →  多くのターミナルでは報告方法が未定義
  Super（Cmd/Win）キー  →  ほぼ報告されない
  キーリリースイベント  →  VT100プロトコルでは存在しない

kittyキーボードプロトコル:
  - すべてのキーを一意に識別するコードで報告
  - 修飾キーの状態を正確にビットフラグで伝達
  - キーの押下/リピート/リリースを区別
  - レガシーとの互換性を保つオプトイン方式
```

kittyキーボードプロトコルは、アプリケーションがオプトインすることでレガシーとの互換性を維持する設計だ。アプリケーションが明示的にプロトコルの有効化を要求しない限り、従来どおりの動作をする。この設計は、40年分の互換性を壊さずに新機能を導入するための、現実的な妥協だ。

kittyのプロトコル拡張が業界に与えた影響は大きい。2025年初頭の時点で、kittyキーボードプロトコルはiTerm2、foot、WezTerm、Ghosttyなど複数のターミナルエミュレータで実装されている。kittyグラフィックスプロトコルも、同様に複数のターミナルで採用が進んでいる。一つのターミナルエミュレータが策定したプロトコルが、デファクト標準として広がりつつある。

だが、ここに問題がある。

### 三つの画像プロトコル――断片化の現実

ターミナル内で画像を表示するプロトコルは、2020年代の時点で少なくとも三つ存在する。

```
ターミナル画像プロトコルの比較:

  Sixel（DEC由来、1980年代）
    原理: 6ピクセル高のビットマップパターンをASCII文字にマッピング
    色数: 最大256色（パレット方式）
    圧縮: ランレングス符号化（RLE）
    利点: 古い規格であり、多くのターミナルが対応
    欠点: 色数の制限、解像度の制約、帯域効率が低い
    対応: xterm, mlterm, foot, WezTerm 等

  kittyグラフィックスプロトコル（2017年〜）
    原理: 24bit RGB/32bit RGBA/PNGをBase64で送信
    色数: True Color（24bit、約1677万色）
    圧縮: PNG圧縮、zlib圧縮をサポート
    利点: 高色数、部分更新、アニメーション、仮想プレースメント
    欠点: kitty以外での対応がまだ限定的
    対応: kitty, WezTerm, Ghostty 等

  iTerm2インライン画像プロトコル（2010年代〜）
    原理: OSC 1337シーケンスでBase64画像を送信
    色数: 画像フォーマット依存（PNG等のフルカラー）
    圧縮: 画像フォーマット自体の圧縮に依存
    利点: macOSのすべての画像形式に対応、PDF表示も可能
    欠点: 元々macOS/iTerm2専用の設計
    対応: iTerm2, WezTerm, mintty 等
```

三つのプロトコルが並立する状況は、アプリケーション開発者にとって負担だ。ターミナル内で画像を表示したいアプリケーションは、「どのプロトコルが使えるか」を実行時に判定し、それぞれに対応するコードを書く必要がある。あるいは、一つのプロトコルだけを実装し、他のターミナルでは画像が表示できないことを受け入れる。

この断片化は、ターミナルプロトコルに「標準化団体」が存在しないことの帰結だ。VT100のエスケープシーケンスはANSI X3.64（1979年）として標準化されたが、それ以降のターミナルプロトコルの拡張は、各ターミナルエミュレータが独自に行ってきた。ECMAやISOが新しいターミナルプロトコル標準を策定する動きはなく、デファクト標準が有機的に形成される――あるいは、形成されずに断片化する。

### Windows Terminal――Microsoftの転回

2019年5月、MicrosoftはBuild 2019カンファレンスでWindows Terminalを発表した。ソースコードは同月3日にGitHubで公開された。安定版v1.0のリリースは2020年5月19日。MITライセンスのオープンソースだ。

この発表の歴史的意義は、技術的な特徴以上に大きい。

Microsoftは30年以上にわたり、Windowsのコマンドラインホスト（conhost.exe）を事実上放置してきた。cmd.exeのウィンドウサイズ変更が不便であること、コピー&ペーストの操作性が悪いこと、True Colorをサポートしないこと――これらは「Windowsのコマンドラインは使いにくい」という評判の一因だった。第6回で語ったcmd.exeの歴史は、Microsoftにとってのコマンドライン軽視の歴史でもあった。

Windows Terminalは、この姿勢の明確な転回だ。GPU描画（DirectWrite/DirectX）、タブ、分割ペイン、Unicode/絵文字の完全サポート、True Color対応。さらに、Windows Subsystem for Linux（WSL）のシェル、PowerShell、cmd.exe、Azure Cloud Shellを同一のターミナル内でタブとして管理できる。

Microsoftの開発チームは、Windows Command Lineブログで開発の過程を詳細に公開している。カリグラフィのエキスパートを招いてテキストレンダリングの品質を追求したこと、フォントのリガチャ対応、プログラマブルフォント（Cascadia Code）の開発。これらは、Microsoftが「ターミナルエミュレータを真剣に作っている」ことの証左だ。

### Warp――AIがターミナルに入る

2022年に公開されたWarpは、別の意味で議論を呼んだ。

Zach Lloyd（元Google Principal Engineer、Google Docs担当）が2020年6月に創業した同社は、Rust製のターミナルエミュレータを開発した。技術的な特徴は三つある。ブロック単位のコマンド出力管理、IDEライクなテキストエディタ、そしてAI統合だ。

2023年4月、WarpはOpenAIの大規模言語モデルを統合したWarp AIを発表した。自然言語からコマンドを生成し、コマンドの意味を解説し、エラーの原因を説明する。第22回で詳しく語るAI+CLIの先駆けだ。

Warpに対する懸念は、主に二つの点に集中した。第一に、プロプライエタリであること。ターミナルエミュレータは開発者のすべての入出力が流れる場所だ。その場所がプロプライエタリなクラウド連携機能を持つことへの抵抗感は、特にOSS文化の強いターミナルユーザーコミュニティでは大きかった。第二に、Sequoia Capital等のVCからの出資を受けていること。ターミナルエミュレータというインフラストラクチャ的なソフトウェアが、VC支援のスタートアップによって開発されることの持続可能性への疑問だ。

Warpの功績は、「ターミナルエミュレータのUXは根本から再設計できる」という可能性を示したことにある。コマンド出力をブロック単位で管理し、過去の出力を折りたたみ、検索する。テキスト入力をIDEのエディタのように行う。これらは、VT100互換の枠組みの中では実現が困難だった発想だ。

### Ghostty――標準準拠とネイティブUIの両立

2024年12月26日、Mitchell HashimotoはGhostty 1.0を公開した。

Hashimotoは、HashiCorpの共同創設者として知られる。Vagrant、Packer、Terraform、Consul、Vault――インフラストラクチャの世界を変えた複数のツールを生み出した開発者だ。その人物が、3年以上を費やして開発したのがGhosttyである。

Ghosttyの設計哲学は二つの柱で成り立っている。

**第一に、プラットフォームネイティブなUI。** macOSではSwiftUI + Metal、LinuxではGTK + OpenGLで描画する。Electron/WebViewのようなクロスプラットフォーム抽象化レイヤーを使わない。macOSではmacOSらしく振る舞い、LinuxではLinuxらしく振る舞う。Alacrittyがクロスプラットフォームの統一感を優先したのに対し、Ghosttyは各プラットフォームの流儀に従うことを選んだ。

**第二に、最高水準の標準準拠。** Ghosttyは、xterm自身を除けば、xtermのエスケープシーケンスに最も忠実に準拠するターミナルエミュレータを目指している。さらに、kittyキーボードプロトコル、kittyグラフィックスプロトコル、スタイル付きアンダーラインといったモダンな仕様にも対応する。レガシーとモダンの両方を高い水準でサポートする。

実装言語はZigだ。Zig言語は2016年にAndrew Kelleyが設計したシステムプログラミング言語で、Cとの相互運用性を重視しつつ、Cの問題点（未定義動作、メモリ安全性の欠如）を解消する設計を持つ。GhosttyはZig言語の大規模実用例としても注目されている。

Hashimotoは、Ghosttyの運営に非営利法人を選択した。VCからの出資を受けないという明確な方針だ。ターミナルエミュレータのような基盤的なソフトウェアは、営利企業の成長戦略に組み込まれるべきではないという判断だろう。Warpとは対照的なアプローチである。

---

## 4. ターミナルプロトコルの40年分の技術的負債

### VT100互換という呪縛

ここまで個別のターミナルエミュレータの歴史を追ってきた。ここで視点を変え、これらの競争が何を意味するのかを考える。

すべてのモダンターミナルエミュレータは、1978年に発売されたDEC VT100のプロトコルとの互換性を維持している。第4回で語ったように、VT100はANSI X3.64に準拠した最初の商業端末であり、そのエスケープシーケンスは事実上の業界標準となった。

だが、VT100のプロトコルは1978年のハードウェア制約の中で設計されたものだ。第4回で語った300bpsのボーレート制約、80列×24行の画面サイズ、7ビットASCIIの文字集合。これらの制約は物理端末の時代には合理的だったが、2020年代のターミナルエミュレータには不要な制約となっている。

にもかかわらず、VT100互換を捨てることはできない。なぜか。

```
VT100互換が必要な理由:

  1. SSH越しの接続
     → リモートサーバのアプリケーションは、接続元のターミナルが
        「VT100互換」であることを前提としている
     → TERM=xterm-256color が事実上の標準

  2. ncurses/terminfoデータベース
     → TUIアプリケーション（vim, htop, tmux等）は、terminfoの
        端末記述に基づいてエスケープシーケンスを選択する
     → 新しいプロトコルに対応するには、terminfoの更新が必要

  3. シェルスクリプト・CI/CD
     → tputコマンド、エスケープシーケンスのハードコーディング
     → 膨大な既存スクリプトが特定のエスケープシーケンスに依存

  4. 40年分のソフトウェア資産
     → VT100互換を前提とするソフトウェアは数え切れない
     → 互換性を壊すと、既存ツールが動作しなくなる
```

この「VT100互換という呪縛」が、ターミナルプロトコルの進化を構造的に制約している。新しい機能を追加する際は、既存のプロトコルと衝突しないエスケープシーケンスの「空き領域」を見つける必要がある。そして、その「空き領域」をどう使うかは、各ターミナルエミュレータが独自に決める。標準化団体は存在しない。

### 断片化がもたらすもの

画像プロトコルの三つ巴（Sixel、kittyグラフィックスプロトコル、iTerm2インライン画像プロトコル）は、この構造的問題の典型例だ。

だが、断片化はプロトコルだけの問題ではない。

ターミナルエミュレータごとの微妙な挙動の違い――特定のエスケープシーケンスの解釈の差異、Unicodeの幅計算の不一致、True Colorのサポートレベルの差――は、TUIアプリケーション開発者にとって継続的な負担となっている。第18回で語ったBubbletea、Textual、Ratatuiといったモダンフレームワークは、この差異を吸収するレイヤーとしても機能している。

kittyのKovid Goyalが自身のプロトコル拡張を「kitty固有」ではなく「業界標準」にしようとしているのは、この断片化への対抗策だ。事実、kittyキーボードプロトコルは複数のターミナルで採用され、デファクト標準に近づきつつある。だが、デファクト標準の形成は、デジュール標準（公的な標準化機関による策定）に比べて時間がかかり、完全な互換性が保証されない。

ターミナルエミュレータの競争は、単に「どのターミナルが速いか」「どのターミナルが美しいか」という問題ではない。「40年分の技術的負債をどう解消するか」という、より根本的な問題に対する異なるアプローチの競争なのだ。

### 入力遅延――体感の技術

GPU描画の効果は、描画速度だけでなく入力遅延（レイテンシ）にも現れる。

Dan Luuが2017年頃に公開したターミナルエミュレータの入力遅延比較は、業界に衝撃を与えた。キーを押してから文字が画面に表示されるまでの時間を計測したもので、ターミナルエミュレータ間で数十ミリ秒の差があることを示した。

beuke.orgの測定では、Typometer（ソフトウェアベースの遅延測定ツール）を使い、Alacrittyで約6.9ms、tmux内のNeovim in Alacrittyで約8.3msという結果が報告されている。kittyもまた、レンダリングしたグリフのキャッシュをビデオRAMに保持することで低遅延を実現している。

数ミリ秒の差を人間が知覚できるのかという疑問はもっともだ。だが、長時間にわたってターミナルで作業する開発者にとって、「引っかかりのなさ」は累積的な体験の質を左右する。数十ミリ秒の遅延が積み重なれば、「なんとなく鈍い」という感覚になる。逆に、遅延が一貫して低ければ、「キーを押した瞬間に反応する」という快適さが得られる。

ただし、GPU描画が自動的に低遅延を意味するわけではない。GPUへのデータ転送、シェーダのコンパイル、フレームバッファの切り替え――GPU描画には固有のオーバーヘッドがある。重要なのは、「GPU描画か否か」ではなく、「全体のパイプラインが最適化されているか」だ。Ghosttyがプラットフォームネイティブの描画API（macOSではMetal、LinuxではOpenGL）を選んだのは、汎用的な抽象化レイヤーを挟まないことで、このパイプラインを最短にするためだ。

```
ターミナルの入力遅延パイプライン:

  キー入力 → OS入力処理 → ターミナルアプリ入力処理
  → エスケープシーケンス送信 → シェル/アプリ処理
  → エスケープシーケンス受信 → パーサー処理
  → レンダリング（CPU or GPU）→ 画面表示

  各段階で数ミリ秒のオーバーヘッドが加算される
  GPU描画が効くのは「レンダリング」段階のみ
  全体の最適化には、パイプライン全体の見直しが必要
```

---

## 5. ハンズオン：ターミナルエミュレータの能力を比較する

### 環境構築

```bash
# Docker環境で実行（ubuntu:24.04ベース）
docker run -it --rm ubuntu:24.04 bash
```

### 演習1：ターミナルの基本情報を確認する

```bash
apt-get update && apt-get install -y ncurses-bin

echo "=== 演習1: ターミナルの基本情報 ==="
echo ""

# 現在のターミナル情報
echo "--- 環境変数 ---"
echo "TERM=${TERM}"
echo "COLORTERM=${COLORTERM:-未設定}"
echo "TERM_PROGRAM=${TERM_PROGRAM:-未設定}"
echo ""

# terminfoが認識する端末能力
echo "--- terminfoによる端末能力 ---"
echo "色数: $(tput colors)"
echo "行数: $(tput lines)"
echo "列数: $(tput cols)"
echo ""

# True Colorサポートの確認
echo "--- True Color (24bit) サポートの確認 ---"
echo "以下にグラデーションが表示されれば、True Colorをサポート:"
echo ""
for i in $(seq 0 6 255); do
  printf "\033[48;2;${i};$((255-i));$(((i*2)%256))m  "
done
printf "\033[0m\n"
echo ""

echo "→ TERM環境変数は、アプリケーションが端末の能力を判断する手がかりだ。"
echo "  xterm-256colorは事実上の標準だが、True Colorの検出には"
echo "  COLORTERM=truecolor が使われることもある。"
echo "  この不統一が、ターミナルプロトコル断片化の一例だ。"
```

### 演習2：エスケープシーケンスの互換性を検証する

```bash
echo ""
echo "=== 演習2: エスケープシーケンスの互換性 ==="
echo ""

# 基本的なSGR（Select Graphic Rendition）
echo "--- 基本SGR属性 ---"
echo -e "\033[1m太字\033[0m"
echo -e "\033[2m暗い\033[0m"
echo -e "\033[3mイタリック\033[0m"
echo -e "\033[4m下線\033[0m"
echo -e "\033[4:3m波線下線（curly underline）\033[0m"
echo -e "\033[9m取り消し線\033[0m"
echo -e "\033[53mオーバーライン\033[0m"
echo ""

# スタイル付きアンダーライン（モダンターミナル機能）
echo "--- スタイル付きアンダーライン ---"
echo "（kitty, Ghostty, WezTerm等のモダンターミナルで表示）"
echo -e "\033[4:1m直線（straight）\033[0m"
echo -e "\033[4:2m二重線（double）\033[0m"
echo -e "\033[4:3m波線（curly）\033[0m"
echo -e "\033[4:4m点線（dotted）\033[0m"
echo -e "\033[4:5m破線（dashed）\033[0m"
echo ""

# 色付きアンダーライン
echo "--- 色付きアンダーライン ---"
echo -e "\033[4:3m\033[58;2;255;0;0m赤い波線\033[0m"
echo -e "\033[4:3m\033[58;2;0;255;0m緑の波線\033[0m"
echo -e "\033[4:3m\033[58;2;0;100;255m青の波線\033[0m"
echo ""

echo "→ スタイル付きアンダーラインは、xtermでは未対応だが、"
echo "  kitty、Ghostty、WezTerm等のモダンターミナルではサポートされている。"
echo "  IDEのエラー表示のような波線下線を、ターミナル内でも使える。"
echo "  この機能の有無が、TUIアプリケーションの表現力を左右する。"
```

### 演習3：大量テキスト出力の描画性能を体感する

```bash
echo ""
echo "=== 演習3: 大量テキスト出力の描画性能比較 ==="
echo ""

# テスト用データを生成
echo "テストデータを生成中..."

# 10万行のテストデータ
seq 1 100000 > /tmp/large_output.txt

# 色付きテスト出力（ターミナルの負荷が高い）
python3 -c "
import random
colors = [31,32,33,34,35,36,91,92,93,94,95,96]
for i in range(50000):
    c = random.choice(colors)
    print(f'\033[{c}m[{i:06d}] Log entry with colored output: status=OK metric={random.randint(1,9999)}\033[0m')
" > /tmp/colored_output.txt 2>/dev/null || echo "(python3未インストール: 色付きテストをスキップ)"

echo ""
echo "--- テスト1: プレーンテキスト（10万行） ---"
echo "実行: time cat /tmp/large_output.txt > /dev/null"
time cat /tmp/large_output.txt > /dev/null
echo ""

if [ -f /tmp/colored_output.txt ]; then
echo "--- テスト2: 色付きテキスト（5万行、エスケープシーケンス付き） ---"
echo "実行: time cat /tmp/colored_output.txt"
echo "（実際にターミナルに出力して描画性能を確認する場合:）"
echo "  cat /tmp/colored_output.txt"
echo ""
echo "→ /dev/nullにリダイレクトした場合との時間差が、描画のコストだ。"
echo "  GPU描画のターミナル（Alacritty, kitty, Ghostty）では"
echo "  この差が小さくなる傾向がある。"
fi

echo ""
echo "--- テスト3: Unicode幅計算の負荷 ---"
echo ""
echo "CJK文字を含む行（全角文字は2セル幅として計算される）:"
echo ""
for i in $(seq 1 20); do
  echo "行${i}: 日本語テキストとASCII text の混在行。ターミナルは各文字の幅を計算する。"
done
echo ""
echo "→ 日本語等のCJK文字は、ターミナルが各文字の幅（1セルか2セルか）を"
echo "  判定する必要がある。この幅計算がターミナルエミュレータごとに"
echo "  微妙に異なることがあり、TUIアプリケーションのレイアウト崩れの原因になる。"
echo "  Unicode East Asian Width の解釈の違いがこの問題の根源だ。"
```

### 演習4：ターミナルの画像表示能力を確認する

```bash
echo ""
echo "=== 演習4: ターミナルの画像表示能力 ==="
echo ""

echo "--- Sixelサポートの確認 ---"
echo "以下のコマンドでSixel画像を表示する試みを行う:"
echo ""

# 最小のSixel画像（8x6ピクセルの赤い四角）
echo "最小Sixel画像の送信:"
printf '\033Pq
#0;2;100;0;0
#0~~~~~~-
#0~~~~~~-
#0~~~~~~-
#0~~~~~~-
#0~~~~~~-
#0~~~~~~\033\\'
echo ""
echo ""
echo "↑ 赤い小さなブロックが表示されれば、Sixelをサポートしている。"
echo "  何も表示されない、または文字化けする場合、非サポートだ。"
echo ""

echo "--- kittyグラフィックスプロトコルの確認 ---"
echo "kittyプロトコルは、PNGデータをBase64で送信する。"
echo "kittyまたはGhosttyを使っている場合のみ表示される:"
echo ""

# 1x1ピクセルの赤いPNG（Base64）をkittyプロトコルで送信
echo "（kitty/Ghostty以外では何も表示されない）"
printf '\033_Gf=100,a=T;iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==\033\\'
echo ""
echo ""

echo "→ 画像プロトコルの対応状況は、ターミナルエミュレータによって異なる。"
echo "  Sixel: xterm(-experimental), mlterm, foot, WezTerm等"
echo "  kitty: kitty, WezTerm, Ghostty等"
echo "  iTerm2: iTerm2, WezTerm, mintty等"
echo ""
echo "  WezTermが3プロトコルすべてをサポートしているのは注目に値する。"
echo "  だが、この「全対応」の必要性こそが、断片化の問題を物語っている。"
```

ハンズオンの自動セットアップスクリプトは `handson/command-line/19-modern-terminal-emulators/setup.sh` を参照してほしい。

---

## 6. まとめと次回予告

### この回の要点

第一に、ターミナルエミュレータの歴史は三つの時代に分けられる。xterm支配の時代（1984年〜2010年代）、軽量化と差別化の時代（rxvt/urxvt、iTerm2）、そしてGPU描画とプロトコル拡張の競争の時代（2017年〜、Alacritty、kitty、Windows Terminal、Warp、Ghostty）。2017年のAlacrittyとkittyの同時登場が、第三の時代の起点だ。

第二に、GPU描画の導入は「贅沢」ではなく合理的な設計判断だ。CPUレンダリングは大量テキスト出力やリッチなTUIアプリケーションの描画でボトルネックとなる。GPUにレンダリングをオフロードし、CPUをパース処理に集中させることで、描画性能と入力遅延の両方を改善できる。ただし、GPU描画が自動的に低遅延を保証するわけではなく、パイプライン全体の最適化が重要だ。

第三に、kittyが策定したプロトコル拡張（グラフィックスプロトコル、キーボードプロトコル）は、VT100時代から引きずる技術的限界を解消する試みとして意義がある。特にキーボードプロトコルは、iTerm2、foot、WezTerm、Ghosttyに採用され、デファクト標準に近づいている。

第四に、ターミナルの画像表示プロトコルは三つ（Sixel、kittyグラフィックスプロトコル、iTerm2インライン画像プロトコル）が並立しており、標準化団体が不在のまま断片化が進行している。この断片化は、ターミナルプロトコルの進化における構造的な課題だ。

第五に、ターミナルエミュレータの競争は、「どのターミナルが速いか」という表層的な問いの裏に、「40年分のVT100互換という技術的負債をどう解消するか」という根本的な問いを抱えている。Alacrittyは「最小限の互換を高速に」、kittyは「互換を維持しつつプロトコルを拡張」、Warpは「互換の枠を超えてUXを再設計」、Ghosttyは「最高水準の互換とモダン仕様の両立」という、それぞれ異なるアプローチを取っている。

### 冒頭の問いへの暫定回答

ターミナルエミュレータに「GPU描画」が必要な理由は何か。そしてその競争は何を意味するのか。

GPU描画が必要な理由は、ターミナルの「使われ方」が変わったからだ。1984年のxtermが想定していたのは、80列×24行の画面に人間が手で打ったコマンドの結果が数行表示される使い方だ。2020年代のターミナルは、数千行のビルドログが一瞬で流れ、True Colorで色付けされたTUIアプリケーションが毎秒数十回画面を更新し、画像が表示される場所になった。この負荷に対して、CPUレンダリングでは限界がある。

そして、この競争が意味するのは、「ターミナルのプロトコルが40年分の技術的負債を抱えている」という現実だ。各ターミナルエミュレータは、この負債に対して異なる戦略で臨んでいる。だが、いずれの戦略もVT100互換という制約の中で動いている。互換性を完全に捨てることは、40年分のソフトウェア資産を捨てることを意味するからだ。

ターミナルエミュレータの競争は、技術的負債との共存の知恵の競争でもある。完全な解決はない。だが、kittyキーボードプロトコルのようにオプトインで新機能を導入し、既存の互換性を壊さずに前進するアプローチが、現実的な進化の道筋を示している。

### 次回予告

次回、第20回「PowerShell――テキストパイプラインへの根本的批判」では、ターミナルエミュレータの中を流れる「データの形」に焦点を移す。

第7回で語ったUNIXパイプは、テキストストリームをプログラム間で受け渡す。この設計は50年間機能してきた。だが、2006年にJeffrey SnoverがPowerShellで投げかけた批判は根本的だった。「テキストを流すのではなく、オブジェクトを流すべきだ」。テキストパイプラインの限界と、オブジェクトパイプラインの可能性。そして構造化データパイプラインのさらなる発展であるNushell。パイプラインの設計思想の違いが、CLIの未来をどう形作るのかを語る。

---

## 参考文献

- Wikipedia, "xterm", <https://en.wikipedia.org/wiki/Xterm>
- Thomas E. Dickey, "XTERM -- Terminal emulator for the X Window System", <https://invisible-island.net/xterm/>
- Wikipedia, "Rxvt", <https://en.wikipedia.org/wiki/Rxvt>
- Marc Lehmann, "rxvt-unicode", <https://software.schmorp.de/pkg/rxvt-unicode.html>
- Wikipedia, "iTerm2", <https://en.wikipedia.org/wiki/ITerm2>
- iTerm2 -- macOS Terminal Replacement, <https://iterm2.com/>
- iTerm2, "Images -- Inline Images Protocol", <https://iterm2.com/documentation-images.html>
- Joe Wilm, "Announcing Alacritty, a GPU-accelerated terminal emulator", 2017, <https://jwilm.io/blog/announcing-alacritty/>
- Wikipedia, "Alacritty", <https://en.wikipedia.org/wiki/Alacritty>
- GitHub, alacritty/alacritty, <https://github.com/alacritty/alacritty>
- Kovid Goyal, "kitty -- the fast, feature-rich, GPU based terminal emulator", <https://sw.kovidgoyal.net/kitty/>
- kitty, "Terminal graphics protocol", <https://sw.kovidgoyal.net/kitty/graphics-protocol/>
- kitty, "Comprehensive keyboard handling in terminals", <https://sw.kovidgoyal.net/kitty/keyboard-protocol/>
- Wikipedia, "Windows Terminal", <https://en.wikipedia.org/wiki/Windows_Terminal>
- Microsoft, "Introducing Windows Terminal", 2019, <https://devblogs.microsoft.com/commandline/introducing-windows-terminal/>
- Wikipedia, "Warp (terminal)", <https://en.wikipedia.org/wiki/Warp_(terminal)>
- Mitchell Hashimoto, "Ghostty 1.0 is Coming", 2024, <https://mitchellh.com/writing/ghostty-is-coming>
- Ghostty, <https://ghostty.org/>
- GitHub, ghostty-org/ghostty, <https://github.com/ghostty-org/ghostty>
- Wikipedia, "Sixel", <https://en.wikipedia.org/wiki/Sixel>
- DEC, "VT330/VT340 Programmer Reference Manual -- Sixel Graphics", <https://vt100.net/docs/vt3xx-gp/chapter14.html>
- Dan Luu, "Terminal latency", <https://danluu.com/term-latency/>
- beuke.org, "Terminal Latency", <https://beuke.org/terminal-latency/>
- Gregory Anders, "State of the Terminal", <https://gpanders.com/blog/state-of-the-terminal/>
