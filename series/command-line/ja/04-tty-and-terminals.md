# ターミナルは遺物か

## ――コマンドラインの本質を問い直す

### 第4回：テレタイプからCRT端末へ――"tty"の起源と端末の進化

**連載「ターミナルは遺物か――コマンドラインの本質を問い直す」**
**著：佐藤裕介（Engineers Hub株式会社 CEO / Technical Lead）**

---

**この回で学べること：**

- 「ターミナル」という言葉が何を模倣しているのか――Teletype社の物理端末に遡る歴史
- Teletype Model 33（1963年）がASCIIの最初の商用実装であり、110ボーの制約がプロトコル設計を規定した事実
- ASCIIの設計思想と制御文字の起源――Bob Bemerの「ESC」「バックスラッシュ」「波括弧」の導入
- CR/LFの二重改行がテレタイプの物理動作に由来し、UNIX vs DOS/Windowsの改行コード問題の根源となった経緯
- DEC VT05（1970年）からVT100（1978年）への端末の進化と、IBM 3270がもたらした80x24の標準化
- xtermの誕生（1984年）がハードウェア端末のソフトウェア置換の先駆となったこと
- `stty`コマンドの設定項目が物理端末の制約の名残であることの実践的確認

---

## 1. `/dev/tty`の正体

ある日、私はLinuxのデバイスファイルを眺めていた。

```
$ ls /dev/tty*
/dev/tty  /dev/tty0  /dev/tty1  /dev/tty2 ...
```

`tty`。この三文字の略語が何を意味するのか、当時の私は知らなかった。

`man tty`を引くと「controlling terminal」とある。端末。だが「tty」という綴りからは何も読み取れない。略語であることは明らかだが、何の略なのか。

調べ始めて、思いがけない場所にたどり着いた。Teletype Corporation。1902年に遡る電信機器メーカーだ。「tty」は「teletype」の略であり、もっと正確には「teletypewriter」――遠隔で文字を打てる電動タイプライター――の略称だった。

```
$ stty -a
speed 38400 baud; rows 50; columns 200; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; ...
```

`stty`コマンドの出力を見たとき、さらに驚いた。`baud`（ボーレート）、`erase`（一文字消去）、`kill`（一行消去）、`intr`（割り込み）、`eof`（ファイル末尾）。これらのパラメータは、シリアル回線で接続された物理端末の動作を制御するためのものだった。2026年の今、私の端末はソフトウェアでエミュレートされており、シリアル回線も物理端末も存在しない。にもかかわらず、`stty`は今でもボーレートを報告し、制御文字のマッピングを管理している。

前回、CTSSのデモンストレーションでは、ユーザーはFlexowriter端末を通じてコンピュータと対話した。紙に印字する電動タイプライター型の端末だ。あなたが毎日起動するターミナルエミュレータは、この物理端末を模倣している。だが、60年以上前のハードウェアの何を、なぜ、今なお模倣し続けているのか。

今あなたが使っている「ターミナル」は、何を模倣しているのか。

この問いに答えるために、テレタイプの誕生から始めよう。`/dev/tty`という名前の背後にある歴史は、予想以上に深い。

---

## 2. テレタイプの時代――文字を電線で送る

### Teletype Corporation：電信から端末へ

テレタイプの歴史は、電信の歴史と重なる。

1902年、シカゴの電気技師Charles Krumが、電信回線を通じて文字を自動的に印字する機械の発明に取り組んだ。それ以前の電信はモールス信号に依存していた。「・」と「−」の組み合わせを人間が聴き取り、手動で文字に変換する。熟練のオペレータが必要であり、速度は人間の能力に制約されていた。Krumの目標は、タイプライターのキーボードで文字を入力すると、遠隔地のプリンターに同じ文字が自動的に印字されるシステムだった。

Krumの発明は改良を重ね、テレタイプ（teleprinter、teletypewriter）として商用化された。1930年、AT&Tがテレタイプ事業を買収し、Teletype Corporationを子会社として設立した。ここから「テレタイプ」は一般名詞であると同時にAT&Tの商標となり、後にUNIXの用語「tty」として永続することになる。UNIXがBell Labs（AT&Tの研究部門）で誕生したことを考えれば、テレタイプ端末がデバイス名として採用されたのは自然な帰結だった。

### Teletype Model 33：ASCIIの物理的な実装

1963年、Teletype CorporationはModel 33を発売した。この端末が、コンピュータの歴史において特別な位置を占める理由は二つある。第一に、ASCIIコードの最初の商用実装だったこと。第二に、圧倒的な普及規模を達成したことである。

Model 33の仕様を見てみよう。

```
Teletype Model 33（1963年）:

通信速度:   110ボー（毎秒約10文字）
文字コード: ASCII（7ビット + パリティ1ビット = 8ビット）
電気仕様:   20mA電流ループ
モデル:     ASR（紙テープリーダー/パンチ付き）
            KSR（キーボード送受信のみ）
            RO（受信印字のみ）
生産台数:   50万台以上
重量:       約15.9kg（ASRモデル）
```

110ボーという速度は、現代の基準では信じがたいほど遅い。1秒あたり約10文字。この文を読むのにかかる時間よりも、1行の出力に時間がかかる計算になる。だが1963年当時、この速度は電話回線を介した通信として十分実用的だった。

Model 33は三つのバリエーションで提供された。ASR（Automatic Send-Receive）は紙テープの読み書き装置を備えた完全版であり、プログラムやデータを紙テープに保存し、再実行できた。KSR（Keyboard Send-Receive）はキーボードとプリンターのみで紙テープ装置を省いた廉価版。RO（Receive Only）は受信した文字を印字するだけの出力専用機だった。

50万台以上という生産台数は、この時代のコンピュータ周辺機器としては驚異的な数字だ。Model 33の低価格（約750ドル、当時の他の端末の数分の一）と信頼性が普及を支えた。この圧倒的な市場シェアが、ASCIIコードの事実上の標準化を推し進めた。コードの「標準」は仕様書で決まるのではない。市場に最も多く存在するデバイスが決める。

### ASCIIの誕生：1963年と1967年

Model 33が実装したASCII（American Standard Code for Information Interchange）は、1963年に最初の版が公開された。だが、ASCIIの設計は一夜にして完成したものではない。

1960年代初頭、コンピュータメーカー各社は独自の文字コードを使用していた。IBMのBCD（Binary Coded Decimal）、EBCDIC（Extended Binary Coded Decimal Interchange Code）、Baudotコードの各種派生。データ交換のたびに文字コードの変換が必要であり、互換性の問題は深刻だった。

ASCIIの設計にあたり、中心的な役割を果たしたのがBob Bemerだった。IBMのプログラマであり、後に「ASCIIの父」と呼ばれる人物である。Bemerの貢献で特に重要なのは三つの文字の導入だ。

第一に、ESC（Escape、ASCII 27）。この制御文字は「次に続く文字列を通常の文字としてではなく、制御命令として解釈せよ」という指示である。ESCの導入により、7ビットの限られたコード空間を超えた拡張が可能になった。後のANSIエスケープシーケンスの基盤であり、今日のターミナルでカーソル移動や色付けを実現する仕組みの起点だ。

第二に、バックスラッシュ（`\`、ASCII 92）。当初のASCII案にはバックスラッシュは含まれていなかった。Bemerがこの文字を提案したのは、論理演算子やエスケープ文字としての用途を見越してのことだった。後にC言語のエスケープシーケンス（`\n`、`\t`など）に不可欠な文字となり、UNIXのパスとWindowsのパスの違い（`/` vs `\`）という今日まで続く分裂の種ともなった。

第三に、波括弧（`{}`、ASCII 123/125）。数学的記法やプログラミング言語の構文要素として導入された。C言語のブロック構文 `{ }` を経て、JavaやJavaScript、そしてJSON（JavaScript Object Notation）に至るまで、波括弧はプログラミングの基本構文として君臨している。

ASCIIの最初の版（1963年）から1967年の大幅改定を経て、7ビット128文字のコード体系が確定した。128文字のうち、最初の32文字（0〜31）と最後の1文字（127、DEL）は制御文字である。残りの95文字が印字可能文字だ。

```
ASCIIコード表（抜粋）:

制御文字（0-31, 127）:
  0  NUL  (Null)           -- 無意味、時間稼ぎ用
  7  BEL  (Bell)           -- ベルを鳴らす
  8  BS   (Backspace)      -- 一文字戻る
  9  HT   (Horizontal Tab) -- 水平タブ
 10  LF   (Line Feed)      -- 改行（次の行へ）
 13  CR   (Carriage Return) -- 復帰（行頭へ）
 27  ESC  (Escape)         -- エスケープシーケンス開始
127  DEL  (Delete)         -- 削除

印字可能文字（32-126）:
 32  SP   (Space)
 48-57   0-9
 65-90   A-Z
 97-122  a-z
 92  \    (Backslash)
123  {    (Left Curly Bracket)
125  }    (Right Curly Bracket)
```

この制御文字の一つ一つが、物理端末の動作に対応していた。BEL（ASCII 7）はテレタイプの内蔵ベルを物理的に鳴動させる制御コードだ。この文字の起源は1870年代のBaudot符号の時代にまで遡る。電信オペレータの注意を喚起するために電気的にベルを鳴らす仕組みは、テレタイプ以前から存在していた。今日のターミナルで `echo -e '\a'` を実行すると、システムがビープ音を鳴らす（あるいはタイトルバーが点滅する）。150年前の電信ベルの名残である。

BS（Backspace、ASCII 8）は印字ヘッドを一文字分だけ戻す動作に対応する。ただし、テレタイプは紙に印字するため、文字を消すことはできない。印字ヘッドを戻して別の文字を重ね打ちすることで「修正」としていた。下線付き文字（`_`をバックスペースして文字を打つ）もこの仕組みだった。DEL（ASCII 127）が全ビット1（1111111）なのは、紙テープ上の既存の穴に対して全位置に穴を追加で開けることで文字を「削除」できる物理的な理由による。

NUL（Null、ASCII 0）が全ビット0なのも偶然ではない。紙テープ上で穴が一つも開いていない状態がNULであり、テープの先頭や末尾に無意味な空白を入れるために使用された。情報を何も持たない「空虚な文字」が、今日のC言語で文字列終端を示す `\0` として生き残っている。

### CR/LF：テレタイプの物理動作が生んだ改行問題

テレタイプが残した最も有名な遺産の一つが、改行コードの分裂だ。

テレタイプの印字機構は、タイプライターと同じ原理で動作する。紙の上を印字ヘッドが左から右に移動しながら文字を印字し、行の末端に達すると二つの動作が必要になる。

第一に、CR（Carriage Return、ASCII 13）。印字ヘッドを行の左端に戻す。タイプライターでレバーを押してキャリッジ（紙を載せた台）を右端に戻す動作と同じだ。「復帰」と訳される。

第二に、LF（Line Feed、ASCII 10）。紙を一行分上に送る。つまり、印字位置を次の行に移す。「改行」と訳される。

物理的なテレタイプでは、この二つの動作は独立した機構で行われていた。そしてここに、物理的な制約が介入する。Model 33では、キャリッジを行の左端に戻す動作に約0.2秒を要した。110ボーの通信速度では1文字の送信に約0.09秒かかるため、0.2秒は約2文字分の時間に相当する。

つまり、CRを送った直後にLFを送り、さらに次の行の最初の文字を送ると、キャリッジがまだ左端に戻りきっていない位置で印字が始まってしまう。この問題を回避するために、CRの後にNULやフィラー文字を挿入して時間を稼ぐ慣行が生まれた。あるいはCR+LFの順序を守ることで、LFの処理時間分をキャリッジの移動時間に充てることもできた。

この物理的制約が、後の改行コード問題の原因となった。

```
改行コードの系譜:

テレタイプ:   CR+LF（物理動作に忠実）
Multics:      LF のみ（CR+LF を抽象化）
UNIX:         LF のみ（Multicsを継承）
CP/M:         CR+LF（テレタイプ互換）
DOS/Windows:  CR+LF（CP/Mを継承）
macOS(旧Mac): CR のみ（Mac OS 9まで）
macOS(OS X~): LF のみ（BSD UNIXベース）
HTTP:         CR+LF（RFC準拠）
```

UNIXがLFのみを採用したのは、Multicsの設計を簡略化した結果だ。テレタイプの物理的制約をOSレベルで抽象化し、端末ドライバが必要に応じてLFをCR+LFに変換する。この変換は今日のLinuxでも `stty` の `onlcr`（Output NL to CR-LF）オプションとして残っている。

一方、CP/MとそれをMicrosoftが引き継いだMS-DOS、そしてWindowsは、テレタイプ時代のCR+LFをそのまま維持した。2026年の今なお、`git config core.autocrlf` という設定が存在し、開発者はWindows/UNIX間の改行コード変換に悩まされている。

60年前のテレタイプの物理機構が0.2秒余計にかかるという事実が、2026年のソフトウェア開発のワークフローに影響を与え続けている。技術の歴史において、物理的制約が抽象化を超えて生き残る力は、しばしば予想を超える。

---

## 3. 画面が書き換わる――CRT端末の革命

### DEC VT05：最初のCRT端末（1970年）

テレタイプの時代、出力は紙に印字されていた。一度印字された文字は消せない。画面をクリアすることもできない。出力はひたすら紙テープの上に蓄積され、やがて床に溢れた。

CRT（Cathode Ray Tube、陰極線管）ディスプレイの端末への応用は、この限界を根本的に打破した。画面上の任意の位置に文字を表示し、書き換え、消去できる。「画面」という概念の導入は、テキストの表示にとってパラダイムの転換だった。

1970年11月、Digital Equipment Corporation（DEC）は最初のCRT端末、VT05を出荷した。

```
DEC VT05（1970年11月）:

表示:       72列 x 20行（大文字のみ）
通信速度:   最大2400ボー
カーソル:   あり（ダイレクトカーソルアドレッシング対応）
文字セット: 大文字ASCIIのみ
表示方式:   CRTディスプレイ
```

72列x20行。現代のターミナルの80x24と比べると一回り小さい。大文字のみという制約は、当時のハードウェアの文字生成回路の限界を反映している。小文字を表示するにはディセンダ（g, j, p, q, yなどの文字の下に伸びる部分）を処理する必要があり、文字セル内の垂直解像度を増やさなければならなかった。

VT05の最も重要な技術的貢献は、ダイレクトカーソルアドレッシングの導入だった。テレタイプでは、印字ヘッドは常に「次の位置」に進むだけだった。VT05では、特定のエスケープシーケンスを送ることで、画面上の任意の位置にカーソルを移動させることができた。画面の特定の場所の文字だけを書き換える、という操作が初めて可能になったのだ。

これは、後の全画面エディタ（viやEmacsなど）の前提条件である。テレタイプでは `ed`（ラインエディタ）が限界だった。画面上の任意の位置に文字を配置できるCRT端末があって初めて、`vi` のような「画面全体を使ったテキスト編集」が実現可能になった。

### DEC VT52：独自エスケープシーケンスの時代（1975年）

1975年9月、DECはVT52を発表した。

```
DEC VT52（1975年9月）:

表示:       80列 x 24行
通信速度:   最大19200ボー
文字セット: 大文字・小文字ASCII
カーソル制御: 独自エスケープシーケンス
スクロール:  双方向スクロール対応
```

VT52は二つの点でVT05から大きく進歩した。第一に、80列x24行の表示。この画面サイズが、後に事実上の標準となる。第二に、より体系的なエスケープシーケンスの導入だ。

VT52のエスケープシーケンスは `ESC` に続く1文字で端末の動作を制御する方式だった。例えば:

```
VT52 エスケープシーケンス（抜粋）:

ESC A  -- カーソルを上に移動
ESC B  -- カーソルを下に移動
ESC C  -- カーソルを右に移動
ESC D  -- カーソルを左に移動
ESC H  -- カーソルをホーム位置（左上）に移動
ESC J  -- カーソル位置から画面末尾まで消去
ESC K  -- カーソル位置から行末まで消去
ESC Y row col -- カーソルをrow行col列に移動
```

この方式は直感的で実装も単純だったが、問題があった。DECの独自仕様だったのだ。Hazeltine、Lear Siegler、Televideo、Wyseなど各社がそれぞれ異なるエスケープシーケンスを使用しており、あるメーカーの端末で動作するプログラムが、別のメーカーの端末では正しく表示されなかった。

この端末間の非互換性は、後にBSDのterminfoデータベースやGNUのncursesライブラリが解決に取り組むことになる重大な問題だった。だがVT52の時点では、各メーカーの独自路線が拡大し続けていた。

### IBM 3270：もう一つの端末哲学（1971年）

DECがVTシリーズで「文字モード」端末を進化させていた同時期、IBMはまったく異なる哲学の端末を開発していた。

1971年、IBMはIBM 3270端末を発表した。IBM 2260の後継として設計された3270は、「ブロックモード」という独自のアーキテクチャを採用していた。

```
DEC VT系（文字モード）vs IBM 3270（ブロックモード）:

┌─ DEC VT系 ─────────────────────┐
│                                 │
│ 端末 ←→ ホスト                 │
│                                 │
│ 1文字入力するたびに             │
│ ホストに送信                    │
│                                 │
│ ホストが1文字ずつ               │
│ エコーバックして表示             │
│                                 │
│ → 回線帯域を常に消費            │
│ → 応答性がネットワーク遅延に依存 │
└─────────────────────────────────┘

┌─ IBM 3270 ──────────────────────┐
│                                 │
│ 端末 ←→ ホスト                 │
│                                 │
│ ローカルバッファに入力           │
│ （端末側でエコー表示）           │
│                                 │
│ Enterキー（送信キー）で          │
│ 画面全体のデータを一括送信       │
│                                 │
│ → 回線帯域を効率的に使用         │
│ → 入力中のレイテンシなし         │
└─────────────────────────────────┘
```

文字モードの端末（VTシリーズ）では、ユーザーがキーボードで1文字打つたびに、その文字がホストコンピュータに送信される。ホストはその文字を処理し、エコーバック（画面に表示するために文字を送り返すこと）する。つまり、キーを打つたびにネットワークを往復する。

ブロックモードのIBM 3270では、端末自体がローカルバッファ（画面メモリ）を持っていた。ユーザーの入力は端末側で即座に画面に表示され、ホストには送信されない。ユーザーがEnterキー（3270では「送信キー」）を押すと、画面全体の変更内容がまとめてホストに送信される。

この設計は、1971年当時の通信回線のコストと速度を考えれば極めて合理的だった。1文字ごとに往復するDEC方式は回線を浪費する。画面全体を一括送信するIBM方式は回線効率が高い。同軸ケーブルで接続されたIBM 3270は、SNA（Systems Network Architecture）上で多数の端末を一つの制御装置（3274/3276）に集約でき、大規模なオフィス環境に適していた。

IBM 3270の表示は80列x24行だった。この80x24という画面サイズは、3270の市場での成功を通じて、CRT端末の事実上の標準として確立されていく。80列はパンチカードの列数に由来し、24行はCRTの垂直解像度とフォントサイズの兼ね合いで決まったものだった。righto.comのKen Shirriffが詳細に分析しているように、IBM 2260（3270の前身）の24行という行数は、ソニック遅延線メモリの容量制約に由来する。文字データを超音波の遅延線に格納する仕組みでは、遅延線の物理的な長さが格納可能な文字数を決定し、その結果として80x24（1,920文字）が上限となった。物理的な制約が標準を規定する、いつものパターンだ。

しかし、IBM 3270の設計哲学は、UNIXの世界とは根本的に相容れなかった。UNIXのシェルはキーボード入力を1文字ずつ処理することを前提としている。タブ補完、ヒストリ検索、行編集――これらはすべて文字モードの動作モデルに依存する。3270のブロックモードでは、`Ctrl+C`で実行中のプロセスに割り込むことすらできない（画面データは送信キーを押すまでホストに届かないからだ）。UNIXの対話的操作の本質は「1文字ごとのフィードバック」であり、3270の「フォーム入力→一括送信」モデルとは根本から異なる。

DECのVTシリーズが事実上のUNIX標準端末となり、IBMの3270はメインフレームの世界に留まった。二つの端末哲学は、二つのコンピューティング文化を反映していた。

### DEC VT100：決定版の登場（1978年）

1978年8月、DECはVT100を発表した。VT100は「ビデオ端末の決定版」と呼ばれ、その後のすべてのターミナルエミュレータの基準点となった。

```
DEC VT100（1978年8月）:

表示:       80列 x 24行（標準モード）
            132列 x 14行（ワイドモード）
プロセッサ: Intel 8080
通信速度:   50〜19200bps
準拠規格:   ANSI X3.64（端末制御シーケンスの標準規格）
機能:       スムーズスクロール
            ダブルハイト/ダブルワイド文字
            セットアップモード（端末設定をメニュー形式で変更）
生産実績:   VTシリーズ累計600万台以上
```

VT100の歴史的意義は三つに集約される。

第一に、ANSI X3.64（後のISO 6429/ECMA-48）への準拠。VT52までのDEC独自仕様ではなく、業界標準のエスケープシーケンスを採用した。これにより、VT100対応のソフトウェアは、他のANSI準拠端末でも動作する可能性が開けた。`ESC [`で始まるCSI（Control Sequence Introducer）シーケンスは、VT100が普及させたものだ。

```
VT100 / ANSI エスケープシーケンス（抜粋）:

ESC [ H       -- カーソルをホーム位置に移動
ESC [ 2 J     -- 画面全体を消去
ESC [ n A     -- カーソルをn行上に移動
ESC [ n B     -- カーソルをn行下に移動
ESC [ n ; m H -- カーソルをn行m列に移動
ESC [ 1 m     -- 太字
ESC [ 4 m     -- 下線
ESC [ 7 m     -- 反転
ESC [ 0 m     -- 属性リセット
```

第二に、Intel 8080プロセッサの内蔵。VT100はCPUを搭載した「スマート端末」であり、端末自体がエスケープシーケンスの解析、スクロール制御、文字属性の管理を行った。ホストコンピュータの負荷を軽減し、より豊富な画面制御を可能にした。

第三に、圧倒的な市場シェア。VTシリーズは累計600万台以上が生産され、1980年代のほぼすべてのUNIXシステムはVT100互換端末を前提として設計された。`TERM=vt100` という環境変数は、今日のLinuxシステムでもフォールバック値として使われている。

VT100の成功は、ネットワーク効果によるところが大きい。端末が広く普及すればするほど、その端末をサポートするソフトウェアが増え、ソフトウェアが増えればさらに端末が売れる。VT52時代の「各社独自路線」の混沌は、VT100のANSI準拠と市場支配によって収束した。

ただし、「標準」とは常に政治的なプロセスでもある。ANSI X3.64規格の策定にはDECの影響が大きく、VT100の機能が標準に取り込まれた面も否定できない。標準が製品を規定するのか、支配的な製品が標準を規定するのか。この循環は、後のHTMLにおけるInternet Explorer、あるいはECMAScriptにおけるNetscape/V8にも繰り返されるパターンである。

### ボーレートの進化が変えたUX

テレタイプからVT100に至る端末の進化は、画面の大型化やCRTの導入だけではない。通信速度の向上が、ユーザー体験を根本的に変えた。

```
ボーレートの進化と体感速度:

110ボー（1963年, Model 33）:
  → 毎秒約10文字
  → 80文字の1行を表示するのに約8秒
  → 24行の画面全体を埋めるのに約3分

300ボー（1970年代前半, 音響カプラ時代）:
  → 毎秒約30文字
  → 1行: 約2.7秒
  → 全画面: 約1分

9600ボー（1970年代後半, 専用回線）:
  → 毎秒約960文字
  → 1行: 約0.08秒（ほぼ瞬時）
  → 全画面: 約2秒

19200ボー（1978年, VT100の最大速度）:
  → 毎秒約1920文字
  → 1行: 約0.04秒
  → 全画面: 約1秒
```

110ボーの世界では、コマンドの出力が一行ずつゆっくりと印字されていく様子を眺めることになる。プログラマは「出力が遅い」ことを前提としてツールを設計した。UNIXの `head` コマンド（先頭の数行だけ表示）や `grep`（条件に合致する行だけ抽出）は、「全部表示すると時間がかかりすぎる」という制約から生まれたツールだ。

Bill Joyが1976年にviエディタを開発した際、Joy自身が使っていたADM-3A端末は300ボーの接続だった。viの設計哲学――最小のキーストロークで最大の編集操作を実現する――は、1文字の送信すら惜しい低速回線の制約から生まれた。`hjkl`によるカーソル移動は、ADM-3A端末のキーボードに矢印キーがなく、`hjkl`キーに矢印が刻印されていたことに由来する。

9600ボーに達すると、全画面の書き換えが「ほぼ瞬時」に感じられるようになった。ここで初めて、全画面エディタやcursesベースのTUI（Text User Interface）が実用的になった。viが1976年にADM-3A上で開発され、Emacsが1976年にMITのITSで形を整えたのは、この通信速度の向上と無縁ではない。

VT100の19200ボーでは、画面全体を約1秒で書き換えられた。これにより、スクロール、ページ切り替え、画面分割といった操作がスムーズに行えるようになった。VT100がスムーズスクロール機能を備えていたのは、この速度があって初めて意味を持つ機能だったからだ。

通信速度の制約がツールの設計を規定し、速度が向上するとツールの可能性が拡張される。この関係は、今日の低帯域環境（SSHでリモートサーバーに接続する際の遅延）でも再現される。Vimが「低帯域に強い」のは、300ボーの時代の設計遺伝子を受け継いでいるからだ。

---

## 4. ソフトウェアが端末を飲み込む――xtermとターミナルエミュレータ

### xterm：ハードウェアの終わりの始まり（1984年）

1984年夏、MITの学生Mark VandevoordはProject Athenaの一環としてxtermを開発した。VT102（VT100の後継）の動作をソフトウェアでエミュレートするプログラムだ。

それ以前にも、ビットマップディスプレイ上にテキスト端末をエミュレートする試みはあった。だがxtermは、X Window System上で動作する標準的なターミナルエミュレータとして広く普及し、ハードウェア端末のソフトウェア置換の決定的な先駆けとなった。

```
ターミナルエミュレータの位置づけ:

1960-70年代: ハードウェア端末の時代
┌─────────────────────────────────────────────┐
│ ホストコンピュータ                          │
│   │                                        │
│   │ シリアル回線（RS-232C）                 │
│   │                                        │
│   ├── Teletype Model 33（テレタイプ）       │
│   ├── DEC VT52（CRT端末）                  │
│   └── DEC VT100（CRT端末）                 │
└─────────────────────────────────────────────┘

1984年〜: ターミナルエミュレータの時代
┌─────────────────────────────────────────────┐
│ ワークステーション / PC                      │
│   ┌────────────────────────────────┐        │
│   │ X Window System                │        │
│   │   ┌────────────────────┐      │        │
│   │   │ xterm              │      │        │
│   │   │ VT102の動作を      │      │        │
│   │   │ ソフトウェアで再現  │      │        │
│   │   └────────────────────┘      │        │
│   └────────────────────────────────┘        │
│   │                                        │
│   │ 疑似端末（pty）                         │
│   │                                        │
│   └── シェル（bash, csh, ...）              │
└─────────────────────────────────────────────┘
```

xtermの登場は、端末の本質について深い問いを投げかけた。ハードウェア端末は、キーボード入力をシリアル信号に変換してホストに送信し、ホストから受信した信号を画面に表示する物理デバイスだった。xtermは、この動作をソフトウェアで忠実に再現する。シリアル回線の代わりに疑似端末（pseudo-terminal、pty）が使われる。物理的なCRTの代わりにビットマップディスプレイのウィンドウが使われる。しかし、ホスト側のOS（カーネルの端末ドライバ）から見れば、xtermは物理端末と区別がつかない。

`/dev/pts/0` というデバイスファイルが、この仕組みを象徴している。`pts` は pseudo-terminal slave の略だ。物理端末の `/dev/tty` に対応するソフトウェア上の端末デバイス。OSは、40年以上前のハードウェアインターフェースを、ソフトウェアで「偽装」し続けている。

この抽象化は強力だ。シェル、エディタ、cursesアプリケーションなど、端末を前提に書かれたすべてのソフトウェアが、一切の修正なしにターミナルエミュレータ上で動作する。後方互換性の維持が、ソフトウェアの進化における最大の制約であると同時に最大の資産であることを、ターミナルエミュレータの歴史は如実に示している。

### ターミナルエミュレータの仕組み

ターミナルエミュレータの内部動作を、もう少し詳しく見てみよう。

```
ターミナルエミュレータの内部構造:

┌──────────────────────────────────────────────┐
│            ターミナルエミュレータ              │
│  ┌────────────────────────────────────────┐  │
│  │ 入力処理                               │  │
│  │  キーボードイベント                     │  │
│  │    → キーコード変換                     │  │
│  │    → エスケープシーケンス生成            │  │
│  │    → pty master fd に write             │  │
│  └────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────┐  │
│  │ 出力処理                               │  │
│  │  pty master fd から read               │  │
│  │    → バイトストリーム解析               │  │
│  │    → 通常文字: セルバッファに書き込み    │  │
│  │    → ESC [ シーケンス: 状態遷移          │  │
│  │      → カーソル移動 / 画面消去          │  │
│  │      → 文字色・背景色変更               │  │
│  │      → スクロール制御                   │  │
│  │    → 画面描画（GPU/ソフトウェア）        │  │
│  └────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────┐  │
│  │ セルバッファ                            │  │
│  │  80列 x 24行 のグリッド                 │  │
│  │  各セル: 文字 + 前景色 + 背景色 + 属性   │  │
│  │  + スクロールバック履歴                  │  │
│  └────────────────────────────────────────┘  │
└──────────────────────────────────────────────┘
        │                     ▲
        │ write               │ read
        ▼                     │
┌──────────────────────────────────────────────┐
│  pty master / pty slave                       │
│  （疑似端末ペア）                             │
│  カーネルの端末ドライバ（line discipline）    │
│    → エコー、行編集、シグナル変換             │
│    → sttyで設定可能なパラメータ群             │
└──────────────────────────────────────────────┘
        │                     ▲
        │ read                │ write
        ▼                     │
┌──────────────────────────────────────────────┐
│  シェルプロセス（bash, zsh, ...）             │
│  子プロセス（ls, grep, vim, ...）             │
└──────────────────────────────────────────────┘
```

カーネルの端末ドライバ（line discipline）が、物理端末時代からの制御機能を提供している。`Ctrl+C`が入力されるとSIGINTシグナルをフォアグラウンドプロセスに送る。`Ctrl+Z`が入力されるとSIGTSTPシグナルを送ってプロセスを一時停止させる。`Ctrl+D`はEOF（End of File）として解釈される。これらの動作は `stty` コマンドで変更可能だ。

```
stty の主要パラメータと物理端末の対応:

speed 38400 baud
  → ボーレート。物理端末のシリアル通信速度。
    ソフトウェア端末では形式的に残っている。

intr = ^C
  → 割り込み文字。Ctrl+C でプロセスに SIGINT を送信。
    物理端末では「BREAK」キーに相当。

quit = ^\
  → 中断文字。Ctrl+\ でプロセスに SIGQUIT を送信。
    コアダンプを生成する「緊急停止」。

erase = ^?
  → 消去文字。Delete/Backspace で1文字削除。
    テレタイプの時代、印字済みの文字は消せなかったため、
    「#」を打って前の文字を取り消す慣習もあった。

kill = ^U
  → 行削除文字。Ctrl+U で入力行全体を取り消し。
    テレタイプでは「@」が行削除文字だった。

eof = ^D
  → EOF。Ctrl+D で入力の終了を通知。

echo
  → エコー。入力した文字を画面に表示する。
    テレタイプでは全二重通信時にホスト側がエコーした。
    半二重通信では端末側でローカルエコーした。

onlcr
  → Output NL to CR-LF。LF を CR+LF に変換して出力。
    テレタイプの物理動作との互換性を維持するための設定。

icrnl
  → Input CR to NL。入力の CR を LF に変換。
    端末によってEnterキーが CR を送るものと
    LF を送るものがあったため。
```

これらのパラメータの一つ一つが、物理端末の時代の制約や慣行の名残だ。`erase`が`^?`（DEL、ASCII 127）と`^H`（BS、ASCII 8）のどちらに設定されているかは、端末の種類によって異なっていた。VT100ではBackspaceキーがDEL（ASCII 127）を送信した。この不統一は2026年の今もSSH接続時にBackspaceキーが効かない問題として時折再現される。

ターミナルエミュレータは、このようにして「物理端末の動作」「カーネルの端末ドライバ」「シェルの行編集」という三層の歴史的蓄積を抱えたまま、現代のコンピューティング環境に存在している。新しい端末エミュレータ（Alacritty、kitty、WezTermなど）はGPUレンダリングやリガチャ対応など現代的な機能を追加しているが、その内部では依然としてVT100互換のエスケープシーケンスを解析し、ptyを通じてカーネルの端末ドライバと通信している。

1963年のTeletype Model 33が「何を打ったら何が起きるか」を定義し、1978年のVT100が「画面のどこに何が表示されるか」を定義し、1984年のxtermが「それをソフトウェアで再現する方法」を定義した。2026年の最新のターミナルエミュレータも、この三層の上に構築されている。

---

## 5. ハンズオン：端末の記憶に触れる

理論だけではなく、実際に手を動かして端末の歴史的遺産を体感しよう。以下のハンズオンでは、Docker環境を使用する。

### 演習1：stty -a の各パラメータの歴史的由来

`stty -a` の出力を一つ一つ読み解き、物理端末の制約がどのように現代のシステムに残存しているかを確認する。

```bash
# Docker環境で実行
docker run --rm -it ubuntu:24.04 bash -c '
echo "=============================================="
echo "[演習1] stty -a のパラメータと物理端末の対応"
echo "=============================================="
echo ""

echo "--- 現在の端末設定 ---"
stty -a
echo ""

echo "--- 歴史的由来の解説 ---"
echo ""
echo "1. speed（ボーレート）:"
BAUD=$(stty speed)
echo "   現在の設定: ${BAUD} baud"
echo "   Teletype Model 33: 110 baud（毎秒約10文字）"
echo "   DEC VT100: 最大19200 baud"
echo "   現在の値はソフトウェア端末のため形式的なもの"
echo ""

echo "2. rows / columns:"
ROWS=$(stty size | cut -d" " -f1)
COLS=$(stty size | cut -d" " -f2)
echo "   現在の設定: ${ROWS} rows x ${COLS} columns"
echo "   VT05 (1970): 20行 x 72列"
echo "   VT100 (1978): 24行 x 80列（標準モード）"
echo "   IBM 3270 (1971): 24行 x 80列"
echo "   80列の起源: 1928年のパンチカード（80列フォーマット）"
echo ""

echo "3. 制御文字マッピング:"
echo "   intr = ^C  : 割り込み（SIGINT送信）"
echo "     → テレタイプの BREAK キーに相当"
echo "   quit = ^\   : 中断（SIGQUIT + コアダンプ）"
echo "     → 緊急停止。物理端末時代の非常手段"
echo "   erase = ^?  : 1文字削除"
echo "     → DEL (ASCII 127)。紙テープの全穴パンチに由来"
echo "   kill = ^U   : 行全体の取り消し"
echo "     → テレタイプ時代は @ が行削除文字だった"
echo "   eof = ^D    : 入力終了（EOF）"
echo "     → シリアル回線でデータの終端を示す"
echo ""

echo "4. 入出力変換フラグ:"
echo "   onlcr : 出力時に LF を CR+LF に変換"
echo "     → テレタイプの物理動作: 印字ヘッド戻し(CR) + 紙送り(LF)"
echo "     → UNIX内部は LF のみだが、端末出力時に CR を補う"
echo "   icrnl : 入力時に CR を LF に変換"
echo "     → Enter キーが CR を送る端末との互換性"
echo "   echo  : 入力文字をエコー表示"
echo "     → 全二重通信でホスト側がエコーする仕組みの名残"
echo ""

echo "--- 実験: onlcr を無効にするとどうなるか ---"
echo "onlcr が有効（デフォルト）:"
printf "Line 1\nLine 2\nLine 3\n"
echo ""
echo "onlcr を無効にした場合の出力:"
stty -onlcr
printf "Line 1\nLine 2\nLine 3\n"
stty onlcr
echo ""
echo "↑ LF のみでは印字ヘッド（カーソル）が行頭に戻らず"
echo "  次の行が前の行の末尾位置から始まる"
echo "  これがテレタイプの物理動作の再現"
echo ""
echo "=============================================="
'
```

`stty -onlcr` でonlcrフラグを無効にした瞬間、出力が階段状にずれる現象が起きる。LF（改行）だけでは行頭に戻らない――これはまさにテレタイプの物理的動作だ。印字ヘッドは紙を一行送るだけで、左端には戻らない。CRが別途必要なのだ。2026年のターミナルでこの動作を再現できること自体が、カーネルの端末ドライバがテレタイプの物理モデルを忠実に引き継いでいることの証拠である。

### 演習2：制御文字の動作実験

ASCIIの制御文字が物理端末のどのような動作に対応していたかを、実際に確認する。

```bash
docker run --rm -it ubuntu:24.04 bash -c '
echo "=============================================="
echo "[演習2] 制御文字の動作実験"
echo "=============================================="
echo ""

echo "--- ASCII制御文字の物理端末対応 ---"
echo ""

echo "1. BEL (ASCII 7) - ベル:"
echo "   テレタイプの内蔵ベルを物理的に鳴動させる制御コード"
echo "   1870年代のBaudot符号時代から存在"
echo -n "   実行: "
printf "\a"
echo "(ベル音またはビジュアルベルが発生)"
echo ""

echo "2. BS (ASCII 8) - バックスペース:"
echo "   テレタイプでは印字ヘッドを1文字分戻す"
echo "   紙に印字済みの文字は消せないため、重ね打ちになる"
echo -n "   デモ: ABC"
printf "\b\b\bXYZ"
echo " ← ABCをXYZで上書き（バックスペース3回+再印字）"
echo ""

echo "3. HT (ASCII 9) - 水平タブ:"
echo "   テレタイプのタブストップ位置まで印字ヘッドを移動"
echo "   デフォルトでは8文字間隔"
printf "   デモ: A\tB\tC\n"
echo ""

echo "4. CR (ASCII 13) - キャリッジリターン:"
echo "   印字ヘッドを行の左端に戻す（行は変えない）"
echo "   テレタイプの物理的なキャリッジ戻し動作"
echo -n "   デモ: "
printf "XXXXXXXXXX\rHELLO"
echo " ← 先にXを10個書き、CRで戻ってHELLOで上書き"
echo ""

echo "5. LF (ASCII 10) - ラインフィード:"
echo "   紙を1行分送る（カーソルを下に移動）"
echo "   CRと組み合わせて改行動作を実現"
echo ""

echo "6. ESC (ASCII 27) - エスケープ:"
echo "   Bob Bemerが導入。後続の文字列を制御命令として解釈"
echo "   ANSI エスケープシーケンスの基盤"
echo -n "   デモ: "
printf "\033[1mBOLD\033[0m "
printf "\033[4mUNDERLINE\033[0m "
printf "\033[7mREVERSE\033[0m"
echo ""
echo "   → ESC[1m: 太字, ESC[4m: 下線, ESC[7m: 反転"
echo ""

echo "7. DEL (ASCII 127) - 削除:"
echo "   全ビット1 (1111111)"
echo "   紙テープの全位置に穴を開けて文字を無効化する操作に由来"
echo "   VT100ではBackspaceキーがDELを送信した"
echo ""

echo "--- 制御文字とシグナルの対応 ---"
echo ""
echo "以下のCtrlキーの組み合わせは、カーネルの端末ドライバが"
echo "対応するシグナルに変換する:"
echo ""
echo "  Ctrl+C → SIGINT  (割り込み, プロセスを中断)"
echo "    テレタイプの BREAK 信号に相当"
echo "    stty設定: intr = ^C"
echo ""
echo "  Ctrl+D → EOF (End of File)"
echo "    シリアル回線の入力終了通知"
echo "    stty設定: eof = ^D"
echo ""
echo "  Ctrl+Z → SIGTSTP (一時停止, Terminal Stop)"
echo "    プロセスを一時停止してバックグラウンドに回す"
echo "    stty設定: susp = ^Z"
echo ""
echo "  Ctrl+\\ → SIGQUIT (中断 + コアダンプ)"
echo "    SIGINTより強い中断。デバッグ用コアダンプを生成"
echo "    stty設定: quit = ^\\"
echo ""
echo "  Ctrl+S → XOFF (送信停止)"
echo "  Ctrl+Q → XON  (送信再開)"
echo "    ソフトウェアフロー制御。テレタイプの時代、"
echo "    印字速度が追いつかない場合に送信を止める仕組み"
echo "    stty設定: stop = ^S, start = ^Q"
echo ""

echo "--- 実験: raw モードと cooked モード ---"
echo ""
echo "端末ドライバには2つの基本モードがある:"
echo ""
echo "cooked モード（canonical, デフォルト）:"
echo "  - 行単位でバッファリング"
echo "  - Enterを押すまでデータはプログラムに渡らない"
echo "  - Backspaceで編集可能"
echo "  - Ctrl+Cでシグナル送信"
echo "  → テレタイプの行単位入力モデルに対応"
echo ""
echo "raw モード:"
echo "  - 1文字ずつ即座にプログラムに渡す"
echo "  - バッファリングなし"
echo "  - 制御文字の解釈なし"
echo "  - Ctrl+CもそのままASCIIコード3として渡る"
echo "  → vi/Emacsなど全画面アプリが使用"
echo ""
echo "=============================================="
'
```

ここで特に注目すべきは、`Ctrl+S`と`Ctrl+Q`のXON/XOFFフロー制御だ。テレタイプやCRT端末の時代、ホストからのデータ送信速度が端末の処理速度（印字速度や画面描画速度）を超えると、データが失われた。端末はXOFF（`Ctrl+S`、ASCII 19）をホストに送信して「データの送信を止めてくれ」と要求し、準備ができたらXON（`Ctrl+Q`、ASCII 17）を送信して「送信を再開してよい」と通知した。

2026年の今でも、ターミナルで誤って`Ctrl+S`を押すと画面が「固まった」ように見える。実際にはXOFFが送信されて端末ドライバが出力を停止しているだけであり、`Ctrl+Q`を押せば再開する。この挙動を知らずに「端末がフリーズした」と慌てる開発者は少なくない。40年前のフロー制御プロトコルが、今日のUXの「罠」として残存している例だ。

### 演習3：ボーレート制限のシミュレーション的体験

110ボー（Teletype Model 33の速度）の世界を疑似的に体験する。

```bash
docker run --rm -it ubuntu:24.04 bash -c '
apt-get update -qq && apt-get install -y -qq bc > /dev/null 2>&1

echo "=============================================="
echo "[演習3] ボーレート制限の疑似体験"
echo "=============================================="
echo ""

# 指定したボーレートに基づいた遅延で文字を出力する関数
slow_print() {
    local text="$1"
    local baud="$2"
    local char_delay

    # 1文字あたりの遅延時間（秒）を計算
    # ASCII 8bit + start bit + stop bit = 10 bits per char
    char_delay=$(echo "scale=4; 10 / $baud" | bc)

    local i=0
    while [ $i -lt ${#text} ]; do
        printf "%s" "${text:$i:1}"
        sleep "$char_delay"
        i=$((i + 1))
    done
}

echo "--- 110ボー: Teletype Model 33 (1963) の速度 ---"
echo "毎秒約10文字。80文字の1行に約8秒。"
echo ""
echo "以下のテキストが110ボーで表示される様子を観察:"
echo ""
slow_print "$ ls -la /usr/bin | head -5" 110
echo ""
echo ""
echo "↑ コマンドの入力自体に数秒かかる世界。"
echo "  出力が画面を埋めるのを待つ時間は数分に及ぶ。"
echo ""

echo "--- 300ボー: 1970年代の音響カプラの速度 ---"
echo "毎秒約30文字。体感は110ボーの約3倍。"
echo ""
slow_print "$ grep ERROR /var/log/syslog | tail -3" 300
echo ""
echo ""

echo "--- 9600ボー: 1970年代後半の専用回線 ---"
echo "毎秒約960文字。ようやく「リアルタイム」に近づく。"
echo ""
slow_print "$ cat /etc/passwd | head -10" 9600
echo ""
echo ""
echo "↑ 9600ボーでは、テキストがほぼ瞬時に表示される。"
echo "  全画面エディタ（vi, Emacs）が実用的になった速度域。"
echo ""

echo "--- 速度比較まとめ ---"
echo ""
echo "テキスト「Hello, World!」(13文字) の表示時間:"
echo ""

for baud in 110 300 2400 9600 19200; do
    chars=13
    bits_per_char=10
    time_ms=$(echo "scale=0; $chars * $bits_per_char * 1000 / $baud" | bc)
    printf "  %6d baud: %5d ms" "$baud" "$time_ms"
    if [ "$baud" -eq 110 ]; then
        printf "  (Teletype Model 33, 1963)"
    elif [ "$baud" -eq 300 ]; then
        printf "  (音響カプラ, 1970年代)"
    elif [ "$baud" -eq 2400 ]; then
        printf "  (VT05最大速度, 1970)"
    elif [ "$baud" -eq 9600 ]; then
        printf "  (専用回線, 1970年代後半)"
    elif [ "$baud" -eq 19200 ]; then
        printf "  (VT100最大速度, 1978)"
    fi
    echo ""
done
echo ""

echo "80列x24行の画面全体 (1920文字) の表示時間:"
echo ""
for baud in 110 300 2400 9600 19200; do
    chars=1920
    bits_per_char=10
    time_sec=$(echo "scale=1; $chars * $bits_per_char / $baud" | bc)
    printf "  %6d baud: %6s 秒" "$baud" "$time_sec"
    if [ "$baud" -eq 110 ]; then
        printf "  ← 約3分。vi は実用不可能"
    elif [ "$baud" -eq 9600 ]; then
        printf "  ← 約2秒。vi が実用的に"
    elif [ "$baud" -eq 19200 ]; then
        printf "  ← 約1秒。スムーズスクロール可能"
    fi
    echo ""
done
echo ""

echo "--- この体験から学べること ---"
echo ""
echo "1. UNIXコマンドの設計は低速回線を前提としていた"
echo "   head, tail, grep, less は「全部出力すると遅すぎる」"
echo "   という制約から生まれたフィルタである"
echo ""
echo "2. vi の hjkl キー操作は「1文字でも節約したい」"
echo "   300ボー回線の制約から生まれた設計である"
echo ""
echo "3. パイプ（|）による処理の連鎖は、"
echo "   必要なデータだけを絞り込んで転送量を減らす"
echo "   ネットワーク効率の最適化でもあった"
echo ""
echo "=============================================="
'
```

110ボーの疑似体験は、現代の開発者にとって衝撃的なはずだ。`ls -la` の出力を待つだけで何十秒もかかる。この環境でプログラミングしていた先人たちが、いかに効率的なツールを求めたかが体感できる。UNIXの設計哲学――「一つのことをうまくやるプログラムを作り、それらをパイプで繋げ」――は、美学ではなく、110ボーの回線を効率的に使うための工学的必然だったのだ。

---

## 6. まとめと次回予告

### この回の要点

第一に、「tty」という名前はTeletype Corporationに由来する。1902年にCharles Krumが発明した電信印字機が、1930年にAT&Tに買収されてTeletype Corporationとなり、Bell Labs生まれのUNIXがデバイス名として「tty」を採用した。`/dev/tty`という名前の背後には、120年以上の電信技術の歴史がある。

第二に、1963年のTeletype Model 33はASCIIの最初の商用実装であり、50万台以上の生産台数でASCIIの事実上の標準化を推進した。110ボー、20mA電流ループ、7ビットASCII+パリティという仕様は、後のすべての端末の基盤となった。

第三に、ASCIIの制御文字（BEL、BS、CR、LF、ESC、NUL、DEL）はすべて物理端末の動作に対応しており、Bob Bemerが導入したESC、バックスラッシュ、波括弧は、今日のプログラミング言語とターミナル制御の基本要素として機能し続けている。

第四に、CR/LFの改行コード問題はテレタイプの物理的制約（キャリッジの戻りに0.2秒かかること）に端を発し、UNIX（LFのみ）とDOS/Windows（CR+LF）の分裂として2026年の今も開発者を悩ませている。

第五に、CRT端末の進化（DEC VT05→VT52→VT100）は、紙の端末から画面の端末への移行であると同時に、独自仕様から標準規格（ANSI X3.64）への収束の過程だった。VT100のANSI準拠と600万台超の市場シェアが、ターミナルの「共通言語」を確立した。IBM 3270のブロックモード端末は、異なる設計哲学としてメインフレームの世界で成功したが、UNIXの文字モードの世界とは相容れなかった。

第六に、1984年のxtermは、ハードウェア端末のソフトウェア置換の先駆けとなった。疑似端末（pty）を介した抽象化により、端末を前提に書かれたすべてのソフトウェアが修正なしにターミナルエミュレータ上で動作する。この後方互換性の層は、2026年の最新のターミナルエミュレータにも維持されている。

### 冒頭の問いへの暫定回答

今あなたが使っている「ターミナル」は、何を模倣しているのか。

暫定的な答えはこうだ。**あなたのターミナルエミュレータは、1978年のDEC VT100を模倣している。** そしてVT100は、1963年のTeletype Model 33から始まった端末の系譜を引き継いでいる。`/dev/tty`というデバイス名、`stty`の設定パラメータ、CR/LFの変換処理、`Ctrl+C`のシグナル変換――すべてが、60年前のハードウェアの記憶を宿している。

だが、これは単なる「歴史の残滓」なのだろうか。ソフトウェアが物理端末を完全に置き換えた今、テレタイプ時代のプロトコルを維持し続けることには合理性があるのか。

一つの答えは「後方互換性」だ。40年間蓄積されたソフトウェア資産を壊さないために、古いインターフェースを維持する。もう一つの答えは「抽象化の安定性」だ。「文字のストリームを入力し、文字のストリームが出力される」というモデルは、60年経っても有効な抽象化であり続けている。

「ターミナル」という言葉自体が、60年前のハードウェアの記憶を宿している。そしてその記憶は、ただの懐古ではない。今日のツールが「なぜそう動くのか」を理解するための、不可欠な鍵なのだ。

### 次回予告

VT100がANSI X3.64に準拠したことで、端末の「共通言語」が確立された。だが、`ESC [`で始まるエスケープシーケンスの世界は、想像以上に豊かで複雑だ。

カーソルの移動、文字色の変更、画面の部分消去、スクロール領域の設定。これらの制御命令は、テキストという制約の中で端末の「表現力」をどこまで拡張できるかという挑戦だった。

次回、第5回「ANSIエスケープシーケンス――端末の表現力の拡張」では、`ESC [`に続く数字とアルファベットの羅列が、いかにして色彩とレイアウトを獲得し、テキスト端末をリッチなインターフェースに変えたかを追う。`printf '\033[31mRED\033[0m'`と打ったとき、その背後でVT100の設計思想が動いている。

あなたは、自分のターミナルが何色まで表示できるか、知っているだろうか。

---

## 参考文献

- Wikipedia, "Teletype Model 33", <https://en.wikipedia.org/wiki/Teletype_Model_33>
- Wikipedia, "ASCII", <https://en.wikipedia.org/wiki/ASCII>
- Wikipedia, "Newline", <https://en.wikipedia.org/wiki/Newline>
- Wikipedia, "Teleprinter", <https://en.wikipedia.org/wiki/Teleprinter>
- ETHW, "ASCII 1963", <https://ethw.org/Milestones:American_Standard_Code_for_Information_Interchange_ASCII,_1963>
- Wikipedia, "VT05", <https://en.wikipedia.org/wiki/VT05>
- Wikipedia, "VT52", <https://en.wikipedia.org/wiki/VT52>
- Wikipedia, "VT100", <https://en.wikipedia.org/wiki/VT100>
- Columbia University, "The DEC VT100 Terminal", <https://www.columbia.edu/cu/computinghistory/vt100.html>
- vt100.net, "Digital's Video Terminals", <https://vt100.net/dec/vt_history>
- Wikipedia, "IBM 3270", <https://en.wikipedia.org/wiki/IBM_3270>
- righto.com, "IBM, sonic delay lines, and the history of the 80x24 display", <http://www.righto.com/2019/11/ibm-sonic-delay-lines-and-history-of.html>
- computer.rip, "a history of the tty", <https://computer.rip/2024-02-25-a-history-of-the-tty.html>
- Linus Akesson, "The TTY demystified", <https://www.linusakesson.net/programming/tty/>
- Wikipedia, "Bell character", <https://en.wikipedia.org/wiki/Bell_character>
- Wikipedia, "xterm", <https://en.wikipedia.org/wiki/Xterm>

---

**次回：** 第5回「ANSIエスケープシーケンス――端末の表現力の拡張」

---

_本記事は「ターミナルは遺物か――コマンドラインの本質を問い直す」連載の第4回です。_
_ライセンス：CC BY-SA 4.0_
